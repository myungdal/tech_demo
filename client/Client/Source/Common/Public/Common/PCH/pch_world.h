// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Common/EnumAutoGenerated/Enum.h"
#include "Common/Math/MathUtil.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Engine
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if 0
#pragma pack(push, 1)
struct EngineUpdateChecksum
{
	uint32_t mPosition = 0;
	uint32_t mCharacter = 0;
	uint32_t mPhysics = 0;
	uint32_t mSkill = 0;

	bool IsNotNull() const
	{
		return (mPosition != 0) || (mCharacter != 0) || (mPhysics != 0) || (mSkill != 0);
	}

	bool operator==(const EngineUpdateChecksum& other) const
	{
		return
			(mPosition == other.mPosition) &&
			(mCharacter == other.mCharacter) &&
			(mPhysics == other.mPhysics) &&
			(mSkill == other.mSkill);
	}

	bool operator!=(const EngineUpdateChecksum& other) const
	{
		return
			(mPosition != other.mPosition) ||
			(mCharacter != other.mCharacter) ||
			(mPhysics != other.mPhysics) ||
			(mSkill != other.mSkill);
	}
};
#pragma pack(pop)


template<typename _CharType>
struct std::formatter<EngineUpdateChecksum, _CharType> {
	constexpr auto parse(auto& ctx) { return ctx.end(); }
	auto format(const EngineUpdateChecksum& t, auto& ctx) const {
		std::wstring result = L"";
		tTabStr += std::wstring(L"\t");
		result += std::format(L"\n{}mPosition: {}", tTabStr, t.mPosition);
		result += std::format(L"\n{}mCharacter: {}", tTabStr, t.mCharacter);
		result += std::format(L"\n{}mPhysics: {}", tTabStr, t.mPhysics);
		result += std::format(L"\n{}mSkill: {}", tTabStr, t.mSkill);
		tTabStr.pop_back();
		return std::ranges::copy(result, ctx.out()).out;
	}
};
#else
#pragma pack(push, 1)
struct EngineUpdateChecksum
{
	uint32_t mValue = 0;

	bool IsNotNull() const
	{
		return (mValue != 0);
	}

	bool operator==(const EngineUpdateChecksum& other) const 
	{
		return (mValue == other.mValue);
	}

	bool operator!=(const EngineUpdateChecksum& other) const
	{
		return (mValue != other.mValue);
	}
};
#pragma pack(pop)


template<typename _CharType>
struct std::formatter<EngineUpdateChecksum, _CharType> {
	constexpr auto parse(auto& ctx) { return ctx.end(); }
	auto format(const EngineUpdateChecksum& t, auto& ctx) const {
		std::wstring result = L"";
		tTabStr += std::wstring(L"\t");
		result += std::format(L"\n{}mValue: {}", tTabStr, t.mValue);
		tTabStr.pop_back();
		return std::ranges::copy(result, ctx.out()).out;
	}
};
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// World 기반 관련.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using Scalar = int64_t;
constexpr Scalar MIN_SCALAR = INT64_MIN;
constexpr Scalar MAX_SCALAR = INT64_MAX;
using ScalarPair = std::pair<Scalar, Scalar>;

using Span = int32_t;

using GridCoordinate = int16_t;
constexpr GridCoordinate MAX_GRID_COORDINATE = INT16_MAX;
constexpr GridCoordinate MIN_GRID_COORDINATE = INT16_MIN;

using GridCol = GridCoordinate;
using GridRow = GridCoordinate;
constexpr size_t MAX_GRID_FACTOR = 12;
constexpr GridCol MIN_GRID_COL = 0;
constexpr GridCol MAX_GRID_COL = (1 << MAX_GRID_FACTOR);
constexpr GridRow MIN_GRID_ROW = 0;
constexpr GridRow MAX_GRID_ROW = (1 << MAX_GRID_FACTOR);

using ColRowPair = std::pair<GridCol, GridRow>;
using ColRowStack = std::stack<ColRowPair>;

struct GridBound
{
	GridCol cMin = MAX_GRID_COL;
	GridCol cMax = MIN_GRID_COL;
	GridRow rMin = MAX_GRID_ROW;
	GridRow rMax = MIN_GRID_ROW;

	void Merge(GridCol c, GridRow r)
	{
		if (cMin > c) cMin = c;
		if (cMax < c) cMax = c;
		if (rMin > r) rMin = r;
		if (rMax < r) rMax = r;
	}

	bool Test(GridCol c, GridRow r) const
	{
		return (cMin <= c && cMax >= c && rMin <= r && rMax >= r);
	}
};

// MathUtil.h 에 각종 쉬프트 값에 대한 고찰이 있음.
constexpr Scalar CELL_SIZE_FACTOR = 20;
constexpr Scalar CELL_SIZE_DESIGN_FACTOR = 10;
constexpr Scalar CELL_SIZE = (1LL << CELL_SIZE_FACTOR);
constexpr Scalar CELL_SIZE_MASK = (1LL << CELL_SIZE_FACTOR) - 1;
constexpr float CELL_SIZE_INVERSE = static_cast<float>(1) / static_cast<float>(CELL_SIZE);
constexpr Scalar CELL_SIZE_HALF = (1LL << (CELL_SIZE_FACTOR - 1));

//using HealthPoint = int32_t; StatValue로 변경됨
//using SkillPoint = int32_t; StatValue로 변경됨
//using Damage = int16_t; StatValue로 변경됨

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Game World 관련
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using StaticId = int64_t;
constexpr StaticId INVALID_SID = 0;

using AchievementSid = StaticId;
using AchievementStepSid = StaticId;
using GameSid = StaticId;
using ProductSid = StaticId;
using ConditionSid = StaticId;
using ActivitySid = StaticId;
using RewardSid = StaticId;
using ActionSid = StaticId;
using AcctivitySid = StaticId;
using ItemSid = StaticId;
using StatGroupSid = StaticId;
using MapSid = StaticId;
using ItemGroupSid = StaticId;
using MissionSid = StaticId;
using QuestSid = StaticId;
using SchedureSid = StaticId;
using StockSid = StaticId;
using MailSid = StaticId;

using GameUserId = Uuid;
using GameGuildId = Uuid;

using WorldUserId = int16_t;
constexpr WorldUserId INVALID_WORLD_USER_ID = -1;
constexpr WorldUserId MAX_WORLD_USER_COUNT = 1024;

using StatContainerPtr = uint64_t; // StatContainer*
using ClientCharacterPtr = uint64_t; // void*

using CharacterDocPtr = uint64_t; // CharacterDoc*
using StaticCharacterSkillPtr = uint64_t; // STATIC_CHARACTER_SKILL*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Stat
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using StatValue = int32_t;

using StatArray = std::array<StatValue, static_cast<size_t>(StatType::MAX)>;
using StatNodeArray = std::array<std::unique_ptr<class StatNodeBase>, static_cast<size_t>(StatType::MAX)>;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Entity
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using EntityId = int16_t;
constexpr EntityId INVALID_ENTITY_ID = -1;
using EntityCount = EntityId;
constexpr EntityCount MAX_ENTITY_COUNT = 8192;
using EntityProof = uint16_t;

#pragma pack(push, 1)
struct EntityIdp
{
public:
	EntityId first = INVALID_ENTITY_ID;
	EntityProof second = 0;

public:
	bool operator==(const EntityIdp& val) const noexcept
	{
		return (first == val.first) && (second == val.second);
	}
	bool operator!=(const EntityIdp& val) const noexcept
	{
		return (first != val.first) || (second != val.second);
	}
};
#pragma pack(pop)

template<typename _CharType>
struct std::formatter<EntityIdp, _CharType> {
	constexpr auto parse(auto& ctx) { return ctx.end(); }
	auto format(MAYBE_UNUSED const EntityIdp& t, auto& ctx) const {
		std::wstring result = L"";
		tTabStr += std::wstring(L"\t");
		result += std::format(L"\n{}first: {}", tTabStr, t.first);
		result += std::format(L"\n{}second: {}", tTabStr, t.second);
		tTabStr.pop_back();
		return std::ranges::copy(result, ctx.out()).out;
	}
};

