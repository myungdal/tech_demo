// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "ClientPacketFlowLogin.h"

#include "Packet/NetworkPacketAutoGenerated/PACKET_CD.h"
#include "Packet/NetworkPacketAutoGenerated/PACKET_CF.h"
#include "Packet/NetworkPacketAutoGenerated/PACKET_CG.h"
#include "Packet/NetworkPacketAutoGenerated/PACKET_CM.h"
#include "Packet/StaticDataAccessor/StaticDataAccessor.h"
#include "Packet/StaticDataCatalog/StaticDataCatalog.h"

#include "MmoSync/Engine/Engine.h"
#include "MmoSync/GameInstance/GameInstance.h"

#include "ClientUtil/ClientStringUtil.h"
#include "GameCore/GameCore.h"
#include "SubSystem/DevPacketSystem/DevPacketSystem.h"
#include "SubSystem/NetworkContext/NetworkContext.h"
#include "SubSystem/NetworkManager/NetworkManager.h"
#include "SubSystem/UiServiceManager/UiServiceManager.h"
#include "UiEvent/AutoGenerated/UiEvent.h"
#include "UiService/Game/UiServiceGame.h"
#include "Util/PacketUtil/PacketUtil.h"
#include "Util/SocketUtil/SocketUtil.h"


/**
 * 로그인 패킷 플로우 생성자
 * 
 * 로그인 시퀀스를 순서대로 등록합니다:
 * - REQ_GLOBAL_NOW           : 서버 시간 동기화
 * - CF_REQ_PACKET_LIST       : 패킷 타입 매핑 정보 요청 (개발용)
 * - CM_REQ_SERVER_LIST       : 서버 목록 조회
 * - CM_REQ_ACCOUNT_USER_LIST : 계정의 유저(캐릭터) 목록 조회
 * - CM_REQ_ACCOUNT_USER_CREATE : 유저(캐릭터) 생성 (없을 경우)
 * - CM_REQ_AUTH_TICKET       : 인증 티켓 발급
 * - CF_REQ_USER_LOGIN        : 유저 로그인
 * - CD_REQ_STATIC_DATA_CHECKSUM : 정적 데이터 체크섬 확인
 * - CD_REQ_STATIC_DATA       : 정적 데이터 다운로드 (필요 시)
 * - CD_REQ_USER_DATA         : 유저 데이터(캐시) 로딩
 */
FClientPacketFlowLogin::FClientPacketFlowLogin()	
{
	RegisterSeq(this, &FClientPacketFlowLogin::REQ_GLOBAL_NOW);
	RegisterSeq(this, &FClientPacketFlowLogin::CF_REQ_PACKET_LIST);
	RegisterSeq(this, &FClientPacketFlowLogin::CM_REQ_SERVER_LIST);
	RegisterSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_LIST);
	RegisterSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE);
	RegisterSeq(this, &FClientPacketFlowLogin::CM_REQ_AUTH_TICKET);
	RegisterSeq(this, &FClientPacketFlowLogin::CF_REQ_USER_LOGIN);
	RegisterSeq(this, &FClientPacketFlowLogin::CD_REQ_STATIC_DATA_CHECKSUM);
	RegisterSeq(this, &FClientPacketFlowLogin::CD_REQ_STATIC_DATA);
	RegisterSeq(this, &FClientPacketFlowLogin::CD_REQ_USER_DATA);
}

/**
 * 패킷 디스패치 핸들러
 * 
 * 수신된 패킷을 적절한 OnPacket() 핸들러로 라우팅합니다.
 * 처리 실패 시 에러 로그를 출력합니다.
 */
void FClientPacketFlowLogin::OnDispatchPacket(NetworkPacket& rp)
{
	const HandleResult handleResult = PacketUtil::DispatchPacket(this, rp);

	if (handleResult != HandleResult::OK)
	{
		_DEBUG_LOG(RED, L"{}[{}]", GetPacketTypeString(rp.GetPacketType()), rp.GetPacketSize());
	}
}

void FClientPacketFlowLogin::OnDispatchUiEvent(UUiEventBase* uiEvent)
{
	DispatchUiEvent(this, uiEvent);
}

/**
 * 서버 연결 완료 콜백
 * 
 * 연결 성공 시 시간 동기화 시도 카운터를 초기화하고
 * 첫 번째 시퀀스(REQ_GLOBAL_NOW)로 점프하여 로그인 플로우를 시작합니다.
 */
void FClientPacketFlowLogin::OnConnected()
{
	// 시간 동기화 시도 카운터 초기화
	mTimeSyncTryCnt = 0;


	const PacketHeader& packetHeader = UNetworkContext::Get(this)->CurrPacketHeader();
	 
	if ((packetHeader.GetAccountId() != INVALID_UUID) &&
		(packetHeader.GetServerId() != INVALID_SERVER_ID) &&
		(packetHeader.GetUserId() != INVALID_UUID))
	{
		// 재연결된 경우이다 
		JumpToSeq(this, &FClientPacketFlowLogin::CF_REQ_USER_LOGIN);
	}
	else
	{
		// 로그인 플로우 시작: 서버 시간 동기화부터
		JumpToSeq(this, &FClientPacketFlowLogin::REQ_GLOBAL_NOW);
	}
}

void FClientPacketFlowLogin::OnFatalError()
{
	Reset();
}

/**
 * 서버 시간 동기화 요청
 * 
 * 클라이언트-서버 간 시간 차이를 측정하고 동기화합니다.
 * - 최대 5회 시도 (MAX_TIME_SYNC_TRY_CNT)
 * - 왕복 시간(RTT)이 600ms 이하여야 성공 (MAX_TIME_SYNC_DELTA)
 * - 실패 시 재시도, 5회 초과 시 연결 종료
 */
void FClientPacketFlowLogin::REQ_GLOBAL_NOW()
{	
	// 최대 시도 횟수 초과 시 연결 종료
	if (MAX_TIME_SYNC_TRY_CNT <= mTimeSyncTryCnt)
	{
		UNetworkManager::Get(this)->Disconnect();
		return;
	}

	++mTimeSyncTryCnt;

	// 현재 클라이언트 시간을 담아 서버에 전송
	SocketUtil::Send<REQ_GLOBAL_NOW::Writer> wp(REQ);
	wp.SetValues(
		false,
		CLOCK_MS_FROM_DR(CLOCK_NOW.time_since_epoch())
	);
}

/**
 * 서버 시간 동기화 응답 처리
 * 
 * 서버로부터 받은 시간 정보를 검증하고 클라이언트 시간을 동기화합니다.
 * - 왕복 시간(RTT) 검증: 600ms 이하여야 성공
 * - 성공 시 다음 시퀀스로 진행
 * - 실패 시 재시도
 */
HandleResult FClientPacketFlowLogin::OnPacket(class ACK_GLOBAL_NOW& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	if (Result::SUCCEEDED != result)
	{
		UNetworkManager::Get(this)->FatalError();
		return HandleResult::OK;;
	}
	
	// 왕복 시간(RTT) 계산
	ClockMs nowMs = CLOCK_MS_FROM_DR(CLOCK_NOW.time_since_epoch());
	ClockMs reqMs = rp.Get_reqMs();
	ClockMs delta = nowMs - reqMs;
	
	// RTT가 너무 크면 재시도 (네트워크 지연이 심함)
	if (MAX_TIME_SYNC_DELTA < delta)
	{		
		_DEBUG_LOG(RED, L"(MAX_TIME_SYNC_DELTA < delta), {}", delta.count());

		RetrySeq();
		return HandleResult::OK;;
	}

	// 서버 시간으로 클라이언트 시간 동기화
	UNetworkManager::Get(this)->SetupGlobalNow(ClockPoint(rp.Get_ackNow()));

	// 다음 시퀀스로 진행
	NextSeq();
	return HandleResult::OK;;
}

/**
 * 패킷 타입 매핑 정보 요청 (개발용)
 * 
 * 클라이언트와 서버의 패킷 타입 ID 매핑 정보를 요청합니다.
 * 개발 중 클라이언트/서버 빌드 버전이 다를 때 패킷 타입 불일치를 해결하기 위한 기능입니다.
 */
void FClientPacketFlowLogin::CF_REQ_PACKET_LIST()
{
	SocketUtil::Send<CF_REQ_PACKET_LIST::Writer> wp(REQ);
}

/**
 * 패킷 타입 매핑 정보 응답 처리
 * 
 * 서버로부터 받은 패킷 타입 매핑 정보를 DevPacketSystem에 저장합니다.
 * 이후 패킷 송수신 시 이 매핑 정보를 사용하여 타입 변환을 수행합니다.
 */
HandleResult FClientPacketFlowLogin::OnPacket(FC_ACK_PACKET_LIST& rp)
{
	// 클라이언트 패킷 타입 -> 서버 패킷 타입 매핑 테이블 구축
	DevPacketTypeMap devPacketTypeMap;
	for (const PACKET_DEV_DATA* packetDevData : rp.Get_packetDevDataList())
	{
		const PacketType clientPacketType = GetPacketTypeEnum(packetDevData->Get_packetName());
		const PacketType serverPacketType = packetDevData->Get_packetType();
		devPacketTypeMap.emplace(clientPacketType, serverPacketType);
	}

	// DevPacketSystem에 매핑 정보 저장
	UDevPacketSystem::Get(this)->SetDevPacketTypeMap(std::move(devPacketTypeMap));

	NextSeq();
	return HandleResult::OK;
}

/**
 * 서버 목록 조회 요청
 * 
 * 접속 가능한 게임 서버 목록을 요청합니다.
 * 유저는 이 목록에서 서버를 선택하여 캐릭터를 생성/로그인합니다.
 */
void FClientPacketFlowLogin::CM_REQ_SERVER_LIST()
{
	SocketUtil::Send<CM_REQ_SERVER_LIST::Writer> wp(REQ);
}

/**
 * 서버 목록 조회 응답 처리
 * 
 * 서버 목록을 UNetworkContext에 저장합니다.
 * - 성공: 다음 시퀀스(계정 유저 목록 조회)로 진행
 * - RETRY_LATER: 재시도
 */
HandleResult FClientPacketFlowLogin::OnPacket(MC_ACK_SERVER_LIST& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		// 서버 목록을 NetworkContext에 저장
		UNetworkContext::Get(this)->ServerList().clear();
		for (const SERVER* server : rp.Get_serverList())
		{
			UNetworkContext::Get(this)->ServerList().emplace_back(*server);
		}

		NextSeq();
		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		RetrySeq();
		break;
	}
	}

	return HandleResult::OK;
}

/**
 * 계정의 유저(캐릭터) 목록 조회 요청
 * 
 * 현재 계정이 소유한 유저(캐릭터) 목록을 조회합니다.
 * Main DB의 t_account_user 테이블에서 조회됩니다.
 */
void FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_LIST()
{
	SocketUtil::Send<CM_REQ_ACCOUNT_USER_LIST::Writer> wp(REQ);
	wp.SetValues(
		**UNetworkContext::Get(this)->Account()
	);
}

/**
 * 계정의 유저(캐릭터) 목록 조회 응답 처리
 * 
 * 유저 목록을 UNetworkContext에 저장합니다.
 * - 성공 + 유저 존재: 인증 티켓 요청으로 점프 (캐릭터 생성 스킵)
 * - 성공 + 유저 없음: 다음 시퀀스(캐릭터 생성)로 진행
 * - RETRY_LATER: 재시도
 */
HandleResult FClientPacketFlowLogin::OnPacket(MC_ACK_ACCOUNT_USER_LIST& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		// 유저(캐릭터) 목록을 NetworkContext에 저장
		UNetworkContext::Get(this)->AccountUserList().clear();
		for (const ACCOUNT_USER* accountUser : rp.Get_accountUserList())
		{
			UNetworkContext::Get(this)->AccountUserList().emplace_back(*accountUser);
		}
		
		if (UNetworkContext::Get(this)->ServerList().empty())
		{
			// 서버 목록이 없으면 서버 목록 조회로 돌아감
			RetryJumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_SERVER_LIST);
		}		
		else if (UNetworkContext::Get(this)->AccountUserList().empty())
		{
			// 유저(캐릭터)가 없으면 서버 선택 및 캐릭터 생성
			JumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE);
		}		
		else
		{
			// 유저(캐릭터)가 이미 존재하면 최근 서버 선택해주고 확인 또는 서버 다시 선택하도록 유도
			JumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_AUTH_TICKET);
		}
		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		_DEBUG_RED;

		RetrySeq();
		break;
	}
	}

	return HandleResult::OK;
}

/**
 * 유저(캐릭터) 생성 요청
 * 
 * 계정에 유저(캐릭터)가 없을 때 자동으로 생성합니다.
 * - 서버 목록이 없으면 서버 목록 조회로 돌아감
 * - 첫 번째 서버에 랜덤 이름으로 캐릭터 생성
 */
void FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE()
{
	const bool userCreateMode = true;
	UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_POPUP_SERVER_LIST_OPEN>(userCreateMode);
}

void FClientPacketFlowLogin::OnUiEvent(UUiEvent_POPUP_SERVER_LIST_OK_CLICKED& uiEvent)
{
	const PacketHeader& packetHeader = UNetworkContext::Get(this)->CurrPacketHeader();
	const ServerId serverId = packetHeader.GetServerId();

	if (serverId == INVALID_SERVER_ID)
	{
		RetryJumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE);
		return;
	}

	// 선택된 서버가 ServerList에 있는지 확인
	const ServerList& serverList = UNetworkContext::Get(this)->ServerList();
	auto serverIt = std::find_if(serverList.begin(), serverList.end(),
		[serverId](const PacketKeep<SERVER>& server)
		{
			return server->Get_c_server_id() == serverId;
		}
	);

	if (serverIt == serverList.end())
	{
		// 서버가 목록에 없으면 처음부터 다시
		RetryJumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE);
		return;
	}

	// 선택된 서버에 이미 유저(캐릭터)가 있는지 확인
	const AccountUserList& accountUserList = UNetworkContext::Get(this)->AccountUserList();
	auto userIt = std::find_if(accountUserList.begin(), accountUserList.end(),
		[serverId](const PacketKeep<ACCOUNT_USER>& accountUser)
		{
			return accountUser->Get_c_server_id() == serverId;
		}
	);

	if (userIt == accountUserList.end())
	{
		// 유저가 없으면 이름 입력 팝업 표시
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_POPUP_USER_NAME_OPEN>();
	}
	else
	{
		// 유저가 이미 있으면 인증 티켓 발급으로 진행
		JumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_AUTH_TICKET);
	}
}

void FClientPacketFlowLogin::OnUiEvent(UUiEvent_POPUP_USER_NAME_OK_CLICKED_FINAL& uiEvent)
{
	const PacketHeader& packetHeader = UNetworkContext::Get(this)->CurrPacketHeader();
	const ServerId serverId = packetHeader.GetServerId();

	// 선택된 서버가 ServerList에 있는지 확인
	const ServerList& serverList = UNetworkContext::Get(this)->ServerList();
	auto serverIt = std::find_if(serverList.begin(), serverList.end(),
		[serverId](const PacketKeep<SERVER>& server)
		{
			return server->Get_c_server_id() == serverId;
		}
	);

	if (serverIt == serverList.end())
	{
		// 서버가 목록에 없으면 처음부터 다시
		RetryJumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE);
		return;
	}

	// 선택된 서버에 이미 유저(캐릭터)가 있는지 확인
	const AccountUserList& accountUserList = UNetworkContext::Get(this)->AccountUserList();
	auto userIt = std::find_if(accountUserList.begin(), accountUserList.end(),
		[serverId](const PacketKeep<ACCOUNT_USER>& accountUser)
		{
			return accountUser->Get_c_server_id() == serverId;
		}
	);

	if (userIt != accountUserList.end())
	{
		// 유저가 이미 있으면 인증 티켓 발급으로 진행
		JumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_AUTH_TICKET);
		return;
	}

	// 유저 이름 가져오기
	const std::wstring& userName = UNetworkContext::Get(this)->GetNewUserName();
	if (userName.empty())
	{
		// 이름이 없으면 다시 입력 요청
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_POPUP_USER_NAME_OPEN>();
		return;
	}

	// 캐릭터 생성 요청
	const ACCOUNT& account = **UNetworkContext::Get(this)->Account();

	SocketUtil::Send<CM_REQ_ACCOUNT_USER_CREATE::Writer> wp(REQ);
	wp.SetHeader(packetHeader);
	wp.SetValues(
		account,
		userName.data()
	);
}

/**
 * 유저(캐릭터) 생성 응답 처리
 * 
 * 생성된 유저 목록을 UNetworkContext에 저장합니다.
 * - 성공: 다음 시퀀스(인증 티켓 요청)로 진행
 * - RETRY_LATER: 재시도
 */
HandleResult FClientPacketFlowLogin::OnPacket(MC_ACK_ACCOUNT_USER_CREATE& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();

	switch (result)
	{
	case Result::SUCCEEDED:
	{
		// 생성된 유저(캐릭터) 목록을 NetworkContext에 저장
		UNetworkContext::Get(this)->AccountUserList().clear();
		for (const ACCOUNT_USER* accountUser : rp.Get_accountUserList())
		{
			UNetworkContext::Get(this)->AccountUserList().emplace_back(*accountUser);
		}

		NextSeq();
		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		_DEBUG_RED;

		RetrySeq();
		break;
	}
	}

	return HandleResult::OK;
}

// 인증 요청
void FClientPacketFlowLogin::CM_REQ_AUTH_TICKET()
{
	if (UNetworkContext::Get(this)->AccountUserList().empty())
	{
		RetryJumpToSeq(this, &FClientPacketFlowLogin::CM_REQ_ACCOUNT_USER_CREATE);
		return;
	}

	const ACCOUNT& account = **UNetworkContext::Get(this)->Account();
	if ((0 == ClientStringUtil::w_to_s(account.Get_c_device_token()).Len()) &&
		(0 == ClientStringUtil::w_to_s(account.Get_c_google_token()).Len()) &&
		(0 == ClientStringUtil::w_to_s(account.Get_c_apple_token()).Len()))
	{
		UNetworkManager::Get(this)->FatalError();
		return;
	}

	const PacketKeep<ACCOUNT_USER>& accountUser = UNetworkContext::Get(this)->AccountUserList().front();

	// 인증 찾기 진행
	SocketUtil::Send<CM_REQ_AUTH_TICKET::Writer> wp(REQ);
	wp.SetValues(
		account,
		accountUser->Get_c_user_id()
	);
}

// 인증 응답 받음
HandleResult FClientPacketFlowLogin::OnPacket(MC_ACK_AUTH_TICKET& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		UNetworkContext::Get(this)->AuthTicket() = rp.Get_authTicket();
		UNetworkContext::Get(this)->AccountUser() = rp.Get_accountUser();

		NextSeq();
		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		UNetworkManager::Get(this)->FatalError();
		break;
	}
	}

	return HandleResult::OK;;
}

// 로그인 요청
void FClientPacketFlowLogin::CF_REQ_USER_LOGIN()
{
	// 로그인
	SocketUtil::Send<CF_REQ_USER_LOGIN::Writer> wp(REQ);
	wp.SetValues(
		UNetworkContext::Get(this)->AuthTicket()
	);
}

// 로그인 응답 받음
HandleResult FClientPacketFlowLogin::OnPacket(FC_ACK_USER_LOGIN& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		UNetworkContext::Get(this)->StaticDataChecksum() = rp.Get_staticDataChecksum();

		// 데이터 받기 시작.
		JumpToSeq(this, &FClientPacketFlowLogin::CD_REQ_STATIC_DATA_CHECKSUM);

		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		UNetworkManager::Get(this)->FatalError();
		break;
	}
	}

	return HandleResult::OK;;
}

// 정적데이터 체크섬 요청
void FClientPacketFlowLogin::CD_REQ_STATIC_DATA_CHECKSUM()
{
	gStaticDataCatalog->ResetSync();
	gStaticDataCatalog->SetSyncing();

	SocketUtil::Send<CD_REQ_STATIC_DATA_CHECKSUM::Writer> wp(REQ);
}

// 정적데이터 체크섬 응답 받음
HandleResult FClientPacketFlowLogin::OnPacket(DC_ACK_STATIC_DATA_CHECKSUM& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		const size_t listSize0 = rp.Get_checksumList_size();
		//const size_t listSize1 = rp.Get_staticDataSizeList_size();
		const StaticDataSize* srcSizeList = rp.Get_staticDataSizeList();
		const Checksum* srcChecksumList = rp.Get_checksumList();

		gStaticDataCatalog->ExpectedChecksumForClient() = rp.Get_staticDataChecksum();
		gStaticDataCatalog->ExpectedSizeList().resize(listSize0, 0);
		gStaticDataCatalog->ExpectedChecksumList().resize(listSize0, {});
		gStaticDataCatalog->BinaryList().resize(listSize0, nullptr);

		for (size_t i = 0; i < listSize0; ++i)
		{
			if ((gStaticDataCatalog->ExpectedSizeList().at(i) == srcSizeList[i]) &&
				(gStaticDataCatalog->ExpectedChecksumList().at(i) == srcChecksumList[i]))
			{
				continue;
			}

			gStaticDataCatalog->ExpectedSizeList().at(i) = srcSizeList[i];
			gStaticDataCatalog->ExpectedChecksumList().at(i) = srcChecksumList[i];

			if (gStaticDataCatalog->BinaryList().at(i))
			{
				_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
				gStaticDataCatalog->BinaryList().at(i) = nullptr;
			}
		}

		JumpToSeq(this, &FClientPacketFlowLogin::CD_REQ_STATIC_DATA);
		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		UNetworkManager::Get(this)->FatalError();
		break;
	}
	}

	return HandleResult::OK;;
}

// 정적데이터 요청
void FClientPacketFlowLogin::CD_REQ_STATIC_DATA()
{
	auto [succeeded, index] = gStaticDataCatalog->BuildDataForClient();

	// 데이터가 일치하지 않으면 데이터 요청
	if (false == succeeded)
	{
		_ASSERT_CRASH(INVALID_STATIC_DATA_INDEX != index);
		SocketUtil::Send<CD_REQ_STATIC_DATA::Writer> wp(REQ);	
		wp.SetValues(
			index
		);
	}
	// 성공이면, 유저 데이터 요청
	else
	{
		if (Engine::GetDebugStepCount() != -1)
		{
			// 디버그 중이라면, 게임 WorldData를 재구성하게 한다
			TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
			if (!gameService)
				return;

			FGameCorePauseGuard gameCorePauseGuard(gameService);
			TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
			if (!gameCore)
				return;

			TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
			if (!gameInstance)
				return;

			UNetworkContext::Get(this)->SaveStaticData();

			gStaticDataAccessor = MakeShared<StaticDataAccessor>();
			gStaticDataAccessor->BuildView();
			gStaticDataCatalog->SetSynced();

			// 월드데이터를 다시 구축
			Serializer serializer;
			gameInstance->SaveWorldDataForNewUser(serializer);
			Deserializer deserializer(serializer.GetBufPtr(), serializer.GetDataSize());
			gameInstance->LoadWorldData(deserializer);
		}
		else
		{
			UNetworkContext::Get(this)->SaveStaticData();

			gStaticDataAccessor = MakeShared<StaticDataAccessor>();
			gStaticDataAccessor->BuildView();
			gStaticDataCatalog->SetSynced();

			// 테스트 모드라면, 
			if (UUiServiceManager::Get(this)->GetClientMode() == ClientMode::TEST)
			{
				UNetworkManager::Get(this)->Disconnect();
				UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_TEST_GAME_STATIC_DATA_COMPLETED>();
			}
			// 디버그 중이 아니고, 처음 받아온 것이라면, 유저 데이터를 요청하게 된다
			else
			{				
				JumpToSeq(this, &FClientPacketFlowLogin::CD_REQ_USER_DATA);
			}
		}		
	}
}

// 정적데이터 응답 받음
HandleResult FClientPacketFlowLogin::OnPacket(DC_ACK_STATIC_DATA& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		const StaticDataIndex i = rp.Get_index();
		const uint8_t* srcBin = rp.Get_staticDataBin();
		const StaticDataSize srcOffset = rp.Get_offset();
		const PacketSize srcSize = rp.Get_staticDataBin_size();

		_ASSERT_CRASH(gStaticDataCatalog->BinaryList().size() > static_cast<size_t>(i));

		gStaticDataCatalog->ExpectedSizeList().at(i) = srcSize;

		if (gStaticDataCatalog->BinaryList().at(i))
		{
			_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
			gStaticDataCatalog->BinaryList().at(i) = nullptr;
		}

		if (srcSize > 0)
		{
			gStaticDataCatalog->BinaryList().at(i) = _MALLOC<uint8_t>(srcSize);
			std::copy_n(srcBin, srcSize, gStaticDataCatalog->BinaryList().at(i) + srcOffset);
		}

		// 완료되었으면, 다음 StaticData 요청.
		if (1 == rp.Get_isCompleted())
			JumpToSeq(this, &FClientPacketFlowLogin::CD_REQ_STATIC_DATA);

		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		UNetworkManager::Get(this)->FatalError();
		break;
	}
	}

	return HandleResult::OK;;
}

/**
 * 유저 데이터 요청
 * 
 * 로그인한 유저의 런타임 데이터를 요청합니다.
 * User DB에서 다음 데이터를 로딩합니다:
 * - t_user: 유저 기본 정보
 * - t_item: 아이템 목록 (캐릭터, 장비, 소모품 등 모두 포함)
 * - t_item_stat: 아이템별 스탯 정보
 * - t_achievement, t_mission, t_quest 등
 */
void FClientPacketFlowLogin::CD_REQ_USER_DATA()
{
	SocketUtil::Send<CD_REQ_USER_DATA::Writer> wp(REQ);
}

/**
 * 유저 데이터 응답 처리
 * 
 * 서버로부터 받은 유저 데이터를 UNetworkContext의 UserCacheAccessor에 캐싱합니다.
 * - UserItemTable: 아이템 목록 (t_item)
 * - UserItemStatTable: 아이템 스탯 (t_item_stat)
 * - UserAchievementTable, UserMissionTable, UserQuestTable 등
 * 
 * 이후 게임 로직에서는 UNetworkContext::Get()->GetUserCacheAccessor()를 통해 접근합니다.
 * 
 * 성공 시 로그인 플로우 완료.
 */
HandleResult FClientPacketFlowLogin::OnPacket(DC_ACK_USER_DATA& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		// 유저 데이터를 UserCacheAccessor에 캐싱
		// PacketUtil::CacheUserData()에서 다음 작업 수행:
		// - UserItemTable에 아이템 저장
		// - UserItemStatTable에 스탯 저장
		// - 기타 유저 데이터 테이블 저장
		PacketUtil::CacheUserData(rp.Get_userData());
		break;
	}
	case Result::RETRY_LATER:
	{
		RetrySeq();
		break;
	}
	default:
	{
		UNetworkManager::Get(this)->FatalError();
		break;
	}
	}

	return HandleResult::OK;;
}
//
//HandleResult FClientPacketFlowLogin::OnPacket(DC_ACK_CHEAT& rp)
//{
//	const Result result = rp.GetHeader().GetPacketResult();
//	switch (result)
//	{
//	case Result::SUCCEEDED:
//	{
//		PacketUtil::CacheUserData(rp.GetUserData());
//		break;
//	}
//	case Result::RETRY_LATER:
//	{
//		// '잠시 후 재시도 하세요' 안내 팝업.
//		break;
//	}
//	default:
//	{
//		UNetworkManager::Get(this)->FatalError();
//		break;
//	}
//	}
//
//	return HandleResult::OK;;
//}
