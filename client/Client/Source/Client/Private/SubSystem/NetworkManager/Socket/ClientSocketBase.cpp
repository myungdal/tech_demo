// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "ClientSocketBase.h"

#include "Networking.h"

#include "Common/Random/Mt19937Random/Mt19937Random32.h"

#include "Packet/BasePacketAutoGenerated/PACKET_TYPE.h"
#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/PacketFuncs/PacketLogger.h"

#include "SubSystem/DevPacketSystem/DevPacketSystem.h"
#include "SubSystem/NetworkManager/SendBuffer/SendBuffer.h"
#include "Util/SocketUtil/SocketUtil.h"


bool FClientSocketBase::CanChangeSocketState(SocketState socketState)
{
	static constexpr size_t expectedArray[_IDX(SocketState::MAX)] = {
		(1 << _IDX(SocketState::DISCONNECTED)) | (1 << _IDX(SocketState::CONNECTING)),										// CLOSED
		(1 << _IDX(SocketState::CLOSED)),																					// OPENED
		(1 << _IDX(SocketState::OPENED)),																					// CONNECTING
		(1 << _IDX(SocketState::CONNECTING)),																				// CONNECTED
		(1 << _IDX(SocketState::CONNECTED)),																				// HANDSHAKED
		(1 << _IDX(SocketState::CONNECTING)) | (1 << _IDX(SocketState::CONNECTED)) | (1 << _IDX(SocketState::HANDSHAKED))	// DISCONNECTED
	};

	size_t expected = expectedArray[_IDX(socketState)];
	if ((0 == ((size_t(1) << _IDX(mSocketState)) & expected)))
	{
		_DEBUG_LOG(WHITE, L"SetSocketState: {}, mSocketState: {}", static_cast<int>(socketState), static_cast<int>(mSocketState));
		return false;
	}

	return true;
}

void FClientSocketBase::ChangeSocketState(SocketState socketState)
{
	mSocketState = socketState;
}

bool FClientSocketBase::Open()
{
	if (false == CanChangeSocketState(SocketState::OPENED))
		return false;

	mSocketSubsystem = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM);
	if (!mSocketSubsystem)
		return false;

	mSocket = mSocketSubsystem->CreateSocket(NAME_Stream, TEXT("FClientSocket"), FNetworkProtocolTypes::IPv4);

	int recvBufferSize = 0;
	int sendBufferSize = 0;
	if((false == mSocket->SetNonBlocking(true)) ||
		(false == mSocket->SetReuseAddr(true)) ||
		(false == mSocket->SetLinger(0)) ||	
		(false == mSocket->SetReceiveBufferSize(0, recvBufferSize)) ||
		(false == mSocket->SetSendBufferSize(0, sendBufferSize)))
	{
		return false;
	}

	ChangeSocketState(SocketState::OPENED);

	return true;
}

bool FClientSocketBase::Close()
{
	if (false == CanChangeSocketState(SocketState::CLOSED))
		return false;

	if (false == mSocket->Close())
	{
		ESocketErrors errorCode = mSocketSubsystem->GetLastErrorCode();
		_DEBUG_LOG(RED, L"errorCode: {}", (int)errorCode);
		return false;
	}
	
	mSocketSubsystem->DestroySocket(mSocket);
	mSocket = nullptr;

	mRecvBufHead = 0;
	mRecvBufTail = 0;

	ChangeSocketState(SocketState::CLOSED);
	
	return true;
}

bool FClientSocketBase::HasEncryptionKey() const
{
	return (0 == mHostEncryptionKey) ? false : true;
}

void FClientSocketBase::Encrypt(uint8_t* buf, int32_t len, EncryptionKey encryptionKey) const
{
	uint8_t* key = reinterpret_cast<uint8_t*>(&encryptionKey);

	for (int32_t i = 0; i < len; ++i)
	{
		buf[i] ^= ++key[i & 0b00000011];
	}
}

void FClientSocketBase::ConnectSocket(const wchar_t* ip, uint16_t port)
{	
	if (false == Open())
	{
		_DEBUG_LOG(RED, L"(false == Open())");
		OnDisconnected();
		return;
	}

	mAddr = mSocketSubsystem->CreateInternetAddr();
	bool isValid = false;
	// 안드로이드 IOS 컴파일 문제
	mAddr->SetIp(reinterpret_cast<const TCHAR*>(ip), isValid);
	if (false == isValid)
	{
		_DEBUG_LOG(RED, L"(false == isValid)");
		OnDisconnected();
		return;
	}
	mAddr->SetPort(port);

	if (false == mSocket->Connect(*mAddr))
	{
		ESocketErrors errorCode = mSocketSubsystem->GetLastErrorCode();
		_DEBUG_LOG(RED, L"errorCode: {}", (int)errorCode);
		OnDisconnected();
		return;
	}

	ChangeSocketState(SocketState::CONNECTING);
}

bool FClientSocketBase::SendNetworkPacket(NetworkPacketWriter& wp, EncryptionOption encryptionOption)
{
#if _PACKET_SEND_LOG
	_DEBUG_LOG(WHITE, L"{}", PacketLogger::GetLogPacketString(*wp.GetNetworkPacketPtr()));
#endif

	if (false == IsConnectedSocket())
	{
		_DEBUG_LOG(RED, L"(false == IsConnected())");
		FSendBuffer::Push(wp.GetPacketBufPtr());
		return false;
	}

	uint8_t* bufPtr = wp.GetPacketBufPtr();
	PacketSize packetSize = wp.GetPacketSize();

	if (MAX_PACKET_BUFFER_SIZE < packetSize)
	{
		_DEBUG_LOG(RED, L"(MAX_PACKET_SIZE < packetSize)");
		FSendBuffer::Push(wp.GetPacketBufPtr());
		DisconnectSocket();
		return false;
	}

	if (EncryptionOption::ENCRYPTION == encryptionOption)
	{
		if (false == HasEncryptionKey())
		{
			_DEBUG_LOG(RED, L"(false == HasEncryptionKey())");
			FSendBuffer::Push(wp.GetPacketBufPtr());
			DisconnectSocket();
			return false;
		}
		
		Encrypt(bufPtr, packetSize, mHostEncryptionKey);
	}

	if (true == mSendBufferQueue.empty())
	{
		mSendBufferQueue.emplace(bufPtr, packetSize);
	}
	else
	{
		//auto& [backBufPtr, backBufSize] = mSendBufferQueue.back();
		SendBufferInfo& sendBuffer = mSendBufferQueue.back();
		uint8_t* backBufPtr = sendBuffer.first;
		PacketSize& backBufSize = sendBuffer.second;
		if (MAX_PACKET_BUFFER_SIZE > (backBufSize + packetSize))
		{
			std::copy_n(bufPtr, packetSize, backBufPtr + backBufSize);
			backBufSize += packetSize;
			FSendBuffer::Push(bufPtr);
		}
		else
		{
			mSendBufferQueue.emplace(bufPtr, packetSize);
		}
	}

	return true;
}

void FClientSocketBase::DisconnectSocket()
{
	if (false == CanChangeSocketState(SocketState::DISCONNECTED))
		return;

	ChangeSocketState(SocketState::DISCONNECTED);
	OnDisconnected();

	Close();
}

bool FClientSocketBase::IsConnectedSocket() const
{
	return ((SocketState::CONNECTED == mSocketState) || (SocketState::HANDSHAKED == mSocketState)) ? true : false;
}

bool FClientSocketBase::IsHandshaked() const
{
	return (SocketState::HANDSHAKED == mSocketState) ? true : false;
}

bool FClientSocketBase::TryRecv()
{
	//uint32_t pendingSize = 0;
	//if ((false == mSocket->HasPendingData(pendingSize)) || (0 == pendingSize))
	//	return true;

	int32 recvSize = 0;
	if (false == mSocket->Recv(mRecvBuf + mRecvBufTail, MAX_RECV_BUF_SIZE - mRecvBufTail, recvSize))
	{
		ESocketErrors errorCode = mSocketSubsystem->GetLastErrorCode();

		if ((SE_EWOULDBLOCK == errorCode) || (SE_EINPROGRESS == errorCode))
			return true;

		return false;
	}

	if (0 == recvSize)
		return true;

	mRecvBufTail += static_cast<size_t>(recvSize);
	size_t len = (mRecvBufTail - mRecvBufHead);
	size_t remain = len;
	uint8_t* buf = mRecvBuf + mRecvBufHead;

	while (sizeof(NetworkPacket) <= remain)
	{
		NetworkPacket* ptr;

		if (false == IsHandshaked())
		{
			if (false == CanChangeSocketState(SocketState::HANDSHAKED))
				return false;

			ptr = reinterpret_cast<NetworkPacket*>(buf);

			const PacketSize packetSize = ptr->GetPacketSize();

			if (packetSize > remain)
				break;

			if (MAX_PACKET_BUFFER_SIZE < packetSize)
				return false;

			const PacketType packetType = ptr->GetPacketType();
			if (PacketTypes::HANDSHAKE_TO_PEER != packetType)
				return false;

			HANDSHAKE_TO_PEER* rp = reinterpret_cast<HANDSHAKE_TO_PEER*>(buf);

			{
				Mt19937Random32 randomEngine32;

				mMyEncryptionKey = randomEngine32();
				if (0 == mMyEncryptionKey)
					mMyEncryptionKey = 1;


				HANDSHAKE_TO_HOST::Writer wp(NOTIFY, FSendBuffer::Pop());
				wp.SetValues(
					mMyEncryptionKey, 
					INVALID_APP_ID,
					AppType::MAX
				);
				SendNetworkPacket(wp, EncryptionOption::NO_ENCRYPTION);
			}

			mHostEncryptionKey = rp->Get_hostEncryptionKey();

			ChangeSocketState(SocketState::HANDSHAKED);

			OnConnected();
		}
		else
		{
			Encrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);

			ptr = reinterpret_cast<NetworkPacket*>(buf);

			const PacketSize packetSize = ptr->GetPacketSize();

			if (packetSize > remain)
			{
				Encrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);
				break;
			}

			if (MAX_PACKET_BUFFER_SIZE < packetSize)
				return false;

			Encrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);
			Encrypt(buf, packetSize, mMyEncryptionKey);

			UDevPacketSystem::Get(this)->OnApplyDevPacketType(IN OUT (*ptr));

#if _PACKET_RECV_LOG
			std::wstring log = PacketLogger::GetLogPacketString(*ptr);
			if (log.size() > 0)
				_DEBUG_LOG(WHITE, L"{}", log);
#endif

			if (false == OnDispatchPacket(*ptr))
				return false;
		}

		buf += ptr->GetPacketSize();
		remain -= ptr->GetPacketSize();
	}

	mRecvBufHead += (len - remain);

	if (mRecvBufHead == mRecvBufTail)
		mRecvBufHead = mRecvBufTail = 0;

	return true;
}

bool FClientSocketBase::FlushSend()
{
	if (false == IsConnectedSocket())
		return false;

	if (true == mSendBufferQueue.empty())
		return true;

	//auto& [frontBufPtr, frontBufSize] = mSendBufferQueue.front();
	SendBufferInfo& sendBuffer = mSendBufferQueue.back();
	uint8_t* frontBufPtr = sendBuffer.first;
	PacketSize& frontBufSize = sendBuffer.second;

	int sent = 0;
	if (false == mSocket->Send(frontBufPtr, frontBufSize, sent))
	{
		_DEBUG_LOG(RED, L"(false == Send)");
		return false;
	}

	if (-1 == sent)
	{
		_DEBUG_LOG(RED, L"(-1 == sent)");
		return false;
	}

	if (sent > static_cast<int>(frontBufSize))
	{
		_DEBUG_LOG(RED, L"(sent > frontBufSize)");
		return false;
	}

	frontBufSize -= sent;

	if (0 == frontBufSize)
	{
		mSendBufferQueue.pop();
		FSendBuffer::Push(frontBufPtr);
	}

	return true;
}

void FClientSocketBase::Update()
{
	if (nullptr == mSocket)
		return;

	ESocketConnectionState connectionState = mSocket->GetConnectionState();
	ESocketErrors errorCode = 
		(SCS_ConnectionError == connectionState) ? mSocketSubsystem->GetLastErrorCode() : SE_NO_ERROR;

	switch (mSocketState)
	{
	case SocketState::CONNECTING:
	{
		switch (connectionState)
		{
		case SCS_Connected:
		{
			if (true == CanChangeSocketState(SocketState::CONNECTED))
				ChangeSocketState(SocketState::CONNECTED);

			break;
		}
		case SCS_ConnectionError:
		{
			if (SE_EBADF != errorCode)
			{
				_DEBUG_LOG(RED, L"errorCode: {}", (int)errorCode);
				OnDisconnected();

				Close();
			}
			break;
		}
		default:
			break;
		}
		break;
	}
	case SocketState::CONNECTED:
	case SocketState::HANDSHAKED:
	{
		switch (connectionState)
		{
		case SCS_Connected:
		{
			if ((false == TryRecv()) || (false == FlushSend()))
				DisconnectSocket();
			break;
		}
		case SCS_NotConnected:
		case SCS_ConnectionError:
		{
			_DEBUG_LOG(RED, L"errorCode: {}", (int)errorCode);
			DisconnectSocket();
			break;
		}
		default:
			break;
		}
		break;
	}
	case SocketState::CLOSED:
	case SocketState::OPENED:
	case SocketState::DISCONNECTED:
	{
		switch (connectionState)
		{
		case SCS_Connected:
		{
			_DEBUG_LOG(RED, L"SCS_Connected");
			break;
		}
		case SCS_ConnectionError:
		{
			_DEBUG_LOG(RED, L"errorCode: {}", (int)errorCode);
			break;
		}
		default:
			break;
		}
		break;
	}
	default:
		break;
	}
}
