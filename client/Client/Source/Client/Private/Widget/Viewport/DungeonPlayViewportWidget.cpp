// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================


#include "DungeonPlayViewportWidget.h"

#include "Framework/Application/SlateApplication.h"
#include "GameFramework/PlayerController.h"

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/PacketCapsule/PacketTemp/PacketTemp.h"

#include "MmoSync/Component/CharacterComponent.h"
#include "MmoSync/Component/PcComponent.h"
#include "MmoSync/Component/LeaderComponent.h"
#include "MmoSync/Component/FollowerComponent.h"
#include "MmoSync/Component/MotionComponent.h"
#include "MmoSync/DebugControlTool/DebugInfo.h"
#include "MmoSync/Engine/Engine.h"
#include "MmoSync/GameInstance/GameInstance.h"
#include "MmoSync/Grid/MultiGrid.h"
#include "MmoSync/Grid/MultiGridDef.h"
#include "MmoSync/WorldManager/WorldManager.h"
#include "MmoSync/WorldManager/WorldUserRegistry/WorldUser.h"

#include "Packet/StaticData/Character/CharacterDoc.h"
#include "Common/Stat/StatContainer/StatContainer.h"

#include "GameRenderer/Character/RenderSystemCharacter.h"

#include "GameCore/GameCore.h"
#include "GameCore/GameCorePauseGuard.h"
#include "GameRenderer/Map/MapRenderer.h"
#include "SubSystem/NetworkManager/SendBuffer/TempBuffer.h"
#include "SubSystem/UiServiceManager/UiServiceManager.h"
#include "UiService/Debug/UiServiceDebug.h"
#include "UiService/Game/UiServiceGame.h"


FReply UDungeonPlayViewportWidget::NativeOnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
#if defined(UE_EDITOR) || defined(_DEBUG)
	// Alt 키가 눌려있을 때 NativeOnKeyDownWithAlt 에서 처리
	if (InKeyEvent.IsShiftDown())
		return NativeOnKeyDownWithAlt(InGeometry, InKeyEvent);
#endif

	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return FReply::Unhandled();

	TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
	if (!gameInstance)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	FVector2D cursorPos0 = FSlateApplication::Get().GetCursorPos();
	FVector2D cursorPos1 = GetTickSpaceGeometry().AbsoluteToLocal(cursorPos0);
	FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPos1);
	const Scalar x = gridCursorPos.X * CELL_SIZE;
	const Scalar y = gridCursorPos.Y * CELL_SIZE;

	MultiGrid& grid = gameInstance->RefMultiGrid();
	const ColRowPair cell = grid.GetCell(gridCursorPos.X, gridCursorPos.Y);

	const WorldUserId worldUserId = GetMyWorldUserId();

	if (InKeyEvent.IsRepeat())
		return FReply::Unhandled();

	uint8_t command = static_cast<uint8>(InKeyEvent.GetCharacter());
	switch (command)
	{
	case 'Q':
		
		break;
	case 'E':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_CHARGE_E>(worldUserId);
		break;
	case 'R':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_RADAR_R>(worldUserId);
		break;
	case 'T':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_INVENTORY_T>(worldUserId);
		break;
	case '1':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_1>(worldUserId);
		break;
	case '2':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_2>(worldUserId);
		break;
	case '3':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_3>(worldUserId);
		break;
	case '4':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_4>(worldUserId);
		break;
	case '5':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_5>(worldUserId);
		break;
	case 'Z':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_Z>(worldUserId);
		break;
	case 'X':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_X>(worldUserId);
		break;
	case 'C':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_C>(worldUserId);
		break;
	case 'V':
		mCameraAutoCenter.EnableAutoMode();  // 명령 입력 시 자동 카메라 모드 복귀
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_V>(worldUserId);
		break;
	case 'W':
	case 'A':
	case 'S':
	case 'D':
	{
		// WASD 이동 시 자동 카메라 모드 복귀
		mCameraAutoCenter.EnableAutoMode();
		// 현재 WASD 키 눌림 상태를 직접 조회
		uint8_t keyState = 0;
		if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
		{
			if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
			if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
			if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
			if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
		}

		// KEY_DOWN 이벤트 시점에 IsInputKeyDown()이 아직 업데이트 안됐을 수 있으므로
		// 현재 누르는 키는 상태에 추가
		uint8_t keyBit = 0;
		switch (command)
		{
		case 'W': keyBit = (1 << 0); break;
		case 'A': keyBit = (1 << 1); break;
		case 'S': keyBit = (1 << 2); break;
		case 'D': keyBit = (1 << 3); break;
		}
		keyState |= keyBit;

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::KEY_DOWN,
			command,
			keyState,
			x,
			y,
			INVALID_ENTITY_IDP
		);
		PacketTemp tp(wp.GetPacketBufPtr());
		SendCommand(tp);
		break;
	}
	default:
	{
		// (GetCharacter()로 잡히지 않으므로 GetKey()로 확인)
		if (InKeyEvent.GetKey() == EKeys::Tab)
		{
			UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_MINIMAP_TAB>(worldUserId);
		}
		else if (InKeyEvent.GetKey() == EKeys::SpaceBar)
		{
			mCameraAutoCenter.EnableAutoMode();  // 구르기 시 자동 카메라 모드 복귀
			UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ROLL_SPACEBAR>(worldUserId);
		}
		break;
	}
	}

	return FReply::Unhandled();
}

FReply UDungeonPlayViewportWidget::NativeOnKeyDownWithAlt(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return FReply::Unhandled();

	TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
	if (!gameInstance)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	FVector2D cursorPos0 = FSlateApplication::Get().GetCursorPos();
	FVector2D cursorPos1 = GetTickSpaceGeometry().AbsoluteToLocal(cursorPos0);
	FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPos1);
	const Scalar x = gridCursorPos.X * CELL_SIZE;
	const Scalar y = gridCursorPos.Y * CELL_SIZE;

	MultiGrid& grid = gameInstance->RefMultiGrid();
	const ColRowPair cell = grid.GetCell(gridCursorPos.X, gridCursorPos.Y);

	const WorldUserId worldUserId = GetMyWorldUserId();

	uint8_t command = static_cast<uint8>(InKeyEvent.GetCharacter());
	switch (command)
	{
	case 'Z':
	case 'X':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '0':
	case 'C': // npc castle
	case 'V': // pc castle
	case 'N': // nest
	case 'R': // reset
	{
		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::TEST,
			command,
			0,  // TEST 커맨드에서는 키 상태가 필요 없음
			x,
			y,
			INVALID_ENTITY_IDP
		);
		PacketTemp tp(wp.GetPacketBufPtr());
		SendCommand(tp);
		break;
	}
	case 'E': // destroy target
	{
		EntityIdp targetIdp = INVALID_ENTITY_IDP;
		if (TSharedPtr<FUiServiceDebug> debugService = UUiServiceManager::Get(this)->GetService<FUiServiceDebug>())
		{
			targetIdp = debugService->GetSelectedEntityIdp();
		}

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::TEST,
			command,
			0,  // TEST 커맨드에서는 키 상태가 필요 없음
			x,
			y,
			targetIdp
		);
		PacketTemp tp(wp.GetPacketBufPtr());
		SendCommand(tp);
		break;
	}
	case 'B': // block
		grid.SetBlocked(cell.first, cell.second, GridCellBlockType::HILL);
		break;
	case 'U': // unblock
		grid.SetUnblocked(cell.first, cell.second, GridCellBlockType::HILL);
		break;
	case 'T':
	{
		TSharedPtr<FUiServiceDebug> debugService = UUiServiceManager::Get(this)->GetService<FUiServiceDebug>();
		if (debugService)
			debugService->SelectEntity(x, y);

		break;
	}
	case 'Q': // 10% damage (Shift+Q)
	{
		EntityIdp targetIdp = INVALID_ENTITY_IDP;
		if (TSharedPtr<FUiServiceDebug> debugService = UUiServiceManager::Get(this)->GetService<FUiServiceDebug>())
		{
			targetIdp = debugService->GetSelectedEntityIdp();
		}

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::TEST,
			command,
			0,
			x,
			y,
			targetIdp
		);
		PacketTemp tp(wp.GetPacketBufPtr());
		SendCommand(tp);
		break;
	}
	default:
		break;
	}

	return FReply::Unhandled();
}

FReply UDungeonPlayViewportWidget::NativeOnKeyUp(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	FVector2D cursorPos0 = FSlateApplication::Get().GetCursorPos();
	FVector2D cursorPos1 = GetTickSpaceGeometry().AbsoluteToLocal(cursorPos0);
	FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPos1);
	const Scalar x = gridCursorPos.X * CELL_SIZE;
	const Scalar y = gridCursorPos.Y * CELL_SIZE;

	const WorldUserId worldUserId = GetMyWorldUserId();

	const uint8_t command = static_cast<uint8>(InKeyEvent.GetCharacter());
	switch (command)
	{
	case 'W':
	case 'A':
	case 'S':
	case 'D':
	{
		// 현재 WASD 키 눌림 상태를 직접 조회
		uint8_t keyState = 0;
		if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
		{
			if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
			if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
			if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
			if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
		}

		// KEY_UP 이벤트 시점에 IsInputKeyDown()이 아직 업데이트 안됐을 수 있으므로
		// 현재 떼는 키는 상태에서 제외
		uint8_t keyBit = 0;
		switch (command)
		{
		case 'W': keyBit = (1 << 0); break;
		case 'A': keyBit = (1 << 1); break;
		case 'S': keyBit = (1 << 2); break;
		case 'D': keyBit = (1 << 3); break;
		}
		keyState &= ~keyBit;

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::KEY_UP,
			command,
			keyState,
			x,
			y,
			INVALID_ENTITY_IDP
		);
		PacketTemp tp(wp.GetPacketBufPtr());
		SendCommand(tp);
		break;
	}
	default:
		break;
	}

	return FReply::Unhandled();
}

void UDungeonPlayViewportWidget::OnMouseButtonDownExtra(TSharedPtr<FUiServiceGame> gameService, const Entity* selectedEntity, const Scalar x, const Scalar y)
{
	const WorldUserId worldUserId = GetMyWorldUserId();

	// 현재 WASD 키 눌림 상태를 직접 조회
	uint8_t keyState = 0;
	if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
	{
		if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
		if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
		if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
		if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
	}

	if (selectedEntity)
	{
		// 공격 명령 시 자동 카메라 모드 복귀
		mCameraAutoCenter.EnableAutoMode();

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::ATTACK,
			'\0',
			keyState,
			x,
			y,
			selectedEntity->GetEntityIdp()
		);
		PacketTemp tp(wp.GetPacketBufPtr());
		SendCommand(tp);
	}
	// else: 빈 공간 클릭은 드래그가 될 수 있으므로 자동 모드로 전환하지 않음
}

void UDungeonPlayViewportWidget::SendCommand(const PacketTemp& packet)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	gameService->SendWorldUserCommand(packet);
}

void UDungeonPlayViewportWidget::NativeOnFocusLost(const FFocusEvent& InFocusEvent)
{
	Super::NativeOnFocusLost(InFocusEvent);

	// 포커스 잃을 때 키 상태 초기화 (모든 키 뗀 상태로 동기화)
	const WorldUserId worldUserId = GetMyWorldUserId();

	FTempBuffer buffer;
	WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
		worldUserId,
		WorldUserCommandType::KEY_UP,
		'\0',
		0,  // keyState = 0 (모든 키 해제)
		0,
		0,
		INVALID_ENTITY_IDP
	);
	PacketTemp tp(wp.GetPacketBufPtr());
	SendCommand(tp);
}

void UDungeonPlayViewportWidget::NativeOnAddedToFocusPath(const FFocusEvent& InFocusEvent)
{
	Super::NativeOnAddedToFocusPath(InFocusEvent);

	// 포커스 복구 시 현재 키 상태 동기화
	SendKeyStateSync();
}

void UDungeonPlayViewportWidget::SendKeyStateSync()
{
	// 현재 WASD 키 눌림 상태를 직접 조회하여 동기화
	uint8_t keyState = 0;
	if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
	{
		if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
		if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
		if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
		if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
	}

	const WorldUserId worldUserId = GetMyWorldUserId();

	// 키 상태 동기화 패킷 전송 (KEY_DOWN으로 전송하여 현재 상태 반영)
	FTempBuffer buffer;
	WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
		worldUserId,
		(keyState != 0) ? WorldUserCommandType::KEY_DOWN : WorldUserCommandType::KEY_UP,
		'\0',
		keyState,
		0,
		0,
		INVALID_ENTITY_IDP
	);
	PacketTemp tp(wp.GetPacketBufPtr());
	SendCommand(tp);
}

// ============================================================================
// CountNpcFollowers: PC가 소유한 NPC Follower 수 계산
// ============================================================================
int32 UDungeonPlayViewportWidget::CountNpcFollowers(Engine& engine, WorldUserId worldUserId) const
{
	int32 count = 0;

	engine.ForEachEntity([&](Entity& entity)
	{
		// PC 소속인지 확인
		PcComponent* pc = engine.TryGetComponent<PcComponent>(entity);
		if (!pc || pc->worldUserId != worldUserId)
			return;

		// Leader가 아닌 Follower만 카운트
		if (engine.TryGetComponent<LeaderComponent>(entity))
			return;

		// 죽어가는 중이거나 죽은 상태는 제외
		if (entity.HasComponent(MotionComponentDead::GetComponentType()) ||
			entity.HasComponent(MotionComponentDying::GetComponentType()))
			return;

		// 원래 NPC였던 캐릭터만 카운트 (wasNpcLeader 또는 originalNpcLeaderIdp 확인)
		CharacterComponent* character = engine.TryGetComponent<CharacterComponent>(entity);
		if (character)
		{
			if (character->wasNpcLeader || character->originalNpcLeaderIdp != INVALID_ENTITY_IDP)
			{
				++count;
			}
		}
	});

	return count;
}

// ============================================================================
// RenderFollowerUI: 하단에 소유 NPC Follower 목록 렌더링
// ============================================================================
int32 UDungeonPlayViewportWidget::RenderFollowerUI(
	const FPaintArgs& Args,
	const FGeometry& AllottedGeometry,
	const FSlateRect& MyCullingRect,
	FSlateWindowElementList& OutDrawElements,
	int32 LayerId,
	const FWidgetStyle& InWidgetStyle,
	bool bParentEnabled,
	Engine& engine,
	WorldUserId worldUserId
) const
{
	const int32 maxFollowers = DebugInfo::MAX_NPC_FOLLOWER;
	const int32 currentFollowers = CountNpcFollowers(engine, worldUserId);

	// UI 설정
	const float slotSize = 40.0f;
	const float slotGap = 4.0f;
	const float padding = 10.0f;
	const float bottomMargin = 20.0f;

	const FVector2D widgetSize = AllottedGeometry.GetLocalSize();
	const float totalWidth = maxFollowers * slotSize + (maxFollowers - 1) * slotGap;
	const float startX = (widgetSize.X - totalWidth) * 0.5f;
	const float startY = widgetSize.Y - bottomMargin - slotSize;

	// 배경 박스 (반투명)
	const FVector2D bgPos(startX - padding, startY - padding);
	const FVector2D bgSize(totalWidth + padding * 2, slotSize + padding * 2);

	FSlateDrawElement::MakeBox(
		OutDrawElements,
		LayerId,
		AllottedGeometry.ToPaintGeometry(bgSize, FSlateLayoutTransform(bgPos)),
		FCoreStyle::Get().GetBrush("WhiteBrush"),
		ESlateDrawEffect::None,
		FLinearColor(0.0f, 0.0f, 0.0f, 0.5f)
	);

	// 슬롯 렌더링
	int32 followerIndex = 0;

	// 슬롯 색상 결정을 위해 먼저 Follower 정보 수집
	TArray<FLinearColor> slotColors;
	slotColors.SetNum(maxFollowers);

	for (int32 i = 0; i < maxFollowers; ++i)
	{
		if (i < currentFollowers)
		{
			// 채워진 슬롯 - 파란색
			slotColors[i] = FLinearColor(0.2f, 0.4f, 0.8f, 0.9f);
		}
		else
		{
			// 빈 슬롯 - 회색
			slotColors[i] = FLinearColor(0.3f, 0.3f, 0.3f, 0.5f);
		}
	}

	// 실제 슬롯 그리기
	for (int32 i = 0; i < maxFollowers; ++i)
	{
		const float slotX = startX + i * (slotSize + slotGap);
		const float slotY = startY;

		// 슬롯 배경
		FSlateDrawElement::MakeBox(
			OutDrawElements,
			LayerId + 1,
			AllottedGeometry.ToPaintGeometry(FVector2D(slotSize, slotSize), FSlateLayoutTransform(FVector2D(slotX, slotY))),
			FCoreStyle::Get().GetBrush("WhiteBrush"),
			ESlateDrawEffect::None,
			slotColors[i]
		);

		// 슬롯 테두리
		FSlateDrawElement::MakeBox(
			OutDrawElements,
			LayerId + 2,
			AllottedGeometry.ToPaintGeometry(FVector2D(slotSize, slotSize), FSlateLayoutTransform(FVector2D(slotX, slotY))),
			FCoreStyle::Get().GetBrush("Border"),
			ESlateDrawEffect::None,
			FLinearColor(0.6f, 0.6f, 0.6f, 0.8f)
		);
	}

	// 텍스트: 현재/최대
	FSlateFontInfo fontInfo = FCoreStyle::GetDefaultFontStyle("Bold", 14);
	const FString countText = FString::Printf(TEXT("%d / %d"), currentFollowers, maxFollowers);
	const FVector2D textPos(startX + totalWidth * 0.5f - 30.0f, startY - 22.0f);

	FSlateDrawElement::MakeText(
		OutDrawElements,
		LayerId + 3,
		AllottedGeometry.ToPaintGeometry(FVector2D(60.0f, 20.0f), FSlateLayoutTransform(textPos)),
		countText,
		fontInfo,
		ESlateDrawEffect::None,
		FLinearColor::White
	);

	return LayerId + 4;
}
