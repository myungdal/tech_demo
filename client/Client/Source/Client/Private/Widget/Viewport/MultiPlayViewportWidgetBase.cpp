// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================



#include "MultiPlayViewportWidgetBase.h"

#include "Framework/Application/SlateApplication.h"

#include "MmoSync/Engine/System/SystemData.h"
#include "MmoSync/Engine/Entity/Entity.h"

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "MmoSync/GameInstance/GameInstance.h"
#include "MmoSync/Grid/MultiGrid.h"

#include "GameCore/GameCore.h"
#include "GameCore/GameCorePauseGuard.h"
#include "UiEvent/UiEventType.h"
#include "UiService/Debug/UiServiceDebug.h"
#include "GameRenderer/GameRenderDef.h"
#include "GameRenderer/Map/MapRenderer.h"
#include "GameCameraController/GameCameraViewport.h"
#include "SubSystem/UiServiceManager/UiServiceManager.h"
#include "SubSystem/NetworkManager/NetworkManager.h"
#include "SubSystem/NetworkContext/NetworkContext.h"
#include "SubSystem/NetworkManager/PacketPtr/PacketPtr.h"
#include "SubSystem/NetworkManager/SendBuffer/TempBuffer.h"
#include "UiService/Game/UiServiceGame.h"
#include "Util/PacketUtil/PacketUtil.h"


void UMultiPlayViewportWidgetBase::NativeConstruct()
{
	Super::NativeConstruct();
}

void UMultiPlayViewportWidgetBase::NativeDestruct()
{
	Super::NativeDestruct();
}

void UMultiPlayViewportWidgetBase::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)
{
	Super::NativeTick(MyGeometry, InDeltaTime);

	UNetworkContext* networkContext = UNetworkContext::Get(this);
	if (!networkContext)
		return;

	UUiServiceManager* uiServiceManager = UUiServiceManager::Get(this);
	if (!uiServiceManager)
		return;

	TSharedPtr<FUiServiceGame> gameService = uiServiceManager->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	const GameId& currGameId = networkContext->GetCurrGameId();
	if (currGameId == INVALID_UUID)
		return;

	const WorldUserId worldUserId = networkContext->CurrPacketHeader().GetWorldUserId();
	if (worldUserId == INVALID_WORLD_USER_ID)
		return;

	TryAutoCameraCenter(InDeltaTime, worldUserId);
}

int32 UMultiPlayViewportWidgetBase::NativePaint(const FPaintArgs& Args, const FGeometry& AllottedGeometry, const FSlateRect& MyCullingRect, FSlateWindowElementList& OutDrawElements, int32 LayerId, const FWidgetStyle& InWidgetStyle, bool bParentEnabled) const
{
#if WITH_EDITOR
	if (!GetWorld() || !GetWorld()->HasBegunPlay())
		return LayerId;
#endif

	UNetworkContext* networkContext = UNetworkContext::Get(this);
	if (!networkContext)
		return LayerId;

	UUiServiceManager* uiServiceManager = UUiServiceManager::Get(this);
	if (!uiServiceManager)
		return LayerId;

	TSharedPtr<FUiServiceGame> gameService = uiServiceManager->GetService<FUiServiceGame>();
	if (!gameService)
		return LayerId;

	const GameId& currGameId = networkContext->GetCurrGameId();
	if (currGameId == INVALID_UUID)
		return LayerId;

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return LayerId;

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return LayerId;

	mapRenderer->Tick(AllottedGeometry.GetLayoutBoundingRect(), Args.GetCurrentTime());
	LayerId = mapRenderer->OnPaint(Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, bParentEnabled);

	gameCore->GetGameRenderSystemDataGrid()->SetBuilt(false);
	gameCore->GetGameRenderSystemDataCharacter()->SetBuilt(false);

	const FGameCameraViewport& viewport = mapRenderer->GetViewportForGrid();
	const FPaintParams paintParams(GetWorld(), viewport, Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, bParentEnabled);

	gameService->Render(paintParams);

	return LayerId;
}

void UMultiPlayViewportWidgetBase::OnDispatchUiEvent(UUiEventBase* uiEvent)
{
	DispatchUiEvent(this, uiEvent);
}

WorldUserId UMultiPlayViewportWidgetBase::GetMyWorldUserId() const
{
	UNetworkContext* networkContext = UNetworkContext::Get(this);
	if (!networkContext)
		return WorldUserId(0);

	return networkContext->CurrPacketHeader().GetWorldUserId();
}

void UMultiPlayViewportWidgetBase::OnDispatchPacket(UPacketPtr* packetPtr)
{
	MAYBE_UNUSED const HandleResult handleResult = PacketUtil::DispatchPacket(this, *packetPtr->rp);
}

void UMultiPlayViewportWidgetBase::OnMouseButtonDownExtra(TSharedPtr<FUiServiceGame> gameService, const Entity* selectedEntity, const Scalar x, const Scalar y)
{
	const WorldUserId worldUserId = GetMyWorldUserId();

	// 현재 WASD 키 입력 상태를 직접 조회
	uint8_t keyState = 0;
	if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
	{
		if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
		if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
		if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
		if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
	}

	if (selectedEntity)
	{
		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::ATTACK,
			'\0',
			keyState,
			x,
			y,
			selectedEntity->GetEntityIdp()
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
	}
	else
	{
		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::MOVE,
			'\0',
			keyState,
			x,
			y,
			INVALID_ENTITY_IDP
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
	}
}

void UMultiPlayViewportWidgetBase::SendCommand(const PacketTemp& packet)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	gameService->SendWorldUserCommand(packet);
}

FReply UMultiPlayViewportWidgetBase::NativeOnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
#if defined(UE_EDITOR) || defined(_DEBUG)
	// Shift 키가 눌렸으면 NativeOnKeyDownWithShift에서 처리
	if (InKeyEvent.IsShiftDown())
		return NativeOnKeyDownWithShift(InGeometry, InKeyEvent);
#endif

	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	FVector2D cursorPos0 = FSlateApplication::Get().GetCursorPos();
	FVector2D cursorPos1 = GetTickSpaceGeometry().AbsoluteToLocal(cursorPos0);
	FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPos1);
	const Scalar x = gridCursorPos.X * CELL_SIZE;
	const Scalar y = gridCursorPos.Y * CELL_SIZE;

	const WorldUserId worldUserId = GetMyWorldUserId();

	if (InKeyEvent.IsRepeat())
		return FReply::Unhandled();

	const uint8_t command = static_cast<uint8>(InKeyEvent.GetCharacter());
	switch (command)
	{
	case 'Q':
		break;
	case 'E':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_CHARGE_E>(worldUserId);
		break;
	case 'R':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_RADAR_R>(worldUserId);
		break;
	case 'T':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_INVENTORY_T>(worldUserId);
		break;
	case '1':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_1>(worldUserId);
		break;
	case '2':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_2>(worldUserId);
		break;
	case '3':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_3>(worldUserId);
		break;
	case '4':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_4>(worldUserId);
		break;
	case '5':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_SKILL_5>(worldUserId);
		break;
	case 'Z':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_Z>(worldUserId);
		break;
	case 'X':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_X>(worldUserId);
		break;
	case 'C':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_C>(worldUserId);
		break;
	case 'V':
		UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_SHORTCUT_ITEM_V>(worldUserId);
		break;
	case 'W':
	case 'A':
	case 'S':
	case 'D':
	{
		// 현재 WASD 키 입력 상태를 직접 조회
		uint8_t keyState = 0;
		if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
		{
			if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
			if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
			if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
			if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
		}

		// KEY_DOWN 이벤트 시점에 IsInputKeyDown()이 아직 업데이트 안됐을 수 있으므로
		// 현재 눌린 키를 상태에 추가
		uint8_t keyBit = 0;
		switch (command)
		{
		case 'W': keyBit = (1 << 0); break;
		case 'A': keyBit = (1 << 1); break;
		case 'S': keyBit = (1 << 2); break;
		case 'D': keyBit = (1 << 3); break;
		}
		keyState |= keyBit;

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::KEY_DOWN,
			command,
			keyState,
			x,
			y,
			INVALID_ENTITY_IDP
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
		break;
	}
	default:
		break;
	}

	return FReply::Unhandled();
}

FReply UMultiPlayViewportWidgetBase::NativeOnKeyUp(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	FVector2D cursorPos0 = FSlateApplication::Get().GetCursorPos();
	FVector2D cursorPos1 = GetTickSpaceGeometry().AbsoluteToLocal(cursorPos0);
	FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPos1);
	const Scalar x = gridCursorPos.X * CELL_SIZE;
	const Scalar y = gridCursorPos.Y * CELL_SIZE;

	const WorldUserId worldUserId = GetMyWorldUserId();

	const uint8_t command = static_cast<uint8>(InKeyEvent.GetCharacter());
	switch (command)
	{
	case 'W':
	case 'A':
	case 'S':
	case 'D':
	{
		// 현재 WASD 키 입력 상태를 직접 조회
		uint8_t keyState = 0;
		if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
		{
			if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
			if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
			if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
			if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
		}

		// KEY_UP 이벤트 시점에 IsInputKeyDown()이 아직 업데이트 안됐을 수 있으므로
		// 현재 뗀 키를 상태에서 제거
		uint8_t keyBit = 0;
		switch (command)
		{
		case 'W': keyBit = (1 << 0); break;
		case 'A': keyBit = (1 << 1); break;
		case 'S': keyBit = (1 << 2); break;
		case 'D': keyBit = (1 << 3); break;
		}
		keyState &= ~keyBit;

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::KEY_UP,
			command,
			keyState,
			x,
			y,
			INVALID_ENTITY_IDP
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
		break;
	}
	default:
		break;
	}

	return FReply::Unhandled();
}

void UMultiPlayViewportWidgetBase::NativeOnFocusLost(const FFocusEvent& InFocusEvent)
{
	Super::NativeOnFocusLost(InFocusEvent);

	// 포커스 잃을 때 키 상태 초기화 (모든 키 뗌 상태로 동기화)
	const WorldUserId worldUserId = GetMyWorldUserId();

	FTempBuffer buffer;
	WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
		worldUserId,
		WorldUserCommandType::KEY_UP,
		'\0',
		0,  // keyState = 0 (모든 키 뗌)
		0,
		0,
		INVALID_ENTITY_IDP
	);
	SendCommand(PacketTemp(wp.GetPacketBufPtr()));
}

void UMultiPlayViewportWidgetBase::NativeOnAddedToFocusPath(const FFocusEvent& InFocusEvent)
{
	Super::NativeOnAddedToFocusPath(InFocusEvent);

	// 포커스 얻을 때 현재 키 상태 동기화
	SendKeyStateSync();
}

void UMultiPlayViewportWidgetBase::SendKeyStateSync()
{
	// 현재 WASD 키 입력 상태를 직접 조회하여 동기화
	uint8_t keyState = 0;
	if (APlayerController* PC = GetWorld()->GetFirstPlayerController())
	{
		if (PC->IsInputKeyDown(EKeys::W)) keyState |= (1 << 0);
		if (PC->IsInputKeyDown(EKeys::A)) keyState |= (1 << 1);
		if (PC->IsInputKeyDown(EKeys::S)) keyState |= (1 << 2);
		if (PC->IsInputKeyDown(EKeys::D)) keyState |= (1 << 3);
	}

	const WorldUserId worldUserId = GetMyWorldUserId();

	// 키 상태 동기화 패킷 전송 (KEY_DOWN으로 전송하여 현재 상태 반영)
	FTempBuffer buffer;
	WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
		worldUserId,
		(keyState != 0) ? WorldUserCommandType::KEY_DOWN : WorldUserCommandType::KEY_UP,
		'\0',
		keyState,
		0,
		0,
		INVALID_ENTITY_IDP
	);
	SendCommand(PacketTemp(wp.GetPacketBufPtr()));
}

FReply UMultiPlayViewportWidgetBase::NativeOnKeyDownWithShift(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return FReply::Unhandled();

	TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
	if (!gameInstance)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	FVector2D cursorPos0 = FSlateApplication::Get().GetCursorPos();
	FVector2D cursorPos1 = GetTickSpaceGeometry().AbsoluteToLocal(cursorPos0);
	FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPos1);
	const Scalar x = gridCursorPos.X * CELL_SIZE;
	const Scalar y = gridCursorPos.Y * CELL_SIZE;

	MultiGrid& grid = gameInstance->RefMultiGrid();
	const ColRowPair cell = grid.GetCell(gridCursorPos.X, gridCursorPos.Y);

	const WorldUserId worldUserId = GetMyWorldUserId();

	const uint8_t command = static_cast<uint8>(InKeyEvent.GetCharacter());
	switch (command)
	{
	case 'Z':
	case 'X':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '0':
	case 'C': // npc castle
	case 'V': // pc castle
	case 'N': // nest
	case 'R': // reset
	{
		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::TEST,
			command,
			0,  // TEST 커맨드에서는 키 상태가 필요 없음
			x,
			y,
			INVALID_ENTITY_IDP
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
		break;
	}
	case 'E': // destroy target
	{
		EntityIdp targetIdp = INVALID_ENTITY_IDP;
		if (TSharedPtr<FUiServiceDebug> debugService = UUiServiceManager::Get(this)->GetService<FUiServiceDebug>())
		{
			targetIdp = debugService->GetSelectedEntityIdp();
		}

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::TEST,
			command,
			0,
			x,
			y,
			targetIdp
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
		break;
	}
	case 'B': // block
		grid.SetBlocked(cell.first, cell.second, GridCellBlockType::HILL);
		break;
	case 'U': // unblock
		grid.SetUnblocked(cell.first, cell.second, GridCellBlockType::HILL);
		break;
	case 'T': // select entity
	{
		TSharedPtr<FUiServiceDebug> debugService = UUiServiceManager::Get(this)->GetService<FUiServiceDebug>();
		if (debugService)
			debugService->SelectEntity(x, y);
		break;
	}
	case 'Q': // 10% damage (Shift+Q)
	{
		EntityIdp targetIdp = INVALID_ENTITY_IDP;
		if (TSharedPtr<FUiServiceDebug> debugService = UUiServiceManager::Get(this)->GetService<FUiServiceDebug>())
		{
			targetIdp = debugService->GetSelectedEntityIdp();
		}

		FTempBuffer buffer;
		WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
			worldUserId,
			WorldUserCommandType::TEST,
			command,
			0,
			x,
			y,
			targetIdp
		);
		SendCommand(PacketTemp(wp.GetPacketBufPtr()));
		break;
	}
	default:
		break;
	}

	return FReply::Unhandled();
}
