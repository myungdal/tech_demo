// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "ViewportWidgetBase.h"

#include "Framework/Application/SlateApplication.h"
#include "GameFramework/PlayerController.h"

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/PacketCapsule/PacketTemp/PacketTemp.h"

#include "MmoSync/Component/CharacterComponent.h"
#include "MmoSync/Component/LeaderComponent.h"
#include "MmoSync/Component/PcComponent.h"
#include "MmoSync/Component/PhysicsComponent.h"
#include "MmoSync/Component/PositionComponent.h"
#include "MmoSync/DebugControlTool/DebugInfo.h"
#include "MmoSync/Engine/Engine.h"
#include "MmoSync/GameInstance/GameInstance.h"
#include "MmoSync/Grid/MultiGrid.h"
#include "MmoSync/Grid/MultiGridDef.h"
#include "MmoSync/WorldManager/WorldUserRegistry/WorldUser.h"

#include "GameCore/GameCore.h"
#include "GameCore/GameCorePauseGuard.h"
#include "GameRenderer/Character/ClientCharacterData.h"
#include "GameRenderer/Character/RenderSystemCharacter.h"
#include "GameRenderer/Map/MapRenderer.h"
#include "GameRenderer/MiniMap/MiniMapRenderer.h"
#include "SubSystem/NetworkManager/SendBuffer/TempBuffer.h"
#include "SubSystem/UiServiceManager/UiServiceManager.h"
#include "UiService/Debug/UiServiceDebug.h"
#include "UiService/Game/UiServiceGame.h"


void UViewportWidgetBase::OnDispatchUiEvent(UUiEventBase* uiEvent)
{
	DispatchUiEvent(this, uiEvent);
}

FVector2D UViewportWidgetBase::GetCursorPos(const FPointerEvent& pointerEvent)
{
	const FVector2D screenSpacePos = pointerEvent.GetScreenSpacePosition();
	return GetTickSpaceGeometry().AbsoluteToLocal(screenSpacePos);
}

void UViewportWidgetBase::TryAutoCameraCenter(float deltaTime, WorldUserId worldUserId)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return;

	TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
	if (!gameInstance)
		return;

	Engine& engine = gameInstance->GetEngine();

	TSharedPtr<FRenderSystemCharacter> renderSystemCharacter = gameService->GetGameRenderSystemCharacter();
	if (!renderSystemCharacter)
		return;

	WorldUser* worldUser = renderSystemCharacter->FindWorldUser(worldUserId);
	if (!worldUser)
		return;

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return;

	// 팔로워 수에 따른 카메라 줌 조정 + 리더 센터 위치 설정 (시야 중심용)
	if (worldUser->leaderEntityIdp != INVALID_ENTITY_IDP)
	{
		if (Entity* leaderEntity = engine.GetEntity(worldUser->leaderEntityIdp))
		{
			if (LeaderComponent* leaderComp = engine.TryGetComponent<LeaderComponent>(*leaderEntity))
			{
				mapRenderer->SetFollowerZoomBonus(leaderComp->followerCnt);
			}

			// 리더 위치를 시야 중심으로 설정 (수동 카메라 모드에서도 유닛 기준으로 시야 유지)
			if (PositionComponent* position = engine.TryGetComponent<PositionComponent>(*leaderEntity))
			{
				mapRenderer->SetLeaderCenterPos(position->x, position->y);
			}
		}
	}
	else
	{
		// 리더가 없으면 리더 센터 클리어 (카메라 중심이 시야 중심이 됨)
		mapRenderer->ClearLeaderCenterPos();
	}

	mCameraAutoCenter.TryAutoCameraCenter(deltaTime, *mapRenderer, *worldUser, engine);
}

FReply UViewportWidgetBase::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	const FVector2D cursorPosLocal = GetCursorPos(InMouseEvent);

	// 미니맵 클릭 처리 (최우선)
	TSharedPtr<FMiniMapRenderer> miniMapRenderer = gameService->GetMiniMapRenderer();
	if (miniMapRenderer)
	{
		if (miniMapRenderer->HandleClick(cursorPosLocal))
		{
			// 미니맵 클릭 → 확대됨, 이벤트 소비
			return FReply::Handled();
		}
		// 미니맵 외부 클릭 → 축소
		miniMapRenderer->HandleClickOutside(cursorPosLocal);
	}

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return FReply::Unhandled();

	TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
	if (!gameInstance)
		return FReply::Unhandled();

	Engine& engine = gameInstance->GetEngine();

	TSharedPtr<FRenderSystemCharacter> renderSystemCharacter = gameService->GetGameRenderSystemCharacter();
	WorldUser* worldUser = renderSystemCharacter ? renderSystemCharacter->FindWorldUser(0) : nullptr;

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	// WorldUser에 캐싱된 leaderEntityIdp 사용 (최적화)
	if (worldUser && worldUser->leaderEntityIdp != INVALID_ENTITY_IDP)
	{
		mapRenderer->UpdateGridCursorPos(cursorPosLocal);
		// 드래그 시작: 수동 카메라 모드로 전환
		mCameraAutoCenter.DisableAutoMode();
		mapRenderer->OnTouchStarted(InGeometry.GetLayoutBoundingRect(), cursorPosLocal);
	}
	else
	{
		mapRenderer->OnTouchStarted(InGeometry.GetLayoutBoundingRect(), cursorPosLocal);
	}

	const FVector2D gridCursorPos = mapRenderer->CalcGridCursorPos(cursorPosLocal);
	const Scalar x = static_cast<Scalar>(gridCursorPos.X * CELL_SIZE);
	const Scalar y = static_cast<Scalar>(gridCursorPos.Y * CELL_SIZE);

	engine.ForEachEntity(
		[&engine](Entity& entity)
		{
			CharacterComponent* character = engine.TryGetComponent<CharacterComponent>(entity);
			if (!character)
				return;

			character->clientCharacterState &= ~CLIENT_CHARACTER_STATE_DEBUG_SELECTED;
			character->clientCharacterState &= ~CLIENT_CHARACTER_STATE_DEBUG_CANDIDATE;
		}
	);

	// 렌더링된 보간 좌표를 기준으로 가장 가까운 엔티티 찾기
	Entity* selectedEntity = nullptr;
	Scalar minDistanceSq = MAX_SCALAR;

	engine.ForEachEntity(
		[&](Entity& entity)
		{
#if defined(UE_EDITOR) || defined(_DEBUG)
			const EntityIdp entityIdp = entity.GetEntityIdp();

			if (entityIdp.first == DebugInfo::DEBUG_ENTITY_ID)
				__nop();
#endif

			CharacterComponent* character = engine.TryGetComponent<CharacterComponent>(entity);
			if (!character)
				return;

			// 렌더링된 보간 좌표 가져오기
			ClientCharacterData* clientCharacterData = reinterpret_cast<ClientCharacterData*>(character->clientCharacterPtr);
			if (!clientCharacterData)
				return;

			Scalar clickRadius = CELL_SIZE;

			PhysicsComponent* physics = engine.TryGetComponent<PhysicsComponent>(entity);
			if (physics)
				clickRadius = physics->radius << 2;

			// 보간된 좌표와 클릭 위치 사이의 거리 계산
			// clientCharacterData는 그리드 좌표(float), x/y는 Scalar 월드 좌표
			const Scalar characterX = static_cast<Scalar>(clientCharacterData->GetX() * CELL_SIZE);
			const Scalar characterY = static_cast<Scalar>(clientCharacterData->GetY() * CELL_SIZE);
			const Scalar dx = characterX - x;
			const Scalar dy = characterY - y;
			const Scalar distanceSq = (dx * dx) + (dy * dy);
			const Scalar clickRadiusSq = MathUtil::Pow(clickRadius);

			// 반경 안에 있고 가장 가까운 엔티티 선택
			if (distanceSq <= clickRadiusSq && distanceSq < minDistanceSq)
			{
				minDistanceSq = distanceSq;
				selectedEntity = &entity;
			}
		}
	);

	if (selectedEntity)
	{
		if (CharacterComponent* selectedCharacter = engine.TryGetComponent<CharacterComponent>(*selectedEntity))
		{
			selectedCharacter->clientCharacterState |= CLIENT_CHARACTER_STATE_DEBUG_SELECTED;
			UUiServiceManager::Get(this)->GetService<FUiServiceDebug>()->SetSelectedEntityIdp(selectedEntity->GetEntityIdp());
			UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_DEBUG_ENTITY_SELECTED>();
		}
	}
	//else
	//{
	//	selectedEntity = nullptr;
	//	UUiServiceManager::Get(this)->GetService<FUiServiceDebug>()->SetSelectedEntityIdp(INVALID_ENTITY_IDP);
	//	UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_DEBUG_ENTITY_SELECTED>();
	//}

	OnMouseButtonDownExtra(gameService, selectedEntity, x, y);

	return FReply::Unhandled();
}

FReply UViewportWidgetBase::NativeOnMouseButtonUp(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	TSharedPtr<FRenderSystemCharacter> renderSystemCharacter = gameService->GetGameRenderSystemCharacter();
	WorldUser* worldUser = renderSystemCharacter ? renderSystemCharacter->FindWorldUser(0) : nullptr;

	// 드래그 종료 처리 (수동 모드여도 터치 종료 처리 필요)
	mapRenderer->OnTouchEnded();

	return FReply::Unhandled();
}

FReply UViewportWidgetBase::NativeOnMouseMove(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	// 수동 모드이거나 리더가 없을 때 드래그 카메라 이동 허용
	mapRenderer->OnTouchMoved(InGeometry.GetLayoutBoundingRect(), GetCursorPos(InMouseEvent));

	return UWidgetBase::NativeOnMouseMove(InGeometry, InMouseEvent);
}

void UViewportWidgetBase::NativeOnMouseEnter(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	if (!InMouseEvent.IsMouseButtonDown(EKeys::LeftMouseButton))
		return;

	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return;

	// 수동 모드이거나 리더가 없을 때 드래그 재개 허용
	mapRenderer->OnTouchStarted(InGeometry.GetLayoutBoundingRect(), GetCursorPos(InMouseEvent));
}

void UViewportWidgetBase::NativeOnMouseLeave(const FPointerEvent& InMouseEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return;

	// 드래그 종료 처리
	mapRenderer->OnTouchEnded();
}

FReply UViewportWidgetBase::NativeOnMouseWheel(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return FReply::Unhandled();

	TSharedPtr<FMapRenderer> mapRenderer = gameService->GetMapRenderer();
	if (!mapRenderer)
		return FReply::Unhandled();

	if (0.f < InMouseEvent.GetWheelDelta())
		mapRenderer->OnTouchZoomOut(InGeometry.GetLayoutBoundingRect());
	else
		mapRenderer->OnTouchZoomIn(InGeometry.GetLayoutBoundingRect());

	return FReply::Unhandled();
}

