// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "UiServiceGame.h"

#include "Packet/NetworkPacketAutoGenerated/PACKET_CD.h"
#include "Packet/NetworkPacketAutoGenerated/PACKET_CF.h"
#include "Packet/NetworkPacketAutoGenerated/PACKET_CG.h"
#include "Packet/NetworkPacketAutoGenerated/PACKET_CM.h"

#include "MmoSync/Component/PositionComponent.h"
#include "MmoSync/Engine/Engine.h"
#include "MmoSync/GameInstance/GameInstance.h"
#include "MmoSync/WorldManager/WorldUserRegistry/WorldUser.h"

#include "ClientUtil/ClientFileUtil.h"
#include "GameCore/GameCore.h"
#include "GameCore/Internal/GameCoreTimeStepPlayer.h"
#include "GameRenderer/Character/RenderSystemCharacter.h"
#include "GameRenderer/Effect/RenderEffectCircle.h"
#include "GameRenderer/Effect/RenderEffectLine.h"
#include "GameRenderer/Effect/RenderEffectObb.h"
#include "GameRenderer/Effect/RenderEffectSector.h"
#include "GameRenderer/Grid/RenderSystemGrid.h"
#include "GameRenderer/Map/MapRenderer.h"
#include "GameRenderer/MiniMap/MiniMapRenderer.h"
#include "GameRenderer/Prop/RenderSystemProp.h"
#include "SubSystem/NetworkContext/NetworkContext.h"
#include "SubSystem/NetworkManager/NetworkManager.h"
#include "SubSystem/NetworkManager/SendBuffer/TempBuffer.h"
#include "SubSystem/UiServiceManager/UiServiceManager.h"
#include "Util/PacketUtil/PacketUtil.h"
#include "Util/SocketUtil/SocketUtil.h"


FUiServiceGame::FUiServiceGame()
	:
	mWorldDataSerializer(MakeShared<Serializer>()),
	mGameCore(MakeShared<FGameCore>()),
	mMapRenderer(MakeShared<FMapRenderer>()),
	mMiniMapRenderer(MakeShared<FMiniMapRenderer>())
{
}

FUiServiceGame::~FUiServiceGame()
{
}

TSharedPtr<FRenderSystemGrid> FUiServiceGame::GetGameRenderSystemGrid()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderSystemGrid();
}

TSharedPtr<FRenderSystemProp> FUiServiceGame::GetGameRenderSystemProp()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderSystemProp();
}

TSharedPtr<FRenderSystemCharacter> FUiServiceGame::GetGameRenderSystemCharacter()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderSystemCharacter();
}

TSharedPtr<FRenderEffectLine> FUiServiceGame::GetGameRenderEffectLine()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderEffectLine();
}

TSharedPtr<FRenderEffectCircle> FUiServiceGame::GetGameRenderEffectCircle()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderEffectCircle();
}

TSharedPtr<FRenderEffectObb> FUiServiceGame::GetGameRenderEffectObb()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderEffectObb();
}

TSharedPtr<FRenderEffectSector> FUiServiceGame::GetGameRenderEffectSector()
{
	if (!mGameCore)
		return nullptr;

	return mGameCore->GetGameRenderEffectSector();
}

void FUiServiceGame::SelectGame(const GAME* val)
{
	_DEBUG_LOG(RED, L"{}", val->Get_c_game_id());
	mSelectedGame = val;
}

TSharedPtr<FGameCore> FUiServiceGame::GameCoreStart()
{
	mGameCore->GetGameCoreTimeStepPlayer()->Reset();
	mGameCore->StartCore();
	return mGameCore;
}

TSharedPtr<FGameCore> FUiServiceGame::GameCorePause()
{
	if (!mGameCore)
		return nullptr;

	mGameCore->PauseCore();
	return mGameCore;
}

void FUiServiceGame::GameCoreResume()
{
	if (!mGameCore)
		return;

	mGameCore->ResumeCore();
}

void FUiServiceGame::GameCorePacketPush(WorldUserId worldUserId, PacketTemp& cp, TimeStep stepCount)
{
	if (!mGameCore)
		return;

	GamePacketDataQueue* gamePacketDataQueue = mGameCore->GetGameCoreTimeStepPlayer()->AcquireGamePacketDataQueue();
	gamePacketDataQueue->emplace_back(GamePacketData{ worldUserId, cp });
	mGameCore->GetGameCoreTimeStepPlayer()->Push(gamePacketDataQueue, stepCount);
}

bool FUiServiceGame::IsStarted()
{
	if (!mGameCore)
		return false;

	return mGameCore->IsStarted();
}

void FUiServiceGame::SetPlayMode(EGamePlayMode mode)
{
	mPlayMode = mode;
	
	if (mode == EGamePlayMode::None)
	{
		mLastCommandTimeStep = 0;
		mCommandList.Empty();
		// memory_order(relaxed): 큐 사이즈는 디버그/대략적인 모니터링용.
		// 큐의 동기화/정합성은 별도 컨테이너(TQueue 등)가 담당하므로 여기서는 원자성만 필요.
		mCommandListSize.store(0, std::memory_order_relaxed);
	}


	// 모바일 키패드 활성화해야 할 경우...
	//if (AClientPlayerController* playerController = Cast<AClientPlayerController>(GetWorld()->GetFirstPlayerController()))
	//{
	//	if ()
	//		playerController->SetTouchInterfaceEnabled(true);
	//	else
	//		playerController->SetTouchInterfaceEnabled(false);
	//}
}

void FUiServiceGame::Update(const FGeometry& MyGeometry, float InDeltaTime, TimeStep timeStepNow, TimeStep timeStepToUpdate)
{
#if defined(UE_EDITOR) || defined(_DEBUG)
	// DebugInfo 주기적 리로드 (1초마다)
	mDebugInfoReloadTimer += InDeltaTime;
	if (mDebugInfoReloadTimer >= DEBUG_INFO_RELOAD_INTERVAL)
	{
		mDebugInfoReloadTimer = 0.0f;
		FClientFileUtil::ReloadDebugInfoFile();
	}
#endif

	if (!mGameCore)
		return;
	
	if (!IsLocalPlay())
		return;

	TSharedPtr<FRenderSystemCharacter> renderSystemCharacter = mGameCore->GetGameRenderSystemCharacter();
	if (!renderSystemCharacter)
		return;

	if (mLastCommandTimeStep == timeStepNow)
		return;

	mLastCommandTimeStep = timeStepNow;

	if (!mCommandList.IsEmpty())
	{
		PacketTemp tp;
		if (mCommandList.Dequeue(OUT tp))
		{
			// memory_order(relaxed): 사이즈 추적용 카운터(순서 보장 불필요).
			mCommandListSize.fetch_sub(1, std::memory_order_relaxed);

			if (WORLD_USER_COMMAND* command = static_cast<WORLD_USER_COMMAND*>(tp.GetPacket()))
			{
				WorldUser* worldUser = renderSystemCharacter->FindWorldUser(command->Get_worldUserId());
				if (worldUser)
					worldUser->SetWorldUserCommand(*command);
			}
		}
	}

#if defined(UE_EDITOR) || defined(_DEBUG)
	_TODO("커맨드 큐 과적재 감지: 원인 로그/대응 정책(드랍/압축/백프레셔) 추가")
	// memory_order(relaxed): 디버그 체크(근사치로 충분).
	if (mCommandListSize.load(std::memory_order_relaxed) > 100)
	{
		_DEBUG_BREAK;
	}
#endif

	FTempBuffer buffer;
	GC_GAME_UPDATE::Writer wp(NOTIFY, *buffer);
	wp.SetValues(
		timeStepToUpdate,
		timeStepNow,
		1,
		EngineUpdateChecksum{}
	);

	PacketTemp cp(wp.GetPacketBufPtr());
	GameCorePacketPush(INVALID_WORLD_USER_ID, cp, timeStepToUpdate);
}

void FUiServiceGame::Render(const FPaintParams& paintParams)
{
	if (!mGameCore)
		return;

	if (TSharedPtr<FRenderSystemGrid> renderSystemGrid = mGameCore->GetGameRenderSystemGrid())
	{
		renderSystemGrid->ResetSystemData();
		renderSystemGrid->BuildSystemData();
		renderSystemGrid->SetupPaintParams(paintParams);
		renderSystemGrid->Render();
	}

	if (TSharedPtr<FRenderSystemProp> renderSystemProp = mGameCore->GetGameRenderSystemProp())
	{
		renderSystemProp->ResetSystemData();
		renderSystemProp->BuildSystemData();
		renderSystemProp->SetupPaintParams(paintParams);
		renderSystemProp->Render();
	}

	if (TSharedPtr<FRenderSystemCharacter> renderSystemCharacter = mGameCore->GetGameRenderSystemCharacter())
	{
		renderSystemCharacter->ResetSystemData();
		renderSystemCharacter->BuildSystemData();
		renderSystemCharacter->SetupPaintParams(paintParams);
		renderSystemCharacter->Render();
	}

	if (TSharedPtr<FRenderEffectLine> renderEffectLine = mGameCore->GetGameRenderEffectLine())
	{
		renderEffectLine->SetupPaintParams(paintParams);
		renderEffectLine->Render();
	}
	if (TSharedPtr<FRenderEffectCircle> renderEffectCircle = mGameCore->GetGameRenderEffectCircle())
	{
		renderEffectCircle->SetupPaintParams(paintParams);
		renderEffectCircle->Render();
	}
	if (TSharedPtr<FRenderEffectObb> renderEffectObb = mGameCore->GetGameRenderEffectObb())
	{
		renderEffectObb->SetupPaintParams(paintParams);
		renderEffectObb->Render();
	}
	if (TSharedPtr<FRenderEffectSector> renderEffectSector = mGameCore->GetGameRenderEffectSector())
	{
		renderEffectSector->SetupPaintParams(paintParams);
		renderEffectSector->Render();
	}

	// ==================== 미니맵 렌더링 ====================
	if (mMiniMapRenderer)
	{
		mMiniMapRenderer->SetGameInstance(mGameCore->GetGameInstance());
		mMiniMapRenderer->Render(paintParams);
	}
}

void FUiServiceGame::SendWorldUserCommand(const PacketTemp& packet)
{
	switch (mPlayMode)
	{
	case EGamePlayMode::TestPlay:
	case EGamePlayMode::SinglePlay:
		// 로컬 플레이: 커맨드 큐에 추가
		mCommandList.Enqueue(packet);
		// memory_order(relaxed): 사이즈 추적용 카운터.
		mCommandListSize.fetch_add(1, std::memory_order_relaxed);
		break;

	case EGamePlayMode::MultiPlay:
		// 멀티플레이: 서버로 전송
		if (const WORLD_USER_COMMAND* command = static_cast<const WORLD_USER_COMMAND*>(packet.GetPacket()))
		{
			SocketUtil::Send<CG_WORLD_USER_COMMAND::Writer> sendWp(NOTIFY);
			sendWp.SetValues(*command);
		}
		break;

	default:
		break;
	}
}

void FUiServiceGame::OnDispatchUiEvent(UUiEventBase* uiEvent)
{
	DispatchUiEvent(this, uiEvent);
}

void FUiServiceGame::OnUiEvent(UUiEvent_POPUP_GAME_LIST_REQ_CLICKED& uiEvent)
{
	SocketUtil::Send<CM_REQ_GAME_LIST_OVER::Writer> wp(REQ);
	wp.SetValues(
		INVALID_UUID
	);

	UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_POPUP_GAME_LIST_OPEN>();
}

void FUiServiceGame::OnUiEvent(UUiEvent_POPUP_GAME_LIST_OK_CLICKED& uiEvent)
{
	const GAME* gameData = mSelectedGame;
	if (nullptr == gameData)
		return;

	SocketUtil::Send<CD_REQ_GAME_USER_ENTER::Writer> wp(REQ);
	wp.SetValues(
		gameData->Get_c_game_id()
	);
}

void FUiServiceGame::OnUiEvent(UUiEvent_DISCONNECTED& uiEvent)
{
	UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_POPUP_GAME_LIST_CLOSE_CLICKED>();

	mWorldDataSerializer->Reset();

	mGameCore = MakeShared<FGameCore>();
	mMapRenderer = MakeShared<FMapRenderer>();
}

void FUiServiceGame::OnUiEvent(UUiEvent_FATAL_ERROR& uiEvent)
{
	UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_POPUP_GAME_LIST_CLOSE_CLICKED>();

	mWorldDataSerializer->Reset();

	mGameCore = MakeShared<FGameCore>();
	mMapRenderer = MakeShared<FMapRenderer>();
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_ROLL_SPACEBAR& uiEvent)
{
	const WorldUserId worldUserId = uiEvent.GetMsg()->mWorldUserId;

	FTempBuffer buffer;
	WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
		worldUserId,
		WorldUserCommandType::ACTION,
		static_cast<uint8>(' '),
		0,  // commandKeyState: ACTION 커맨드에서는 키 상태가 중요하지 않음
		0,
		0,
		INVALID_ENTITY_IDP
	);
	PacketTemp tp(wp.GetPacketBufPtr());
	SendWorldUserCommand(tp);
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_CHARGE_E& uiEvent)
{
	const WorldUserId worldUserId = uiEvent.GetMsg()->mWorldUserId;

	FTempBuffer buffer;
	WORLD_USER_COMMAND::Writer wp(PARAM, *buffer,
		worldUserId,
		WorldUserCommandType::ACTION,
		static_cast<uint8>('E'),
		0,  // commandKeyState: ACTION 커맨드에서는 키 상태가 중요하지 않음
		0,
		0,
		INVALID_ENTITY_IDP
	);
	PacketTemp tp(wp.GetPacketBufPtr());
	SendWorldUserCommand(tp);
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_RADAR_R& uiEvent)
{
	// [TODO] 레이더 단축키 처리(기능/위젯 연동 필요)
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_INVENTORY_T& uiEvent)
{
	// [TODO] 인벤토리 UI 토글
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_MINIMAP_TAB& uiEvent)
{
	// [TODO] 미니맵 확대/축소 토글(렌더러/입력 포커스 규칙 정의 필요)
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_SKILL_1& uiEvent)
{
	// [TODO] 스킬 슬롯 1 발동
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_SKILL_2& uiEvent)
{
	// [TODO] 스킬 슬롯 2 발동
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_SKILL_3& uiEvent)
{
	// [TODO] 스킬 슬롯 3 발동
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_SKILL_4& uiEvent)
{
	// [TODO] 스킬 슬롯 4 발동
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_SKILL_5& uiEvent)
{
	// [TODO] 스킬 슬롯 5 발동
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_OK_ENTER& uiEvent)
{
	// [TODO] 확인/엔터 입력 처리(팝업/위젯 포커스 기준)
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_CANCEL_ESC& uiEvent)
{
	// [TODO] 취소/ESC 입력 처리(팝업/위젯 포커스 기준)
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_ITEM_Z& uiEvent)
{
	// [TODO] 아이템 퀵슬롯(Z) 사용
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_ITEM_X& uiEvent)
{
	// [TODO] 아이템 퀵슬롯(X) 사용
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_ITEM_C& uiEvent)
{
	// [TODO] 아이템 퀵슬롯(C) 사용
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_ITEM_V& uiEvent)
{
	// [TODO] 아이템 퀵슬롯(V) 사용
}

void FUiServiceGame::OnUiEvent(UUiEvent_SHORTCUT_ITEM_B& uiEvent)
{
	// [TODO] 아이템 퀵슬롯(B) 사용
}

void FUiServiceGame::OnDispatchPacket(NetworkPacket& rp)
{
	MAYBE_UNUSED const HandleResult handleResult = PacketUtil::DispatchPacket(this, rp);
}
