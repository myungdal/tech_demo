// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "SubSystem/UiServiceManager/UiServiceBase/UiServiceBase.h"
#include "UiEvent/AutoGenerated/UiEvent.h"
#include "Containers/Queue.h"
#include "Packet/PacketCapsule/PacketTemp/PacketTemp.h"

struct FGeometry;
class PacketTemp;
class Serializer;
class GAME;

class FGameCore;
class FMapRenderer;
class FMiniMapRenderer;
class FRenderSystemGrid;
class FRenderSystemProp;
class FRenderSystemCharacter;
class FRenderEffectLine;
class FRenderEffectCircle;
class FRenderEffectObb;
class FRenderEffectSector;
struct FPaintParams;
class UViewportWidgetBase;

// ========================================================================
// 게임 플레이 모드
// ------------------------------------------------------------------------
// TestPlay: 로컬 테스트 (서버 없이 클라이언트 단독 실행)
// SinglePlay: 싱글플레이 (로컬 서버 시뮬레이션)
// MultiPlay: 멀티플레이 (원격 서버 연결)
// ========================================================================
enum class EGamePlayMode : uint8
{
	None,
	TestPlay,
	SinglePlay,
	MultiPlay
};

class FUiServiceGame : public FUiServiceBase
{
private:
	friend class UUiServiceManager;
	static inline size_t mServiceIdx = 0;

	TSharedPtr<Serializer> mWorldDataSerializer = nullptr;

	const GAME* mSelectedGame = nullptr;

	TSharedPtr<FGameCore> mGameCore = nullptr;
	TSharedPtr<FMapRenderer> mMapRenderer = nullptr;
	TSharedPtr<FMiniMapRenderer> mMiniMapRenderer = nullptr;

	// ========== 플레이 모드 ==========
private:
	EGamePlayMode mPlayMode = EGamePlayMode::None;

	// Command를 한 스텝에 두 번 이상 보내지 않도록 하기 위해 마지막 Command의 TimeStep을 기억한다.
	TimeStep mLastCommandTimeStep = 0;
	TQueue<PacketTemp> mCommandList;
	std::atomic<size_t> mCommandListSize{0};  // TQueue가 멀티스레드 환경일 수 있으므로 atomic 사용

	// DebugInfo 리로드 타이머 (1초마다)
	float mDebugInfoReloadTimer = 0.0f;
	static constexpr float DEBUG_INFO_RELOAD_INTERVAL = 1.0f;

public:
	FUiServiceGame();
	virtual ~FUiServiceGame();

public:
	TSharedPtr<Serializer> GetWorldDataSerializer() { return mWorldDataSerializer; }

	TSharedPtr<FMapRenderer> GetMapRenderer() { return mMapRenderer; }
	TSharedPtr<FMiniMapRenderer> GetMiniMapRenderer() { return mMiniMapRenderer; }

	// ========== 플레이 모드 관리 ==========
	void SetPlayMode(EGamePlayMode mode);
	EGamePlayMode GetPlayMode() const { return mPlayMode; }
	bool IsLocalPlay() const { return mPlayMode == EGamePlayMode::TestPlay || mPlayMode == EGamePlayMode::SinglePlay; }

	TSharedPtr<FRenderSystemGrid> GetGameRenderSystemGrid();
	TSharedPtr<FRenderSystemProp> GetGameRenderSystemProp();
	TSharedPtr<FRenderSystemCharacter> GetGameRenderSystemCharacter();
	TSharedPtr<FRenderEffectLine> GetGameRenderEffectLine();
	TSharedPtr<FRenderEffectCircle> GetGameRenderEffectCircle();
	TSharedPtr<FRenderEffectObb> GetGameRenderEffectObb();
	TSharedPtr<FRenderEffectSector> GetGameRenderEffectSector();

public:
	void SelectGame(const GAME* val);
	const GAME* GetSelectedGame() const { return mSelectedGame; }

	TSharedPtr<FGameCore> GameCoreStart();
	TSharedPtr<FGameCore> GameCorePause();
	void GameCoreResume();
	void GameCorePacketPush(WorldUserId worldUserId, PacketTemp& cp, TimeStep stepCount);

	bool IsStarted();

public:
	void Update(const FGeometry& MyGeometry, float InDeltaTime, TimeStep timeStepNow, TimeStep timeStepToUpdate);
	void Render(const FPaintParams& paintParams);

public:
	void SendWorldUserCommand(const PacketTemp& packet);

public:
	void OnDispatchUiEvent(UUiEventBase* uiEvent) override;
	void OnUiEvent(UUiEventBase& uiEvent) {}
	void OnUiEvent(UUiEvent_POPUP_GAME_LIST_REQ_CLICKED& uiEvent);
	void OnUiEvent(UUiEvent_POPUP_GAME_LIST_OK_CLICKED& uiEvent);
	void OnUiEvent(UUiEvent_DISCONNECTED& uiEvent);
	void OnUiEvent(UUiEvent_FATAL_ERROR& uiEvent);

	// ========== Shortcut 이벤트 ==========
	void OnUiEvent(UUiEvent_SHORTCUT_ROLL_SPACEBAR& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_CHARGE_E& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_RADAR_R& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_INVENTORY_T& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_MINIMAP_TAB& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_SKILL_1& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_SKILL_2& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_SKILL_3& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_SKILL_4& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_SKILL_5& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_OK_ENTER& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_CANCEL_ESC& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_ITEM_Z& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_ITEM_X& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_ITEM_C& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_ITEM_V& uiEvent);
	void OnUiEvent(UUiEvent_SHORTCUT_ITEM_B& uiEvent);

public:
	void OnDispatchPacket(NetworkPacket& rp) override;
	HandleResult OnPacket(NetworkPacket& rp) { return HandleResult::OK; }
};
