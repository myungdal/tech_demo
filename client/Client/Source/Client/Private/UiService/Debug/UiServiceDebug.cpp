// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "UiServiceDebug.h"

#include "Util/PacketUtil/PacketUtil.h"
#include "UiEvent/AutoGenerated/UiEvent.h"

#include "GameCore/GameCore.h"
#include "Widget/Button/ButtonWidgetBase.h"
#include "UiService/Game/UiServiceGame.h"
#include "SubSystem/UiServiceManager/UiServiceManager.h"
#include "GameRenderer/Map/MapRenderer.h"
#include "GameRenderer/Grid/RenderSystemGrid.h"
#include "GameRenderer/Character/RenderSystemCharacter.h"
#include "GameCameraController/GameCameraViewport.h"
#include "Util/GameUtil/GameComponentPrinter.h"
#include "GameRenderer/Effect/RenderEffectSector.h"
#include "GameRenderer/Effect/RenderEffectObb.h"
#include "GameRenderer/Effect/RenderEffectCircle.h"


FUiServiceDebug::FUiServiceDebug()
{
}

FUiServiceDebug::~FUiServiceDebug()
{
}

void FUiServiceDebug::SelectEntity(Scalar x, Scalar y)
{
	TSharedPtr<FUiServiceGame> gameService = UUiServiceManager::Get(this)->GetService<FUiServiceGame>();
	if (!gameService)
		return;

	FGameCorePauseGuard gameCorePauseGuard(gameService);
	TSharedPtr<FGameCore> gameCore = gameCorePauseGuard.GetGameCore();
	if (!gameCore)
		return;

	TSharedPtr<GameInstance> gameInstance = gameCore->GetGameInstance();
	if (!gameInstance)
		return;

	Engine& engine = gameInstance->GetEngine();

	engine.ForEachEntity(
		[&engine](Entity& entity)
		{
			CharacterComponent* character = engine.TryGetComponent<CharacterComponent>(entity);
			if (!character)
				return;

			character->clientCharacterState &= ~CLIENT_CHARACTER_STATE_DEBUG_SELECTED;
			character->clientCharacterState &= ~CLIENT_CHARACTER_STATE_DEBUG_CANDIDATE;
		}
	);

	// 엔티티 선택 방법 예시
	// 원하는 방식의 #if 블록을 활성화하여 사용한다.
	// 0) 원형 영역          - PickEntityInPointInCircle
	// 1) 회전 직사각형(OBB) - PickEntityInObb
	// 2) 부채꼴(Sector)    - PickEntityInSector
	// 3) 격자(Grid) 패턴   - 체스판 형태
	std::deque<EntityIdp> entityList;

	switch (DebugInfo::DEBUG_PICK_ENTITY_MODE)
	{
	case 0:
	{
		// 포인트에 찍힌 엔티티를 선택, 특별히 CharacterComponent 의 Radius 까지 고쳐된다
		Entity* entity = gameInstance->GetWorldManager().PickEntityInPoint(x, y);
		if (entity)
		{
			entityList.emplace_back(entity->GetEntityIdp());
		}
		break;
	}
	case 1:
	{
		// 원형 영역 내의 모든 엔티티를 선택
		// 매개변수: 중심점(x, y), 반지름(CELL_SIZE의 제곱)
		// 예시: 플레이어 주변 2칸 반지름 내의 모든 엔티티 선택
		Scalar searchRadiusSq = MathUtil::Pow(CELL_SIZE * 2.0f); // 2칸 반지름
		gameInstance->GetWorldManager().PickEntityInCircle(x, y, searchRadiusSq, OUT entityList);

		if (TSharedPtr<FRenderEffectCircle> renderEffectCircle = gameService->GetGameRenderEffectCircle())
		{
			renderEffectCircle->RegisterCircle(
				FVector2D(x, y),
				static_cast<float>(MathUtil::Sqrt(searchRadiusSq)),
				1000,
				FLinearColor::Green,
				1.0f
			);
		}
		break;
	}
	case 2:
	{
		// OBB(Oriented Bounding Box) 영역으로 엔티티 선택 (회전 가능한 직사각형)
		// 매개변수: 중심점(x, y), 영역 크기
		Scalar halfWidth = static_cast<Scalar>(CELL_SIZE << 2); // 가로 
		Scalar halfHeight = static_cast<Scalar>(CELL_SIZE >> 1); // 세로 
		Angle rotation = MathUtil::DegreeToAngle(45);
		Scalar distanceFromCenter = static_cast<Scalar>(CELL_SIZE * 3.0f); // 중심 이동
		gameInstance->GetWorldManager().PickEntityInObb(
			x, y,
			halfWidth, halfHeight,
			rotation,
			distanceFromCenter,
			OUT entityList
		);

		if (TSharedPtr<FRenderEffectObb> renderEffectObb = gameService->GetGameRenderEffectObb())
		{
			Scalar dirX = MathUtil::Cos(rotation);
			Scalar dirY = MathUtil::Sin(rotation);
			Scalar centerX = x + ((dirX * distanceFromCenter) >> 10);
			Scalar centerY = y + ((dirY * distanceFromCenter) >> 10);

			renderEffectObb->RegisterObb(
				FVector2D(centerX, centerY),
				static_cast<float>(halfWidth),
				static_cast<float>(halfHeight),
				MathUtil::AngleToRadian(rotation),
				1000,
				FLinearColor::Blue,
				1.0f
			);
		}
		break;
	}
	case 3:
	{
		// 부채꼴(Sector) 영역으로 엔티티 선택 (각도 기반)
		// 매개변수: 중심점(x, y), 반지름, 각도
		// 예시: 플레이어가 바라보는 방향으로 90도 부채꼴 영역 내 엔티티 선택
		Scalar sqRange = MathUtil::Pow(CELL_SIZE * 2.0f); // 반지름의 제곱 값
		Angle rotation = MathUtil::DegreeToAngle(-45);	// 바라보는 방향(예시)
		Angle halfAngle = MathUtil::RadianToAngle(FLOAT_PI / 4.0f); // 총 45도 부채꼴
		Scalar distanceFromCenter = static_cast<Scalar>(CELL_SIZE * 1.0f); // 중심 이동
		gameInstance->GetWorldManager().PickEntityInSector(
			x, y,
			sqRange,
			rotation,
			halfAngle,
			distanceFromCenter,
			OUT entityList
		);

		if (TSharedPtr<FRenderEffectSector> renderEffectSector = gameService->GetGameRenderEffectSector())
		{
			Scalar dirX = MathUtil::Cos(rotation);
			Scalar dirY = MathUtil::Sin(rotation);
			Scalar originX = x + ((dirX * distanceFromCenter) >> 10);
			Scalar originY = y + ((dirY * distanceFromCenter) >> 10);

			renderEffectSector->RegisterSector(
				FVector2D(originX, originY),
				static_cast<float>(MathUtil::Sqrt(sqRange)),
				MathUtil::AngleToRadian(rotation),
				MathUtil::AngleToRadian(halfAngle),
				1000,
				FLinearColor::Red,
				1.0f
			);
		}
		break;
	}
	case 4:
	{
		// 그리드 기반 영역으로 엔티티 선택 (격자 패턴)
		// 예시: 체스판처럼 격자 패턴으로 엔티티 선택
		Scalar gridSize = CELL_SIZE * 2.0f; // 2칸 간격
		int gridRadius = 3; // 3x3 그리드

		for (int dx = -gridRadius; dx <= gridRadius; ++dx) {
			for (int dy = -gridRadius; dy <= gridRadius; ++dy) {
				// 격자 패턴 (체스판처럼)
				if ((dx + dy) % 2 == 0) {
					Scalar gridX = x + dx * gridSize;
					Scalar gridY = y + dy * gridSize;
					std::deque<EntityIdp> tempList;
					gameInstance->GetWorldManager().PickEntityInCircle(
						gridX, gridY,
						MathUtil::Pow(CELL_SIZE * 0.5f), // 각 격자점에서 0.5칸 반지름
						OUT tempList
					);
					entityList.insert(entityList.end(), tempList.begin(), tempList.end());
				}
			}
		}
		break;
	}
	default:
		break;
	}

	Scalar closestDistSq = std::numeric_limits<Scalar>::max();
	EntityIdp closestEntityIdp = INVALID_ENTITY_IDP;
	for (EntityIdp entityIdp : entityList)
	{
		PositionComponent* position = engine.TryGetComponent<PositionComponent>(entityIdp);
		if (!position)
			continue;

		const Scalar dx = (position->x - x);
		const Scalar dy = (position->y - y);
		const Scalar distSq = MathUtil::DistanceSq(dx, dy);
		if (closestDistSq > distSq)
		{
			closestDistSq = distSq;
			closestEntityIdp = entityIdp;
		}
	}
	_DEBUG_LOG(RED, L"selectEntityIdp: {}, x: {}, y: {}", closestEntityIdp, x, y);

	for (EntityIdp entityIdp : entityList)
	{
		CharacterComponent* character = engine.TryGetComponent<CharacterComponent>(entityIdp);
		if (!character)
			continue;

		if (closestEntityIdp == entityIdp)
			character->clientCharacterState |= CLIENT_CHARACTER_STATE_DEBUG_SELECTED;
		else
			character->clientCharacterState |= CLIENT_CHARACTER_STATE_DEBUG_CANDIDATE;
	}

	SetSelectedEntityIdp(closestEntityIdp);
	UUiServiceManager::Get(this)->BroadcastUiEvent<UUiEvent_DEBUG_ENTITY_SELECTED>();
}

void FUiServiceDebug::OnDispatchUiEvent(UUiEventBase* uiEvent)
{
	DispatchUiEvent(this, uiEvent);
}

void FUiServiceDebug::OnDispatchPacket(NetworkPacket& rp)
{
	MAYBE_UNUSED const HandleResult handleResult = PacketUtil::DispatchPacket(this, rp);
}
