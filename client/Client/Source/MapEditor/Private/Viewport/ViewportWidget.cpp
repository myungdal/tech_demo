// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "ViewportWidget.h"

#include "SlateOptMacros.h"
#include "Widgets/SBoxPanel.h"
#include "Widgets/Input/SButton.h"
#include "Widgets/Layout/SSpacer.h"

#include "MmoSync/Util/Noise/NaturalNoise.h"

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"

#include "GameRenderer/Map/MapRenderer.h"
#include "ClientUtil/ClientStringUtil.h"
#include "SubSystem/NetworkManager/SendBuffer/TempBuffer.h"

#include "MapEditor/Private/Viewport/GridLineRenderer/GridLineRenderer.h"
#include "MmoSync/Map/GridGeneration/FieldGridGenerator.h"
#include "MmoSync/Map/GridGeneration/DungeonGridGenerator.h"
#include "MmoSync/Map/Types/MapGenerationSettings.h"
#include "MmoSync/Map/Types/AsciiMap.h"
#include "MmoSync/Grid/MultiGrid.h"
#include "MmoSync/Map/Configuration/MapConfig.h"
#include "MmoSync/Map/Configuration/FieldMapConfig.h"
#include "SharedLib/WorldCreationHelper/WorldCreationHelper.h"


#define LOCTEXT_NAMESPACE "MapEditor"

BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION
void SViewportWidget::Construct(const FArguments& InArgs)
{
	mMapRenderer = std::make_shared<FMapRenderer>();
	mGridLineRenderer = std::make_shared<FGridLineRenderer>(0, 0);
}
END_SLATE_FUNCTION_BUILD_OPTIMIZATION

void SViewportWidget::Load(SMapListWidget::ItemPtr item)
{
	const UMapData& data = *item->mData;

	FTempBuffer buffer;
	STATIC_MAP::Writer wp(PARAM, *buffer,
		data.mMapSid,
		*ClientStringUtil::s_to_w(data.mName),
		data.mTileTheme,
		data.mWidthFactor,
		data.mHeightFactor,
		data.mLevelDivisionList[0],
		data.mLevelDivisionList[1],
		data.mLevelDivisionList[2],
		data.mLevelDivisionList[3],
		data.mLevelDivisionList[4],
		data.mLevelDivisionList[5],
		data.mLevelDivisionList[6],
		data.mFractalScaleList[0].mX,
		data.mFractalScaleList[1].mX,
		data.mFractalScaleList[2].mX,
		data.mFractalScaleList[3].mX,
		data.mFractalScaleList[0].mY,
		data.mFractalScaleList[1].mY,
		data.mFractalScaleList[2].mY,
		data.mFractalScaleList[3].mY,
		data.mFractalScaleList[0].mW,
		data.mFractalScaleList[1].mW,
		data.mFractalScaleList[2].mW,
		data.mFractalScaleList[3].mW,
		data.mRandomSeed,
		*ClientStringUtil::s_to_w(data.mInitialSystemGroupName),
		*ClientStringUtil::s_to_w(data.mInitialSystemGroupFsmStateName)
	);
	const STATIC_MAP* staticMap = &wp.GetPacket();

	// STATIC_MAP에서 FieldMapConfig 생성
	FieldMapConfig fieldConfig = WorldCreationHelper::MakeGridConfig(staticMap);
	MapConfig mapConfig(fieldConfig);

	// MapGenerationSettings 생성
	MapGenerationSettings settings;
	settings.SetMapKind(mapConfig.mapKind);
	settings.mapConfig = mapConfig;
	settings.entitySettings.castleCount = 0;
	settings.entitySettings.nestCount = 0;

	// MultiGrid 생성
	MultiGrid dummyGrid(mapConfig.GetColFactor(), mapConfig.GetRowFactor());

	// GridGenerator로 AsciiMap 생성 (Engine 없이)
	std::unique_ptr<GridGeneratorBase> generator;
	if (settings.IsField())
	{
		generator = std::make_unique<FieldGridGenerator>(mapConfig);
	}
	else if (settings.IsDungeon())
	{
		generator = std::make_unique<DungeonGridGenerator>(mapConfig);
	}

	// AsciiMap 생성
	std::unique_ptr<AsciiMap> asciiMap = generator->CreateMultiGrid(dummyGrid, settings);

	// FMapRenderer에 로드
	mMapRenderer->Load(*asciiMap);
	mGridLineRenderer = std::make_shared<FGridLineRenderer>(mMapRenderer->GetMapWidth(), mMapRenderer->GetMapHeight());
}

//void SViewportWidget::Tick(const FGeometry& AllottedGeometry, const double InCurrentTime, const float InDeltaTime)
//{
//	SCompoundWidget::Tick(AllottedGeometry, InCurrentTime, InDeltaTime);
//}

int32 SViewportWidget::OnPaint(const FPaintArgs& Args, const FGeometry& AllottedGeometry, const FSlateRect& MyCullingRect, FSlateWindowElementList& OutDrawElements, int32 LayerId, const FWidgetStyle& InWidgetStyle, bool bParentEnabled) const
{
	mMapRenderer->Tick(AllottedGeometry.GetLayoutBoundingRect(), Args.GetCurrentTime());

	LayerId = mMapRenderer->OnPaint(Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, bParentEnabled);

	LayerId = mGridLineRenderer->OnPaint(
		mMapRenderer->GetViewportForGrid(),
		Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, bParentEnabled
	);

	return LayerId;
}

FReply SViewportWidget::OnMouseButtonDown(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)
{
	if (true == MouseEvent.IsMouseButtonDown(EKeys::LeftMouseButton))
	{
		mMapRenderer->OnTouchStarted(MyGeometry.GetLayoutBoundingRect(), GetCursorPos(MouseEvent));
	}

	//return SCompoundWidget::OnMouseButtonDown(MyGeometry, MouseEvent);
	return FReply::Unhandled();
}

FReply SViewportWidget::OnMouseButtonUp(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)
{
	if (false == MouseEvent.IsMouseButtonDown(EKeys::LeftMouseButton))
	{
		mMapRenderer->OnTouchEnded();
	}

	//return SCompoundWidget::OnMouseButtonUp(MyGeometry, MouseEvent);
	return FReply::Unhandled();
}

FReply SViewportWidget::OnMouseMove(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)
{
	mMapRenderer->OnTouchMoved(MyGeometry.GetLayoutBoundingRect(), GetCursorPos(MouseEvent));
	
	const GridCol c = static_cast<GridCol>(mMapRenderer->GetGridCursorPos().X);
	const GridRow r = static_cast<GridRow>(mMapRenderer->GetGridCursorPos().Y);
	mGridLineRenderer->UpdateCursorPos(c, r);

	//return SCompoundWidget::OnMouseMove(MyGeometry, MouseEvent);
	return FReply::Unhandled();
}

void SViewportWidget::OnMouseEnter(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)
{
	//SCompoundWidget::OnMouseEnter(MyGeometry, MouseEvent);

	if (true == MouseEvent.IsMouseButtonDown(EKeys::LeftMouseButton))
	{
		mMapRenderer->OnTouchStarted(MyGeometry.GetLayoutBoundingRect(), GetCursorPos(MouseEvent));
	}
}

void SViewportWidget::OnMouseLeave(const FPointerEvent& MouseEvent)
{
	//SCompoundWidget::OnMouseLeave(MouseEvent);

	mMapRenderer->OnTouchEnded();
}

FReply SViewportWidget::OnMouseWheel(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)
{
	if (0.f < MouseEvent.GetWheelDelta())
	{
		mMapRenderer->OnTouchZoomOut(MyGeometry.GetLayoutBoundingRect());
	}
	else
	{
		mMapRenderer->OnTouchZoomIn(MyGeometry.GetLayoutBoundingRect());
	}

	//return SCompoundWidget::OnMouseWheel(MyGeometry, MouseEvent);
	return FReply::Unhandled();
}

bool SViewportWidget::SupportsKeyboardFocus() const
{
	return true;
}

FReply SViewportWidget::OnKeyUp(const FGeometry& MyGeometry, const FKeyEvent& InKeyEvent)
{
	switch (InKeyEvent.GetCharacter())
	{
	case 'Q':
	{
		mMapRenderer->OnTouchZoomOut(MyGeometry.GetLayoutBoundingRect());
		break;
	}
	case 'E':
	{
		mMapRenderer->OnTouchZoomIn(MyGeometry.GetLayoutBoundingRect());
		break;
	}
	default:
	{
		break;
	}
	}

	//return SCompoundWidget::OnKeyDown(MyGeometry, InKeyEvent);
	return FReply::Unhandled();
}

FVector2D SViewportWidget::GetCursorPos(const FPointerEvent& pointerEvent)
{
	FVector2D screenSpacePos = pointerEvent.GetScreenSpacePosition();
	FVector2D cursorPos = GetTickSpaceGeometry().AbsoluteToLocal(screenSpacePos);
	return cursorPos;
}

#undef LOCTEXT_NAMESPACE
