// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/NetworkPacket/NetworkPacket.h"
#include "Packet/NetworkPacket/NetworkPacketWriter.h"
#include "Packet/BasePacket/PacketWriter.h"
#include "Packet/PacketDataList/PacketDataList.h"
#include "Packet/PacketFuncs/PacketValidator.h"
#include "Packet/PacketFuncs/PacketDispatcher.h"

#pragma pack(push, 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_CHEAT;

class CD_REQ_CHEAT_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_CHEAT;

public:
   // (1)
   explicit CD_REQ_CHEAT_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_CHEAT, buf)
   {
   }

   // (2)
   explicit CD_REQ_CHEAT_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_CHEAT, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_CHEAT_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_CHEAT, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_CHEAT_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const wchar_t* command
   )
   {
       PacketSize& commandOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& commandLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       commandOffset = GetPacketSize();
       commandLength = (PacketSize)wcsnlen_s(command, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == commandLength) WriteString(L"", 0);
       else WriteString(command, commandLength); 

   }

   CD_REQ_CHEAT& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_CHEAT*>(GetPacketBufPtr()); }
   CD_REQ_CHEAT* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_CHEAT*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_CHEAT : public NetworkPacket
{
   public:
      using Writer = CD_REQ_CHEAT_WRITER;


private:
   PacketSize m_command_offset = 0;
   PacketSize m_command_length = 0;

public:
   CD_REQ_CHEAT()
   {
       memset(this, 0, sizeof(CD_REQ_CHEAT));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_CHEAT));
   }
   CD_REQ_CHEAT(const CD_REQ_CHEAT&) = delete;
   CD_REQ_CHEAT(CD_REQ_CHEAT &&) = delete;
   CD_REQ_CHEAT& operator = (const CD_REQ_CHEAT&) = delete;
   CD_REQ_CHEAT& operator = (CD_REQ_CHEAT &&) = delete;

   const wchar_t* Get_command() const
   {
       if (0 != *((const wchar_t*)((uint8_t*)this + m_command_offset) + m_command_length))
           return L"";

       return (const wchar_t*)((uint8_t*)this + m_command_offset);
   }

   wchar_t* Ref_command()
   {
       if (0 != *((wchar_t*)((uint8_t*)this + m_command_offset) + m_command_length))
           return nullptr;

       return (wchar_t*)((uint8_t*)this + m_command_offset);
   }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_CHEAT) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_CHEAT) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_CHEAT); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_CHEAT))
           {
               size += sizeof(CD_REQ_CHEAT);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_command_offset)
               return false;

           if (0 < m_command_offset)
               thisSize += sizeof(wchar_t) * (size_t(m_command_length) + 1);

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_CHEAT>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}command: {}", tTabStr, t->Get_command());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_STATIC_DATA_CHECKSUM;

class CD_REQ_STATIC_DATA_CHECKSUM_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_STATIC_DATA_CHECKSUM;

public:
   // (1)
   explicit CD_REQ_STATIC_DATA_CHECKSUM_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_STATIC_DATA_CHECKSUM, buf)
   {

   }

   // (2)
   explicit CD_REQ_STATIC_DATA_CHECKSUM_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_STATIC_DATA_CHECKSUM, buf)
   {
       SetReadPacket(rp);

   }

   // (3)
   explicit CD_REQ_STATIC_DATA_CHECKSUM_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_STATIC_DATA_CHECKSUM, buf)
   {
       SetWritePacket(wp);

   }

   // (8)
   explicit CD_REQ_STATIC_DATA_CHECKSUM_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   CD_REQ_STATIC_DATA_CHECKSUM& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_STATIC_DATA_CHECKSUM*>(GetPacketBufPtr()); }
   CD_REQ_STATIC_DATA_CHECKSUM* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_STATIC_DATA_CHECKSUM*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_STATIC_DATA_CHECKSUM : public NetworkPacket
{
   public:
      using Writer = CD_REQ_STATIC_DATA_CHECKSUM_WRITER;


private:
public:
   CD_REQ_STATIC_DATA_CHECKSUM()
   {
       memset(this, 0, sizeof(CD_REQ_STATIC_DATA_CHECKSUM));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_STATIC_DATA_CHECKSUM));
   }
   CD_REQ_STATIC_DATA_CHECKSUM(const CD_REQ_STATIC_DATA_CHECKSUM&) = delete;
   CD_REQ_STATIC_DATA_CHECKSUM(CD_REQ_STATIC_DATA_CHECKSUM &&) = delete;
   CD_REQ_STATIC_DATA_CHECKSUM& operator = (const CD_REQ_STATIC_DATA_CHECKSUM&) = delete;
   CD_REQ_STATIC_DATA_CHECKSUM& operator = (CD_REQ_STATIC_DATA_CHECKSUM &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_STATIC_DATA_CHECKSUM) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_STATIC_DATA_CHECKSUM) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_STATIC_DATA_CHECKSUM); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_STATIC_DATA_CHECKSUM))
           {
               size += sizeof(CD_REQ_STATIC_DATA_CHECKSUM);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_STATIC_DATA_CHECKSUM>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_STATIC_DATA;

class CD_REQ_STATIC_DATA_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_STATIC_DATA;

public:
   // (1)
   explicit CD_REQ_STATIC_DATA_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_STATIC_DATA, buf)
   {
   }

   // (2)
   explicit CD_REQ_STATIC_DATA_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_STATIC_DATA, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_STATIC_DATA_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_STATIC_DATA, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_STATIC_DATA_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       StaticDataIndex index
   )
   {
       WriteValue(index);


   }

   CD_REQ_STATIC_DATA& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_STATIC_DATA*>(GetPacketBufPtr()); }
   CD_REQ_STATIC_DATA* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_STATIC_DATA*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_STATIC_DATA : public NetworkPacket
{
   public:
      using Writer = CD_REQ_STATIC_DATA_WRITER;


private:
   StaticDataIndex m_index;

public:
   CD_REQ_STATIC_DATA()
   {
       memset(this, 0, sizeof(CD_REQ_STATIC_DATA));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_STATIC_DATA));
   }
   CD_REQ_STATIC_DATA(const CD_REQ_STATIC_DATA&) = delete;
   CD_REQ_STATIC_DATA(CD_REQ_STATIC_DATA &&) = delete;
   CD_REQ_STATIC_DATA& operator = (const CD_REQ_STATIC_DATA&) = delete;
   CD_REQ_STATIC_DATA& operator = (CD_REQ_STATIC_DATA &&) = delete;

   StaticDataIndex Get_index() const noexcept { return m_index; }
   StaticDataIndex& Ref_index() noexcept { return m_index; }
   const StaticDataIndex& ConstRef_index() const noexcept { return m_index; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_STATIC_DATA) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_STATIC_DATA) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_STATIC_DATA); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_STATIC_DATA))
           {
               size += sizeof(CD_REQ_STATIC_DATA);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(StaticDataIndex);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_STATIC_DATA>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}index: {}", tTabStr, t->Get_index());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_USER_DATA;

class CD_REQ_USER_DATA_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_USER_DATA;

public:
   // (1)
   explicit CD_REQ_USER_DATA_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_USER_DATA, buf)
   {

   }

   // (2)
   explicit CD_REQ_USER_DATA_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_USER_DATA, buf)
   {
       SetReadPacket(rp);

   }

   // (3)
   explicit CD_REQ_USER_DATA_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_USER_DATA, buf)
   {
       SetWritePacket(wp);

   }

   // (8)
   explicit CD_REQ_USER_DATA_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   CD_REQ_USER_DATA& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_USER_DATA*>(GetPacketBufPtr()); }
   CD_REQ_USER_DATA* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_USER_DATA*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_USER_DATA : public NetworkPacket
{
   public:
      using Writer = CD_REQ_USER_DATA_WRITER;


private:
public:
   CD_REQ_USER_DATA()
   {
       memset(this, 0, sizeof(CD_REQ_USER_DATA));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_USER_DATA));
   }
   CD_REQ_USER_DATA(const CD_REQ_USER_DATA&) = delete;
   CD_REQ_USER_DATA(CD_REQ_USER_DATA &&) = delete;
   CD_REQ_USER_DATA& operator = (const CD_REQ_USER_DATA&) = delete;
   CD_REQ_USER_DATA& operator = (CD_REQ_USER_DATA &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_USER_DATA) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_USER_DATA) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_USER_DATA); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_USER_DATA))
           {
               size += sizeof(CD_REQ_USER_DATA);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_USER_DATA>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_USER_LEVEL_UP;

class CD_REQ_USER_LEVEL_UP_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_USER_LEVEL_UP;

public:
   // (1)
   explicit CD_REQ_USER_LEVEL_UP_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_USER_LEVEL_UP, buf)
   {

   }

   // (2)
   explicit CD_REQ_USER_LEVEL_UP_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_USER_LEVEL_UP, buf)
   {
       SetReadPacket(rp);

   }

   // (3)
   explicit CD_REQ_USER_LEVEL_UP_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_USER_LEVEL_UP, buf)
   {
       SetWritePacket(wp);

   }

   // (8)
   explicit CD_REQ_USER_LEVEL_UP_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   CD_REQ_USER_LEVEL_UP& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_USER_LEVEL_UP*>(GetPacketBufPtr()); }
   CD_REQ_USER_LEVEL_UP* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_USER_LEVEL_UP*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_USER_LEVEL_UP : public NetworkPacket
{
   public:
      using Writer = CD_REQ_USER_LEVEL_UP_WRITER;


private:
public:
   CD_REQ_USER_LEVEL_UP()
   {
       memset(this, 0, sizeof(CD_REQ_USER_LEVEL_UP));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_USER_LEVEL_UP));
   }
   CD_REQ_USER_LEVEL_UP(const CD_REQ_USER_LEVEL_UP&) = delete;
   CD_REQ_USER_LEVEL_UP(CD_REQ_USER_LEVEL_UP &&) = delete;
   CD_REQ_USER_LEVEL_UP& operator = (const CD_REQ_USER_LEVEL_UP&) = delete;
   CD_REQ_USER_LEVEL_UP& operator = (CD_REQ_USER_LEVEL_UP &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_USER_LEVEL_UP) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_USER_LEVEL_UP) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_USER_LEVEL_UP); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_USER_LEVEL_UP))
           {
               size += sizeof(CD_REQ_USER_LEVEL_UP);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_USER_LEVEL_UP>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_ITEM_USE;

class CD_REQ_ITEM_USE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_ITEM_USE;

public:
   // (1)
   explicit CD_REQ_ITEM_USE_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_ITEM_USE, buf)
   {
   }

   // (2)
   explicit CD_REQ_ITEM_USE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_ITEM_USE, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_ITEM_USE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_ITEM_USE, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_ITEM_USE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       ItemId itemId,
       ItemQuantity itemQuantity
   )
   {
       WriteValue(itemId);

       WriteValue(itemQuantity);


   }

   CD_REQ_ITEM_USE& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_ITEM_USE*>(GetPacketBufPtr()); }
   CD_REQ_ITEM_USE* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_ITEM_USE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_ITEM_USE : public NetworkPacket
{
   public:
      using Writer = CD_REQ_ITEM_USE_WRITER;


private:
   ItemId m_itemId;

   ItemQuantity m_itemQuantity;

public:
   CD_REQ_ITEM_USE()
   {
       memset(this, 0, sizeof(CD_REQ_ITEM_USE));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_ITEM_USE));
   }
   CD_REQ_ITEM_USE(const CD_REQ_ITEM_USE&) = delete;
   CD_REQ_ITEM_USE(CD_REQ_ITEM_USE &&) = delete;
   CD_REQ_ITEM_USE& operator = (const CD_REQ_ITEM_USE&) = delete;
   CD_REQ_ITEM_USE& operator = (CD_REQ_ITEM_USE &&) = delete;

   ItemId Get_itemId() const noexcept { return m_itemId; }
   ItemId& Ref_itemId() noexcept { return m_itemId; }
   const ItemId& ConstRef_itemId() const noexcept { return m_itemId; }

   ItemQuantity Get_itemQuantity() const noexcept { return m_itemQuantity; }
   ItemQuantity& Ref_itemQuantity() noexcept { return m_itemQuantity; }
   const ItemQuantity& ConstRef_itemQuantity() const noexcept { return m_itemQuantity; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_ITEM_USE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_ITEM_USE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_ITEM_USE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_ITEM_USE))
           {
               size += sizeof(CD_REQ_ITEM_USE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(ItemId);
       }

       {
           thisSize += sizeof(ItemQuantity);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_ITEM_USE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}itemId: {}", tTabStr, t->Get_itemId());
       result += std::format(L"\n{}itemQuantity: {}", tTabStr, t->Get_itemQuantity());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_GAME_CREATE;

class CD_REQ_GAME_CREATE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_GAME_CREATE;

public:
   // (1)
   explicit CD_REQ_GAME_CREATE_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_CREATE, buf)
   {
   }

   // (2)
   explicit CD_REQ_GAME_CREATE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_CREATE, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_GAME_CREATE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_CREATE, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_GAME_CREATE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       ItemId itemId
   )
   {
       WriteValue(itemId);


   }

   CD_REQ_GAME_CREATE& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_GAME_CREATE*>(GetPacketBufPtr()); }
   CD_REQ_GAME_CREATE* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_GAME_CREATE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_GAME_CREATE : public NetworkPacket
{
   public:
      using Writer = CD_REQ_GAME_CREATE_WRITER;


private:
   ItemId m_itemId;

public:
   CD_REQ_GAME_CREATE()
   {
       memset(this, 0, sizeof(CD_REQ_GAME_CREATE));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_GAME_CREATE));
   }
   CD_REQ_GAME_CREATE(const CD_REQ_GAME_CREATE&) = delete;
   CD_REQ_GAME_CREATE(CD_REQ_GAME_CREATE &&) = delete;
   CD_REQ_GAME_CREATE& operator = (const CD_REQ_GAME_CREATE&) = delete;
   CD_REQ_GAME_CREATE& operator = (CD_REQ_GAME_CREATE &&) = delete;

   ItemId Get_itemId() const noexcept { return m_itemId; }
   ItemId& Ref_itemId() noexcept { return m_itemId; }
   const ItemId& ConstRef_itemId() const noexcept { return m_itemId; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_GAME_CREATE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_GAME_CREATE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_GAME_CREATE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_GAME_CREATE))
           {
               size += sizeof(CD_REQ_GAME_CREATE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(ItemId);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_GAME_CREATE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}itemId: {}", tTabStr, t->Get_itemId());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_GAME_USER_ENTER;

class CD_REQ_GAME_USER_ENTER_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_GAME_USER_ENTER;

public:
   // (1)
   explicit CD_REQ_GAME_USER_ENTER_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_USER_ENTER, buf)
   {
   }

   // (2)
   explicit CD_REQ_GAME_USER_ENTER_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_USER_ENTER, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_GAME_USER_ENTER_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_USER_ENTER, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_GAME_USER_ENTER_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       GameId gameId
   )
   {
       WriteValue(gameId);


   }

   CD_REQ_GAME_USER_ENTER& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_GAME_USER_ENTER*>(GetPacketBufPtr()); }
   CD_REQ_GAME_USER_ENTER* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_GAME_USER_ENTER*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_GAME_USER_ENTER : public NetworkPacket
{
   public:
      using Writer = CD_REQ_GAME_USER_ENTER_WRITER;


private:
   GameId m_gameId; // Client가 Db서버에 게임 유저 등록 요청

public:
   CD_REQ_GAME_USER_ENTER()
   {
       memset(this, 0, sizeof(CD_REQ_GAME_USER_ENTER));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_GAME_USER_ENTER));
   }
   CD_REQ_GAME_USER_ENTER(const CD_REQ_GAME_USER_ENTER&) = delete;
   CD_REQ_GAME_USER_ENTER(CD_REQ_GAME_USER_ENTER &&) = delete;
   CD_REQ_GAME_USER_ENTER& operator = (const CD_REQ_GAME_USER_ENTER&) = delete;
   CD_REQ_GAME_USER_ENTER& operator = (CD_REQ_GAME_USER_ENTER &&) = delete;

   GameId Get_gameId() const noexcept { return m_gameId; }
   GameId& Ref_gameId() noexcept { return m_gameId; }
   const GameId& ConstRef_gameId() const noexcept { return m_gameId; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_GAME_USER_ENTER) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_GAME_USER_ENTER) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_GAME_USER_ENTER); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_GAME_USER_ENTER))
           {
               size += sizeof(CD_REQ_GAME_USER_ENTER);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(GameId);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_GAME_USER_ENTER>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}gameId: {}", tTabStr, t->Get_gameId());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_GAME_USER_LEAVE;

class CD_REQ_GAME_USER_LEAVE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_GAME_USER_LEAVE;

public:
   // (1)
   explicit CD_REQ_GAME_USER_LEAVE_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_USER_LEAVE, buf)
   {

   }

   // (2)
   explicit CD_REQ_GAME_USER_LEAVE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_USER_LEAVE, buf)
   {
       SetReadPacket(rp);

   }

   // (3)
   explicit CD_REQ_GAME_USER_LEAVE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_GAME_USER_LEAVE, buf)
   {
       SetWritePacket(wp);

   }

   // (8)
   explicit CD_REQ_GAME_USER_LEAVE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   CD_REQ_GAME_USER_LEAVE& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_GAME_USER_LEAVE*>(GetPacketBufPtr()); }
   CD_REQ_GAME_USER_LEAVE* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_GAME_USER_LEAVE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_GAME_USER_LEAVE : public NetworkPacket
{
   public:
      using Writer = CD_REQ_GAME_USER_LEAVE_WRITER;


private:
public:
   CD_REQ_GAME_USER_LEAVE()
   {
       memset(this, 0, sizeof(CD_REQ_GAME_USER_LEAVE));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_GAME_USER_LEAVE));
   }
   CD_REQ_GAME_USER_LEAVE(const CD_REQ_GAME_USER_LEAVE&) = delete;
   CD_REQ_GAME_USER_LEAVE(CD_REQ_GAME_USER_LEAVE &&) = delete;
   CD_REQ_GAME_USER_LEAVE& operator = (const CD_REQ_GAME_USER_LEAVE&) = delete;
   CD_REQ_GAME_USER_LEAVE& operator = (CD_REQ_GAME_USER_LEAVE &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_GAME_USER_LEAVE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_GAME_USER_LEAVE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_GAME_USER_LEAVE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_GAME_USER_LEAVE))
           {
               size += sizeof(CD_REQ_GAME_USER_LEAVE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_GAME_USER_LEAVE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_MAIL_LIST;

class CD_REQ_MAIL_LIST_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_MAIL_LIST;

public:
   // (1)
   explicit CD_REQ_MAIL_LIST_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_MAIL_LIST, buf)
   {
   }

   // (2)
   explicit CD_REQ_MAIL_LIST_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_MAIL_LIST, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_MAIL_LIST_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_MAIL_LIST, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_MAIL_LIST_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       MailId underMailId,
       MailId overMailId
   )
   {
       WriteValue(underMailId);

       WriteValue(overMailId);


   }

   CD_REQ_MAIL_LIST& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_MAIL_LIST*>(GetPacketBufPtr()); }
   CD_REQ_MAIL_LIST* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_MAIL_LIST*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_MAIL_LIST : public NetworkPacket
{
   public:
      using Writer = CD_REQ_MAIL_LIST_WRITER;


private:
   MailId m_underMailId;

   MailId m_overMailId;

public:
   CD_REQ_MAIL_LIST()
   {
       memset(this, 0, sizeof(CD_REQ_MAIL_LIST));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_MAIL_LIST));
   }
   CD_REQ_MAIL_LIST(const CD_REQ_MAIL_LIST&) = delete;
   CD_REQ_MAIL_LIST(CD_REQ_MAIL_LIST &&) = delete;
   CD_REQ_MAIL_LIST& operator = (const CD_REQ_MAIL_LIST&) = delete;
   CD_REQ_MAIL_LIST& operator = (CD_REQ_MAIL_LIST &&) = delete;

   MailId Get_underMailId() const noexcept { return m_underMailId; }
   MailId& Ref_underMailId() noexcept { return m_underMailId; }
   const MailId& ConstRef_underMailId() const noexcept { return m_underMailId; }

   MailId Get_overMailId() const noexcept { return m_overMailId; }
   MailId& Ref_overMailId() noexcept { return m_overMailId; }
   const MailId& ConstRef_overMailId() const noexcept { return m_overMailId; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_MAIL_LIST) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_MAIL_LIST) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_MAIL_LIST); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_MAIL_LIST))
           {
               size += sizeof(CD_REQ_MAIL_LIST);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(MailId);
       }

       {
           thisSize += sizeof(MailId);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_MAIL_LIST>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}underMailId: {}", tTabStr, t->Get_underMailId());
       result += std::format(L"\n{}overMailId: {}", tTabStr, t->Get_overMailId());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CD_REQ_MAIL_READ;

class CD_REQ_MAIL_READ_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::CD_REQ_MAIL_READ;

public:
   // (1)
   explicit CD_REQ_MAIL_READ_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_MAIL_READ, buf)
   {
   }

   // (2)
   explicit CD_REQ_MAIL_READ_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_MAIL_READ, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit CD_REQ_MAIL_READ_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::CD_REQ_MAIL_READ, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit CD_REQ_MAIL_READ_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const MailId* MailIdList,
       PacketSize MailIdListSize
   )
   {
       PacketSize& MailIdListOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(MailIdListSize);


       MailIdListOffset = GetPacketSize();
       WriteBinary((uint8_t*)MailIdList, sizeof(MailId) * MailIdListSize);

   }

   CD_REQ_MAIL_READ& GetPacket() const noexcept { return *reinterpret_cast<CD_REQ_MAIL_READ*>(GetPacketBufPtr()); }
   CD_REQ_MAIL_READ* GetPacketPtr() const noexcept { return reinterpret_cast<CD_REQ_MAIL_READ*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CD_REQ_MAIL_READ : public NetworkPacket
{
   public:
      using Writer = CD_REQ_MAIL_READ_WRITER;


private:
   PacketSize m_MailIdList_offset = 0;
   PacketSize m_MailIdList_size = 0;

public:
   CD_REQ_MAIL_READ()
   {
       memset(this, 0, sizeof(CD_REQ_MAIL_READ));
       mPacketSize = static_cast<PacketSize>(sizeof(CD_REQ_MAIL_READ));
   }
   CD_REQ_MAIL_READ(const CD_REQ_MAIL_READ&) = delete;
   CD_REQ_MAIL_READ(CD_REQ_MAIL_READ &&) = delete;
   CD_REQ_MAIL_READ& operator = (const CD_REQ_MAIL_READ&) = delete;
   CD_REQ_MAIL_READ& operator = (CD_REQ_MAIL_READ &&) = delete;

   const MailId* Get_MailIdList() const noexcept { return (MailId*)((uint8_t*)this + m_MailIdList_offset); }
   PacketSize Get_MailIdList_size() const noexcept { return m_MailIdList_size; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(CD_REQ_MAIL_READ) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(CD_REQ_MAIL_READ) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(CD_REQ_MAIL_READ); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(CD_REQ_MAIL_READ))
           {
               size += sizeof(CD_REQ_MAIL_READ);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(MailId) * m_MailIdList_size;
           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, CD_REQ_MAIL_READ>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       if (0 == t->Get_MailIdList_size())
       {
           result += std::format(L"\n{}MailIdList: ARRAY[{}]", tTabStr, t->Get_MailIdList_size());
       }
       else
       {
           result += std::format(L"\n{}MailIdList: ARRAY[{}], ", tTabStr, t->Get_MailIdList_size());
           //tTabStr += std::wstring(L"\t");
           for (size_t i = 0; i < t->Get_MailIdList_size(); ++i)
           {
               result += std::format(L"\n{}{}", tTabStr, t->Get_MailIdList()[i]);
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

#pragma pack(pop)

inline bool ValidatePacketCD(const Packet& rp)
{
   static constexpr bool(*ValidatePacketFuncArray[PacketTypes::CD_PACKET_END - PacketTypes::CD_PACKET_START - 1])(const Packet&) =
   {
       &ValidatePacketFunc<CD_REQ_CHEAT>,
       &ValidatePacketFunc<CD_REQ_STATIC_DATA_CHECKSUM>,
       &ValidatePacketFunc<CD_REQ_STATIC_DATA>,
       &ValidatePacketFunc<CD_REQ_USER_DATA>,
       &ValidatePacketFunc<CD_REQ_USER_LEVEL_UP>,
       &ValidatePacketFunc<CD_REQ_ITEM_USE>,
       &ValidatePacketFunc<CD_REQ_GAME_CREATE>,
       &ValidatePacketFunc<CD_REQ_GAME_USER_ENTER>,
       &ValidatePacketFunc<CD_REQ_GAME_USER_LEAVE>,
       &ValidatePacketFunc<CD_REQ_MAIL_LIST>,
       &ValidatePacketFunc<CD_REQ_MAIL_READ>
   };

   if ((PacketTypes::CD_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::CD_PACKET_END <= rp.GetPacketType()))
   {
       return true;
   }

   return ValidatePacketFuncArray[rp.GetPacketType() - PacketTypes::CD_PACKET_START - 1](rp);
}

template <typename _Owner, typename... _Args>
HandleResult DispatchPacketCD(uint64_t socket, _Owner* owner, NetworkPacket& rp, _Args&&... args)
{
   HandleResult handleResult = DispatchPacketCOMMON(socket, owner, rp, std::forward<_Args>(args)...);
   if (handleResult != HandleResult::NOT_EXISTS)
       return handleResult;
   
   static constexpr HandleResult(*DispatchPacketFuncArray[PacketTypes::CD_PACKET_END - PacketTypes::CD_PACKET_START - 1])(uint64_t, _Owner*, NetworkPacket&, _Args&&...) =
   {
       &DispatchPacketFunc<_Owner, CD_REQ_CHEAT, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_STATIC_DATA_CHECKSUM, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_STATIC_DATA, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_USER_DATA, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_USER_LEVEL_UP, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_ITEM_USE, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_GAME_CREATE, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_GAME_USER_ENTER, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_GAME_USER_LEAVE, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_MAIL_LIST, _Args&&...>,
       &DispatchPacketFunc<_Owner, CD_REQ_MAIL_READ, _Args&&...>
   };

   if ((PacketTypes::CD_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::CD_PACKET_END <= rp.GetPacketType()))
   {
       return HandleResult::NOT_EXISTS;
   }

   if (auto func = DispatchPacketFuncArray[rp.GetPacketType() - PacketTypes::CD_PACKET_START - 1])
       return func(socket, owner, rp, std::forward<_Args>(args)...);
   else
       return HandleResult::NOT_EXISTS;
}

