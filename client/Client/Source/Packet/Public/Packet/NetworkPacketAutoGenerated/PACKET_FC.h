// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/NetworkPacket/NetworkPacket.h"
#include "Packet/NetworkPacket/NetworkPacketWriter.h"
#include "Packet/BasePacket/PacketWriter.h"
#include "Packet/PacketDataList/PacketDataList.h"
#include "Packet/PacketFuncs/PacketValidator.h"
#include "Packet/PacketFuncs/PacketDispatcher.h"

#pragma pack(push, 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_ACK_PACKET_LIST;

class FC_ACK_PACKET_LIST_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_ACK_PACKET_LIST;

private:
   PacketSize* m_packetDevDataList_offset = nullptr;
   PacketSize* m_packetDevDataList_count = nullptr;

public:
   // (4)
   explicit FC_ACK_PACKET_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_PACKET_LIST, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_packetDevDataList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (5)
   explicit FC_ACK_PACKET_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_PACKET_LIST, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_packetDevDataList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (6)
   explicit FC_ACK_PACKET_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_PACKET_LIST, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_packetDevDataList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (8)
   explicit FC_ACK_PACKET_LIST_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void Write_packetDevDataList(const PACKET_DEV_DATA& packet)
   {
       *m_packetDevDataList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_packetDevDataList_count);
   }

   void Write_packetDevDataList(PACKET_DEV_DATA&& packet)
   {
       *m_packetDevDataList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_packetDevDataList_count);
   }

   void Write_packetDevDataList(const PACKET_DEV_DATA::Writer& packet)
   {
       *m_packetDevDataList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_packetDevDataList_count);
   }

   void Write_packetDevDataList(PACKET_DEV_DATA::Writer&& packet)
   {
       *m_packetDevDataList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_packetDevDataList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_packetDevDataList_count);
   }

   FC_ACK_PACKET_LIST& GetPacket() const noexcept { return *reinterpret_cast<FC_ACK_PACKET_LIST*>(GetPacketBufPtr()); }
   FC_ACK_PACKET_LIST* GetPacketPtr() const noexcept { return reinterpret_cast<FC_ACK_PACKET_LIST*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_ACK_PACKET_LIST : public NetworkPacket
{
   public:
      using Writer = FC_ACK_PACKET_LIST_WRITER;


private:
   PacketSize m_packetDevDataList_offset = 0;
   PacketSize m_packetDevDataList_count = 0;

public:
   FC_ACK_PACKET_LIST()
   {
       memset(this, 0, sizeof(FC_ACK_PACKET_LIST));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_ACK_PACKET_LIST));
   }
   FC_ACK_PACKET_LIST(const FC_ACK_PACKET_LIST&) = delete;
   FC_ACK_PACKET_LIST(FC_ACK_PACKET_LIST &&) = delete;
   FC_ACK_PACKET_LIST& operator = (const FC_ACK_PACKET_LIST&) = delete;
   FC_ACK_PACKET_LIST& operator = (FC_ACK_PACKET_LIST &&) = delete;

   PacketDataList<FC_ACK_PACKET_LIST, PACKET_DEV_DATA> Get_packetDevDataList() const { return PacketDataList<FC_ACK_PACKET_LIST, PACKET_DEV_DATA>(this, m_packetDevDataList_offset); }
   PacketSize Get_packetDevDataList_count() const { return m_packetDevDataList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_ACK_PACKET_LIST) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_ACK_PACKET_LIST) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_ACK_PACKET_LIST); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_ACK_PACKET_LIST))
           {
               size += sizeof(FC_ACK_PACKET_LIST);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_packetDevDataList_offset)
               return false;

           PacketSize _offset = m_packetDevDataList_offset;
           while (0 != _offset)
           {
               const PACKET_DEV_DATA* _packet = reinterpret_cast<const PACKET_DEV_DATA*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_ACK_PACKET_LIST>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       if (0 == t->Get_packetDevDataList_count())
       {
           result += std::format(L"\n{}packetDevDataList: LIST[{}]", tTabStr, t->Get_packetDevDataList_count());
       }
       else
       {
           result += std::format(L"\n{}packetDevDataList: LIST[{}], ", tTabStr, t->Get_packetDevDataList_count());
           //tTabStr += std::wstring(L"\t");
           for (const PACKET_DEV_DATA* it : t->Get_packetDevDataList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<PACKET_DEV_DATA*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_KICK;

class FC_KICK_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_KICK;

public:
   // (7)
   explicit FC_KICK_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_KICK, buf)
   {
   }

   // (9)
   explicit FC_KICK_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       KickReason reason,
       const wchar_t* comment
   )
       :
       NetworkPacketWriter(trait, PacketTypes::FC_KICK, buf)
   {
       WriteValue(reason);

       PacketSize& commentOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& commentLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       commentOffset = GetPacketSize();
       commentLength = (PacketSize)wcsnlen_s(comment, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == commentLength) WriteString(L"", 0);
       else WriteString(comment, commentLength); 

   }

   // (8)
   explicit FC_KICK_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       KickReason reason,
       const wchar_t* comment
   )
   {
       WriteValue(reason);

       PacketSize& commentOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& commentLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       commentOffset = GetPacketSize();
       commentLength = (PacketSize)wcsnlen_s(comment, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == commentLength) WriteString(L"", 0);
       else WriteString(comment, commentLength); 

   }

   FC_KICK& GetPacket() const noexcept { return *reinterpret_cast<FC_KICK*>(GetPacketBufPtr()); }
   FC_KICK* GetPacketPtr() const noexcept { return reinterpret_cast<FC_KICK*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_KICK : public NetworkPacket
{
   public:
      using Writer = FC_KICK_WRITER;


private:
   KickReason m_reason;

   PacketSize m_comment_offset = 0;
   PacketSize m_comment_length = 0;

public:
   FC_KICK()
   {
       memset(this, 0, sizeof(FC_KICK));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_KICK));
   }
   FC_KICK(const FC_KICK&) = delete;
   FC_KICK(FC_KICK &&) = delete;
   FC_KICK& operator = (const FC_KICK&) = delete;
   FC_KICK& operator = (FC_KICK &&) = delete;

   KickReason Get_reason() const noexcept { return m_reason; }
   KickReason& Ref_reason() noexcept { return m_reason; }
   const KickReason& ConstRef_reason() const noexcept { return m_reason; }

   const wchar_t* Get_comment() const
   {
       if (0 != *((const wchar_t*)((uint8_t*)this + m_comment_offset) + m_comment_length))
           return L"";

       return (const wchar_t*)((uint8_t*)this + m_comment_offset);
   }

   wchar_t* Ref_comment()
   {
       if (0 != *((wchar_t*)((uint8_t*)this + m_comment_offset) + m_comment_length))
           return nullptr;

       return (wchar_t*)((uint8_t*)this + m_comment_offset);
   }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_KICK) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_KICK) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_KICK); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_KICK))
           {
               size += sizeof(FC_KICK);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(KickReason);
       }

       {
           if (GetPacketSize() < m_comment_offset)
               return false;

           if (0 < m_comment_offset)
               thisSize += sizeof(wchar_t) * (size_t(m_comment_length) + 1);

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_KICK>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}reason: {}", tTabStr, t->Get_reason());
       result += std::format(L"\n{}comment: {}", tTabStr, t->Get_comment());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_NOTIFY;

class FC_NOTIFY_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_NOTIFY;

public:
   // (7)
   explicit FC_NOTIFY_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_NOTIFY, buf)
   {
   }

   // (9)
   explicit FC_NOTIFY_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       NotifyReason reason,
       const wchar_t* comment
   )
       :
       NetworkPacketWriter(trait, PacketTypes::FC_NOTIFY, buf)
   {
       WriteValue(reason);

       PacketSize& commentOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& commentLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       commentOffset = GetPacketSize();
       commentLength = (PacketSize)wcsnlen_s(comment, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == commentLength) WriteString(L"", 0);
       else WriteString(comment, commentLength); 

   }

   // (8)
   explicit FC_NOTIFY_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       NotifyReason reason,
       const wchar_t* comment
   )
   {
       WriteValue(reason);

       PacketSize& commentOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& commentLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       commentOffset = GetPacketSize();
       commentLength = (PacketSize)wcsnlen_s(comment, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == commentLength) WriteString(L"", 0);
       else WriteString(comment, commentLength); 

   }

   FC_NOTIFY& GetPacket() const noexcept { return *reinterpret_cast<FC_NOTIFY*>(GetPacketBufPtr()); }
   FC_NOTIFY* GetPacketPtr() const noexcept { return reinterpret_cast<FC_NOTIFY*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_NOTIFY : public NetworkPacket
{
   public:
      using Writer = FC_NOTIFY_WRITER;


private:
   NotifyReason m_reason;

   PacketSize m_comment_offset = 0;
   PacketSize m_comment_length = 0;

public:
   FC_NOTIFY()
   {
       memset(this, 0, sizeof(FC_NOTIFY));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_NOTIFY));
   }
   FC_NOTIFY(const FC_NOTIFY&) = delete;
   FC_NOTIFY(FC_NOTIFY &&) = delete;
   FC_NOTIFY& operator = (const FC_NOTIFY&) = delete;
   FC_NOTIFY& operator = (FC_NOTIFY &&) = delete;

   NotifyReason Get_reason() const noexcept { return m_reason; }
   NotifyReason& Ref_reason() noexcept { return m_reason; }
   const NotifyReason& ConstRef_reason() const noexcept { return m_reason; }

   const wchar_t* Get_comment() const
   {
       if (0 != *((const wchar_t*)((uint8_t*)this + m_comment_offset) + m_comment_length))
           return L"";

       return (const wchar_t*)((uint8_t*)this + m_comment_offset);
   }

   wchar_t* Ref_comment()
   {
       if (0 != *((wchar_t*)((uint8_t*)this + m_comment_offset) + m_comment_length))
           return nullptr;

       return (wchar_t*)((uint8_t*)this + m_comment_offset);
   }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_NOTIFY) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_NOTIFY) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_NOTIFY); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_NOTIFY))
           {
               size += sizeof(FC_NOTIFY);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(NotifyReason);
       }

       {
           if (GetPacketSize() < m_comment_offset)
               return false;

           if (0 < m_comment_offset)
               thisSize += sizeof(wchar_t) * (size_t(m_comment_length) + 1);

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_NOTIFY>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}reason: {}", tTabStr, t->Get_reason());
       result += std::format(L"\n{}comment: {}", tTabStr, t->Get_comment());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_ERROR;

class FC_ERROR_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_ERROR;

public:
   // (7)
   explicit FC_ERROR_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ERROR, buf)
   {
   }

   // (9)
   explicit FC_ERROR_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       PacketType packetType
   )
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ERROR, buf)
   {
       WriteValue(packetType);


   }

   // (8)
   explicit FC_ERROR_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       PacketType packetType
   )
   {
       WriteValue(packetType);


   }

   FC_ERROR& GetPacket() const noexcept { return *reinterpret_cast<FC_ERROR*>(GetPacketBufPtr()); }
   FC_ERROR* GetPacketPtr() const noexcept { return reinterpret_cast<FC_ERROR*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_ERROR : public NetworkPacket
{
   public:
      using Writer = FC_ERROR_WRITER;


private:
   PacketType m_packetType;

public:
   FC_ERROR()
   {
       memset(this, 0, sizeof(FC_ERROR));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_ERROR));
   }
   FC_ERROR(const FC_ERROR&) = delete;
   FC_ERROR(FC_ERROR &&) = delete;
   FC_ERROR& operator = (const FC_ERROR&) = delete;
   FC_ERROR& operator = (FC_ERROR &&) = delete;

   PacketType Get_packetType() const noexcept { return m_packetType; }
   PacketType& Ref_packetType() noexcept { return m_packetType; }
   const PacketType& ConstRef_packetType() const noexcept { return m_packetType; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_ERROR) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_ERROR) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_ERROR); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_ERROR))
           {
               size += sizeof(FC_ERROR);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(PacketType);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_ERROR>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}packetType: {}", tTabStr, t->Get_packetType());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_ACK_USER_LOGIN;

class FC_ACK_USER_LOGIN_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_ACK_USER_LOGIN;

public:
   // (4)
   explicit FC_ACK_USER_LOGIN_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_USER_LOGIN, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit FC_ACK_USER_LOGIN_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_USER_LOGIN, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit FC_ACK_USER_LOGIN_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_USER_LOGIN, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit FC_ACK_USER_LOGIN_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const ACCOUNT_USER& accountUser,
       const USER& user,
       Checksum staticDataChecksum
   )
   {
       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       PacketSize& userOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(staticDataChecksum);


       accountUserOffset = GetPacketSize();
       WriteBinary((uint8_t*)&accountUser, accountUser.GetPacketSize());

       userOffset = GetPacketSize();
       WriteBinary((uint8_t*)&user, user.GetPacketSize());

   }

   void SetValues(
       const ACCOUNT_USER::Writer& accountUser,
       const USER::Writer& user,
       Checksum staticDataChecksum
   )
   {
       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       PacketSize& userOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(staticDataChecksum);


       accountUserOffset = GetPacketSize();
       WriteBinary(accountUser.GetPacketBufPtr(), accountUser.GetPacketSize());

       userOffset = GetPacketSize();
       WriteBinary(user.GetPacketBufPtr(), user.GetPacketSize());

   }

   FC_ACK_USER_LOGIN& GetPacket() const noexcept { return *reinterpret_cast<FC_ACK_USER_LOGIN*>(GetPacketBufPtr()); }
   FC_ACK_USER_LOGIN* GetPacketPtr() const noexcept { return reinterpret_cast<FC_ACK_USER_LOGIN*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_ACK_USER_LOGIN : public NetworkPacket
{
   public:
      using Writer = FC_ACK_USER_LOGIN_WRITER;


private:
   PacketSize m_accountUser_offset = 0;

   PacketSize m_user_offset = 0;

   Checksum m_staticDataChecksum;

public:
   FC_ACK_USER_LOGIN()
   {
       memset(this, 0, sizeof(FC_ACK_USER_LOGIN));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_ACK_USER_LOGIN));
   }
   FC_ACK_USER_LOGIN(const FC_ACK_USER_LOGIN&) = delete;
   FC_ACK_USER_LOGIN(FC_ACK_USER_LOGIN &&) = delete;
   FC_ACK_USER_LOGIN& operator = (const FC_ACK_USER_LOGIN&) = delete;
   FC_ACK_USER_LOGIN& operator = (FC_ACK_USER_LOGIN &&) = delete;

   const ACCOUNT_USER& Get_accountUser() const noexcept { return *(ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }
   ACCOUNT_USER* Get_accountUser_ptr() const noexcept { return (ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }

   const USER& Get_user() const noexcept { return *(USER*)((uint8_t*)this + m_user_offset); }
   USER* Get_user_ptr() const noexcept { return (USER*)((uint8_t*)this + m_user_offset); }

   Checksum Get_staticDataChecksum() const noexcept { return m_staticDataChecksum; }
   Checksum& Ref_staticDataChecksum() noexcept { return m_staticDataChecksum; }
   const Checksum& ConstRef_staticDataChecksum() const noexcept { return m_staticDataChecksum; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_ACK_USER_LOGIN) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_ACK_USER_LOGIN) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_ACK_USER_LOGIN); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_ACK_USER_LOGIN))
           {
               size += sizeof(FC_ACK_USER_LOGIN);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_accountUser_offset)
               return false;

           const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + m_accountUser_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           if (GetPacketSize() < m_user_offset)
               return false;

           const USER* _packet = reinterpret_cast<const USER*>(GetPacketBufPtr() + m_user_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           thisSize += sizeof(Checksum);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_ACK_USER_LOGIN>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}accountUser: {}", tTabStr, t->Get_accountUser_ptr());
       result += std::format(L"\n{}user: {}", tTabStr, t->Get_user_ptr());
       result += std::format(L"\n{}staticDataChecksum: {}", tTabStr, t->Get_staticDataChecksum());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_ACK_GAME_CHANNEL_USER_ENTER;

class FC_ACK_GAME_CHANNEL_USER_ENTER_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_ACK_GAME_CHANNEL_USER_ENTER;

public:
   // (4)
   explicit FC_ACK_GAME_CHANNEL_USER_ENTER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_GAME_CHANNEL_USER_ENTER, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (5)
   explicit FC_ACK_GAME_CHANNEL_USER_ENTER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_GAME_CHANNEL_USER_ENTER, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (6)
   explicit FC_ACK_GAME_CHANNEL_USER_ENTER_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_GAME_CHANNEL_USER_ENTER, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);

   }

   // (8)
   explicit FC_ACK_GAME_CHANNEL_USER_ENTER_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   FC_ACK_GAME_CHANNEL_USER_ENTER& GetPacket() const noexcept { return *reinterpret_cast<FC_ACK_GAME_CHANNEL_USER_ENTER*>(GetPacketBufPtr()); }
   FC_ACK_GAME_CHANNEL_USER_ENTER* GetPacketPtr() const noexcept { return reinterpret_cast<FC_ACK_GAME_CHANNEL_USER_ENTER*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_ACK_GAME_CHANNEL_USER_ENTER : public NetworkPacket
{
   public:
      using Writer = FC_ACK_GAME_CHANNEL_USER_ENTER_WRITER;


private:
public:
   FC_ACK_GAME_CHANNEL_USER_ENTER()
   {
       memset(this, 0, sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER));
   }
   FC_ACK_GAME_CHANNEL_USER_ENTER(const FC_ACK_GAME_CHANNEL_USER_ENTER&) = delete;
   FC_ACK_GAME_CHANNEL_USER_ENTER(FC_ACK_GAME_CHANNEL_USER_ENTER &&) = delete;
   FC_ACK_GAME_CHANNEL_USER_ENTER& operator = (const FC_ACK_GAME_CHANNEL_USER_ENTER&) = delete;
   FC_ACK_GAME_CHANNEL_USER_ENTER& operator = (FC_ACK_GAME_CHANNEL_USER_ENTER &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER))
           {
               size += sizeof(FC_ACK_GAME_CHANNEL_USER_ENTER);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_ACK_GAME_CHANNEL_USER_ENTER>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_GAME_FINISHED;

class FC_GAME_FINISHED_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_GAME_FINISHED;

public:
   // (7)
   explicit FC_GAME_FINISHED_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_GAME_FINISHED, buf)
   {

   }

   // (8)
   explicit FC_GAME_FINISHED_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   FC_GAME_FINISHED& GetPacket() const noexcept { return *reinterpret_cast<FC_GAME_FINISHED*>(GetPacketBufPtr()); }
   FC_GAME_FINISHED* GetPacketPtr() const noexcept { return reinterpret_cast<FC_GAME_FINISHED*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_GAME_FINISHED : public NetworkPacket
{
   public:
      using Writer = FC_GAME_FINISHED_WRITER;


private:
public:
   FC_GAME_FINISHED()
   {
       memset(this, 0, sizeof(FC_GAME_FINISHED));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_GAME_FINISHED));
   }
   FC_GAME_FINISHED(const FC_GAME_FINISHED&) = delete;
   FC_GAME_FINISHED(FC_GAME_FINISHED &&) = delete;
   FC_GAME_FINISHED& operator = (const FC_GAME_FINISHED&) = delete;
   FC_GAME_FINISHED& operator = (FC_GAME_FINISHED &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_GAME_FINISHED) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_GAME_FINISHED) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_GAME_FINISHED); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_GAME_FINISHED))
           {
               size += sizeof(FC_GAME_FINISHED);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_GAME_FINISHED>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_ACK_CHAT;

class FC_ACK_CHAT_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_ACK_CHAT;

public:
   // (4)
   explicit FC_ACK_CHAT_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_CHAT, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit FC_ACK_CHAT_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_CHAT, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit FC_ACK_CHAT_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_ACK_CHAT, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit FC_ACK_CHAT_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       ClockMs nextDelay
   )
   {
       WriteValue(nextDelay);


   }

   FC_ACK_CHAT& GetPacket() const noexcept { return *reinterpret_cast<FC_ACK_CHAT*>(GetPacketBufPtr()); }
   FC_ACK_CHAT* GetPacketPtr() const noexcept { return reinterpret_cast<FC_ACK_CHAT*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_ACK_CHAT : public NetworkPacket
{
   public:
      using Writer = FC_ACK_CHAT_WRITER;


private:
   ClockMs m_nextDelay; // 채팅 응답

public:
   FC_ACK_CHAT()
   {
       memset(this, 0, sizeof(FC_ACK_CHAT));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_ACK_CHAT));
   }
   FC_ACK_CHAT(const FC_ACK_CHAT&) = delete;
   FC_ACK_CHAT(FC_ACK_CHAT &&) = delete;
   FC_ACK_CHAT& operator = (const FC_ACK_CHAT&) = delete;
   FC_ACK_CHAT& operator = (FC_ACK_CHAT &&) = delete;

   ClockMs Get_nextDelay() const noexcept { return m_nextDelay; }
   ClockMs& Ref_nextDelay() noexcept { return m_nextDelay; }
   const ClockMs& ConstRef_nextDelay() const noexcept { return m_nextDelay; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_ACK_CHAT) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_ACK_CHAT) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_ACK_CHAT); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_ACK_CHAT))
           {
               size += sizeof(FC_ACK_CHAT);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(ClockMs);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_ACK_CHAT>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}nextDelay: {}", tTabStr, t->Get_nextDelay());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FC_CHAT;

class FC_CHAT_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FC_CHAT;

public:
   // (7)
   explicit FC_CHAT_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FC_CHAT, buf)
   {
   }

   // (9)
   explicit FC_CHAT_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       ChatType chatType,
       RoomId roomId,
       const wchar_t* userName,
       const wchar_t* guildName,
       const wchar_t* msg
   )
       :
       NetworkPacketWriter(trait, PacketTypes::FC_CHAT, buf)
   {
       WriteValue(chatType);

       WriteValue(roomId);

       PacketSize& userNameOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& userNameLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 

       PacketSize& guildNameOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& guildNameLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 

       PacketSize& msgOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& msgLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       userNameOffset = GetPacketSize();
       userNameLength = (PacketSize)wcsnlen_s(userName, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == userNameLength) WriteString(L"", 0);
       else WriteString(userName, userNameLength); 

       guildNameOffset = GetPacketSize();
       guildNameLength = (PacketSize)wcsnlen_s(guildName, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == guildNameLength) WriteString(L"", 0);
       else WriteString(guildName, guildNameLength); 

       msgOffset = GetPacketSize();
       msgLength = (PacketSize)wcsnlen_s(msg, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == msgLength) WriteString(L"", 0);
       else WriteString(msg, msgLength); 

   }

   // (8)
   explicit FC_CHAT_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       ChatType chatType,
       RoomId roomId,
       const wchar_t* userName,
       const wchar_t* guildName,
       const wchar_t* msg
   )
   {
       WriteValue(chatType);

       WriteValue(roomId);

       PacketSize& userNameOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& userNameLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 

       PacketSize& guildNameOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& guildNameLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 

       PacketSize& msgOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 
       PacketSize& msgLength = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0)); 


       userNameOffset = GetPacketSize();
       userNameLength = (PacketSize)wcsnlen_s(userName, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == userNameLength) WriteString(L"", 0);
       else WriteString(userName, userNameLength); 

       guildNameOffset = GetPacketSize();
       guildNameLength = (PacketSize)wcsnlen_s(guildName, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == guildNameLength) WriteString(L"", 0);
       else WriteString(guildName, guildNameLength); 

       msgOffset = GetPacketSize();
       msgLength = (PacketSize)wcsnlen_s(msg, MAX_STRING_LENGTH);
       if (MAX_STRING_LENGTH == msgLength) WriteString(L"", 0);
       else WriteString(msg, msgLength); 

   }

   FC_CHAT& GetPacket() const noexcept { return *reinterpret_cast<FC_CHAT*>(GetPacketBufPtr()); }
   FC_CHAT* GetPacketPtr() const noexcept { return reinterpret_cast<FC_CHAT*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FC_CHAT : public NetworkPacket
{
   public:
      using Writer = FC_CHAT_WRITER;


private:
   ChatType m_chatType; // 채팅 전파

   RoomId m_roomId;

   PacketSize m_userName_offset = 0;
   PacketSize m_userName_length = 0;

   PacketSize m_guildName_offset = 0;
   PacketSize m_guildName_length = 0;

   PacketSize m_msg_offset = 0;
   PacketSize m_msg_length = 0;

public:
   FC_CHAT()
   {
       memset(this, 0, sizeof(FC_CHAT));
       mPacketSize = static_cast<PacketSize>(sizeof(FC_CHAT));
   }
   FC_CHAT(const FC_CHAT&) = delete;
   FC_CHAT(FC_CHAT &&) = delete;
   FC_CHAT& operator = (const FC_CHAT&) = delete;
   FC_CHAT& operator = (FC_CHAT &&) = delete;

   ChatType Get_chatType() const noexcept { return m_chatType; }
   ChatType& Ref_chatType() noexcept { return m_chatType; }
   const ChatType& ConstRef_chatType() const noexcept { return m_chatType; }

   RoomId Get_roomId() const noexcept { return m_roomId; }
   RoomId& Ref_roomId() noexcept { return m_roomId; }
   const RoomId& ConstRef_roomId() const noexcept { return m_roomId; }

   const wchar_t* Get_userName() const
   {
       if (0 != *((const wchar_t*)((uint8_t*)this + m_userName_offset) + m_userName_length))
           return L"";

       return (const wchar_t*)((uint8_t*)this + m_userName_offset);
   }

   wchar_t* Ref_userName()
   {
       if (0 != *((wchar_t*)((uint8_t*)this + m_userName_offset) + m_userName_length))
           return nullptr;

       return (wchar_t*)((uint8_t*)this + m_userName_offset);
   }

   const wchar_t* Get_guildName() const
   {
       if (0 != *((const wchar_t*)((uint8_t*)this + m_guildName_offset) + m_guildName_length))
           return L"";

       return (const wchar_t*)((uint8_t*)this + m_guildName_offset);
   }

   wchar_t* Ref_guildName()
   {
       if (0 != *((wchar_t*)((uint8_t*)this + m_guildName_offset) + m_guildName_length))
           return nullptr;

       return (wchar_t*)((uint8_t*)this + m_guildName_offset);
   }

   const wchar_t* Get_msg() const
   {
       if (0 != *((const wchar_t*)((uint8_t*)this + m_msg_offset) + m_msg_length))
           return L"";

       return (const wchar_t*)((uint8_t*)this + m_msg_offset);
   }

   wchar_t* Ref_msg()
   {
       if (0 != *((wchar_t*)((uint8_t*)this + m_msg_offset) + m_msg_length))
           return nullptr;

       return (wchar_t*)((uint8_t*)this + m_msg_offset);
   }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FC_CHAT) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FC_CHAT) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FC_CHAT); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FC_CHAT))
           {
               size += sizeof(FC_CHAT);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(ChatType);
       }

       {
           thisSize += sizeof(RoomId);
       }

       {
           if (GetPacketSize() < m_userName_offset)
               return false;

           if (0 < m_userName_offset)
               thisSize += sizeof(wchar_t) * (size_t(m_userName_length) + 1);

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           if (GetPacketSize() < m_guildName_offset)
               return false;

           if (0 < m_guildName_offset)
               thisSize += sizeof(wchar_t) * (size_t(m_guildName_length) + 1);

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           if (GetPacketSize() < m_msg_offset)
               return false;

           if (0 < m_msg_offset)
               thisSize += sizeof(wchar_t) * (size_t(m_msg_length) + 1);

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FC_CHAT>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}chatType: {}", tTabStr, t->Get_chatType());
       result += std::format(L"\n{}roomId: {}", tTabStr, t->Get_roomId());
       result += std::format(L"\n{}userName: {}", tTabStr, t->Get_userName());
       result += std::format(L"\n{}guildName: {}", tTabStr, t->Get_guildName());
       result += std::format(L"\n{}msg: {}", tTabStr, t->Get_msg());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

#pragma pack(pop)

inline bool ValidatePacketFC(const Packet& rp)
{
   static constexpr bool(*ValidatePacketFuncArray[PacketTypes::FC_PACKET_END - PacketTypes::FC_PACKET_START - 1])(const Packet&) =
   {
       &ValidatePacketFunc<FC_ACK_PACKET_LIST>,
       &ValidatePacketFunc<FC_KICK>,
       &ValidatePacketFunc<FC_NOTIFY>,
       &ValidatePacketFunc<FC_ERROR>,
       &ValidatePacketFunc<FC_ACK_USER_LOGIN>,
       &ValidatePacketFunc<FC_ACK_GAME_CHANNEL_USER_ENTER>,
       &ValidatePacketFunc<FC_GAME_FINISHED>,
       &ValidatePacketFunc<FC_ACK_CHAT>,
       &ValidatePacketFunc<FC_CHAT>
   };

   if ((PacketTypes::FC_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::FC_PACKET_END <= rp.GetPacketType()))
   {
       return true;
   }

   return ValidatePacketFuncArray[rp.GetPacketType() - PacketTypes::FC_PACKET_START - 1](rp);
}

template <typename _Owner, typename... _Args>
HandleResult DispatchPacketFC(uint64_t socket, _Owner* owner, NetworkPacket& rp, _Args&&... args)
{
   HandleResult handleResult = DispatchPacketCOMMON(socket, owner, rp, std::forward<_Args>(args)...);
   if (handleResult != HandleResult::NOT_EXISTS)
       return handleResult;
   
   static constexpr HandleResult(*DispatchPacketFuncArray[PacketTypes::FC_PACKET_END - PacketTypes::FC_PACKET_START - 1])(uint64_t, _Owner*, NetworkPacket&, _Args&&...) =
   {
       &DispatchPacketFunc<_Owner, FC_ACK_PACKET_LIST, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_KICK, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_NOTIFY, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_ERROR, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_ACK_USER_LOGIN, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_ACK_GAME_CHANNEL_USER_ENTER, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_GAME_FINISHED, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_ACK_CHAT, _Args&&...>,
       &DispatchPacketFunc<_Owner, FC_CHAT, _Args&&...>
   };

   if ((PacketTypes::FC_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::FC_PACKET_END <= rp.GetPacketType()))
   {
       return HandleResult::NOT_EXISTS;
   }

   if (auto func = DispatchPacketFuncArray[rp.GetPacketType() - PacketTypes::FC_PACKET_START - 1])
       return func(socket, owner, rp, std::forward<_Args>(args)...);
   else
       return HandleResult::NOT_EXISTS;
}

