// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/NetworkPacket/NetworkPacket.h"
#include "Packet/NetworkPacket/NetworkPacketWriter.h"
#include "Packet/BasePacket/PacketWriter.h"
#include "Packet/PacketDataList/PacketDataList.h"
#include "Packet/PacketFuncs/PacketValidator.h"
#include "Packet/PacketFuncs/PacketDispatcher.h"

#pragma pack(push, 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ERROR;

class MC_ERROR_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ERROR;

public:
   // (7)
   explicit MC_ERROR_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ERROR, buf)
   {
   }

   // (9)
   explicit MC_ERROR_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       PacketType packetType
   )
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ERROR, buf)
   {
       WriteValue(packetType);


   }

   // (8)
   explicit MC_ERROR_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       PacketType packetType
   )
   {
       WriteValue(packetType);


   }

   MC_ERROR& GetPacket() const noexcept { return *reinterpret_cast<MC_ERROR*>(GetPacketBufPtr()); }
   MC_ERROR* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ERROR*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ERROR : public NetworkPacket
{
   public:
      using Writer = MC_ERROR_WRITER;


private:
   PacketType m_packetType;

public:
   MC_ERROR()
   {
       memset(this, 0, sizeof(MC_ERROR));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ERROR));
   }
   MC_ERROR(const MC_ERROR&) = delete;
   MC_ERROR(MC_ERROR &&) = delete;
   MC_ERROR& operator = (const MC_ERROR&) = delete;
   MC_ERROR& operator = (MC_ERROR &&) = delete;

   PacketType Get_packetType() const noexcept { return m_packetType; }
   PacketType& Ref_packetType() noexcept { return m_packetType; }
   const PacketType& ConstRef_packetType() const noexcept { return m_packetType; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ERROR) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ERROR) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ERROR); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ERROR))
           {
               size += sizeof(MC_ERROR);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(PacketType);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ERROR>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}packetType: {}", tTabStr, t->Get_packetType());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_SERVER_LIST;

class MC_ACK_SERVER_LIST_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_SERVER_LIST;

private:
   PacketSize* m_serverList_offset = nullptr;
   PacketSize* m_serverList_count = nullptr;

public:
   // (4)
   explicit MC_ACK_SERVER_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_SERVER_LIST, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_serverList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (5)
   explicit MC_ACK_SERVER_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_SERVER_LIST, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_serverList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (6)
   explicit MC_ACK_SERVER_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_SERVER_LIST, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_serverList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (8)
   explicit MC_ACK_SERVER_LIST_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void Write_serverList(const SERVER& packet)
   {
       *m_serverList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_serverList_count);
   }

   void Write_serverList(SERVER&& packet)
   {
       *m_serverList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_serverList_count);
   }

   void Write_serverList(const SERVER::Writer& packet)
   {
       *m_serverList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_serverList_count);
   }

   void Write_serverList(SERVER::Writer&& packet)
   {
       *m_serverList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_serverList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_serverList_count);
   }

   MC_ACK_SERVER_LIST& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_SERVER_LIST*>(GetPacketBufPtr()); }
   MC_ACK_SERVER_LIST* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_SERVER_LIST*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_SERVER_LIST : public NetworkPacket
{
   public:
      using Writer = MC_ACK_SERVER_LIST_WRITER;


private:
   PacketSize m_serverList_offset = 0;
   PacketSize m_serverList_count = 0;

public:
   MC_ACK_SERVER_LIST()
   {
       memset(this, 0, sizeof(MC_ACK_SERVER_LIST));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_SERVER_LIST));
   }
   MC_ACK_SERVER_LIST(const MC_ACK_SERVER_LIST&) = delete;
   MC_ACK_SERVER_LIST(MC_ACK_SERVER_LIST &&) = delete;
   MC_ACK_SERVER_LIST& operator = (const MC_ACK_SERVER_LIST&) = delete;
   MC_ACK_SERVER_LIST& operator = (MC_ACK_SERVER_LIST &&) = delete;

   PacketDataList<MC_ACK_SERVER_LIST, SERVER> Get_serverList() const { return PacketDataList<MC_ACK_SERVER_LIST, SERVER>(this, m_serverList_offset); }
   PacketSize Get_serverList_count() const { return m_serverList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_SERVER_LIST) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_SERVER_LIST) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_SERVER_LIST); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_SERVER_LIST))
           {
               size += sizeof(MC_ACK_SERVER_LIST);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_serverList_offset)
               return false;

           PacketSize _offset = m_serverList_offset;
           while (0 != _offset)
           {
               const SERVER* _packet = reinterpret_cast<const SERVER*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_SERVER_LIST>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       if (0 == t->Get_serverList_count())
       {
           result += std::format(L"\n{}serverList: LIST[{}]", tTabStr, t->Get_serverList_count());
       }
       else
       {
           result += std::format(L"\n{}serverList: LIST[{}], ", tTabStr, t->Get_serverList_count());
           //tTabStr += std::wstring(L"\t");
           for (const SERVER* it : t->Get_serverList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<SERVER*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_ACCOUNT_USER_LIST;

class MC_ACK_ACCOUNT_USER_LIST_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_ACCOUNT_USER_LIST;

private:
   PacketSize* m_accountUserList_offset = nullptr;
   PacketSize* m_accountUserList_count = nullptr;

public:
   // (4)
   explicit MC_ACK_ACCOUNT_USER_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_LIST, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit MC_ACK_ACCOUNT_USER_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_LIST, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit MC_ACK_ACCOUNT_USER_LIST_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_LIST, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit MC_ACK_ACCOUNT_USER_LIST_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const ACCOUNT& account
   )
   {
       PacketSize& accountOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


       accountOffset = GetPacketSize();
       WriteBinary((uint8_t*)&account, account.GetPacketSize());

   }

   void SetValues(
       const ACCOUNT::Writer& account
   )
   {
       PacketSize& accountOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


       accountOffset = GetPacketSize();
       WriteBinary(account.GetPacketBufPtr(), account.GetPacketSize());

   }

   void Write_accountUserList(const ACCOUNT_USER& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(ACCOUNT_USER&& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(const ACCOUNT_USER::Writer& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(ACCOUNT_USER::Writer&& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   MC_ACK_ACCOUNT_USER_LIST& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_ACCOUNT_USER_LIST*>(GetPacketBufPtr()); }
   MC_ACK_ACCOUNT_USER_LIST* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_ACCOUNT_USER_LIST*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_ACCOUNT_USER_LIST : public NetworkPacket
{
   public:
      using Writer = MC_ACK_ACCOUNT_USER_LIST_WRITER;


private:
   PacketSize m_account_offset = 0;

   PacketSize m_accountUserList_offset = 0;
   PacketSize m_accountUserList_count = 0;

public:
   MC_ACK_ACCOUNT_USER_LIST()
   {
       memset(this, 0, sizeof(MC_ACK_ACCOUNT_USER_LIST));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_ACCOUNT_USER_LIST));
   }
   MC_ACK_ACCOUNT_USER_LIST(const MC_ACK_ACCOUNT_USER_LIST&) = delete;
   MC_ACK_ACCOUNT_USER_LIST(MC_ACK_ACCOUNT_USER_LIST &&) = delete;
   MC_ACK_ACCOUNT_USER_LIST& operator = (const MC_ACK_ACCOUNT_USER_LIST&) = delete;
   MC_ACK_ACCOUNT_USER_LIST& operator = (MC_ACK_ACCOUNT_USER_LIST &&) = delete;

   const ACCOUNT& Get_account() const noexcept { return *(ACCOUNT*)((uint8_t*)this + m_account_offset); }
   ACCOUNT* Get_account_ptr() const noexcept { return (ACCOUNT*)((uint8_t*)this + m_account_offset); }

   PacketDataList<MC_ACK_ACCOUNT_USER_LIST, ACCOUNT_USER> Get_accountUserList() const { return PacketDataList<MC_ACK_ACCOUNT_USER_LIST, ACCOUNT_USER>(this, m_accountUserList_offset); }
   PacketSize Get_accountUserList_count() const { return m_accountUserList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_ACCOUNT_USER_LIST) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_ACCOUNT_USER_LIST) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_ACCOUNT_USER_LIST); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_ACCOUNT_USER_LIST))
           {
               size += sizeof(MC_ACK_ACCOUNT_USER_LIST);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_account_offset)
               return false;

           const ACCOUNT* _packet = reinterpret_cast<const ACCOUNT*>(GetPacketBufPtr() + m_account_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           if (GetPacketSize() < m_accountUserList_offset)
               return false;

           PacketSize _offset = m_accountUserList_offset;
           while (0 != _offset)
           {
               const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_ACCOUNT_USER_LIST>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}account: {}", tTabStr, t->Get_account_ptr());
       if (0 == t->Get_accountUserList_count())
       {
           result += std::format(L"\n{}accountUserList: LIST[{}]", tTabStr, t->Get_accountUserList_count());
       }
       else
       {
           result += std::format(L"\n{}accountUserList: LIST[{}], ", tTabStr, t->Get_accountUserList_count());
           //tTabStr += std::wstring(L"\t");
           for (const ACCOUNT_USER* it : t->Get_accountUserList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<ACCOUNT_USER*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_ACCOUNT_USER_CREATE;

class MC_ACK_ACCOUNT_USER_CREATE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_ACCOUNT_USER_CREATE;

private:
   PacketSize* m_accountUserList_offset = nullptr;
   PacketSize* m_accountUserList_count = nullptr;

public:
   // (4)
   explicit MC_ACK_ACCOUNT_USER_CREATE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_CREATE, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (5)
   explicit MC_ACK_ACCOUNT_USER_CREATE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_CREATE, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (6)
   explicit MC_ACK_ACCOUNT_USER_CREATE_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_CREATE, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (8)
   explicit MC_ACK_ACCOUNT_USER_CREATE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void Write_accountUserList(const ACCOUNT_USER& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(ACCOUNT_USER&& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(const ACCOUNT_USER::Writer& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(ACCOUNT_USER::Writer&& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   MC_ACK_ACCOUNT_USER_CREATE& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_ACCOUNT_USER_CREATE*>(GetPacketBufPtr()); }
   MC_ACK_ACCOUNT_USER_CREATE* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_ACCOUNT_USER_CREATE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_ACCOUNT_USER_CREATE : public NetworkPacket
{
   public:
      using Writer = MC_ACK_ACCOUNT_USER_CREATE_WRITER;


private:
   PacketSize m_accountUserList_offset = 0;
   PacketSize m_accountUserList_count = 0;

public:
   MC_ACK_ACCOUNT_USER_CREATE()
   {
       memset(this, 0, sizeof(MC_ACK_ACCOUNT_USER_CREATE));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_ACCOUNT_USER_CREATE));
   }
   MC_ACK_ACCOUNT_USER_CREATE(const MC_ACK_ACCOUNT_USER_CREATE&) = delete;
   MC_ACK_ACCOUNT_USER_CREATE(MC_ACK_ACCOUNT_USER_CREATE &&) = delete;
   MC_ACK_ACCOUNT_USER_CREATE& operator = (const MC_ACK_ACCOUNT_USER_CREATE&) = delete;
   MC_ACK_ACCOUNT_USER_CREATE& operator = (MC_ACK_ACCOUNT_USER_CREATE &&) = delete;

   PacketDataList<MC_ACK_ACCOUNT_USER_CREATE, ACCOUNT_USER> Get_accountUserList() const { return PacketDataList<MC_ACK_ACCOUNT_USER_CREATE, ACCOUNT_USER>(this, m_accountUserList_offset); }
   PacketSize Get_accountUserList_count() const { return m_accountUserList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_ACCOUNT_USER_CREATE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_ACCOUNT_USER_CREATE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_ACCOUNT_USER_CREATE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_ACCOUNT_USER_CREATE))
           {
               size += sizeof(MC_ACK_ACCOUNT_USER_CREATE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_accountUserList_offset)
               return false;

           PacketSize _offset = m_accountUserList_offset;
           while (0 != _offset)
           {
               const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_ACCOUNT_USER_CREATE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       if (0 == t->Get_accountUserList_count())
       {
           result += std::format(L"\n{}accountUserList: LIST[{}]", tTabStr, t->Get_accountUserList_count());
       }
       else
       {
           result += std::format(L"\n{}accountUserList: LIST[{}], ", tTabStr, t->Get_accountUserList_count());
           //tTabStr += std::wstring(L"\t");
           for (const ACCOUNT_USER* it : t->Get_accountUserList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<ACCOUNT_USER*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_ACCOUNT_USER_DELETE;

class MC_ACK_ACCOUNT_USER_DELETE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_ACCOUNT_USER_DELETE;

private:
   PacketSize* m_accountUserList_offset = nullptr;
   PacketSize* m_accountUserList_count = nullptr;

public:
   // (4)
   explicit MC_ACK_ACCOUNT_USER_DELETE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_DELETE, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (5)
   explicit MC_ACK_ACCOUNT_USER_DELETE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_DELETE, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (6)
   explicit MC_ACK_ACCOUNT_USER_DELETE_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_ACCOUNT_USER_DELETE, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_accountUserList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (8)
   explicit MC_ACK_ACCOUNT_USER_DELETE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void Write_accountUserList(const ACCOUNT_USER& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(ACCOUNT_USER&& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(const ACCOUNT_USER::Writer& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   void Write_accountUserList(ACCOUNT_USER::Writer&& packet)
   {
       *m_accountUserList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_accountUserList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_accountUserList_count);
   }

   MC_ACK_ACCOUNT_USER_DELETE& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_ACCOUNT_USER_DELETE*>(GetPacketBufPtr()); }
   MC_ACK_ACCOUNT_USER_DELETE* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_ACCOUNT_USER_DELETE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_ACCOUNT_USER_DELETE : public NetworkPacket
{
   public:
      using Writer = MC_ACK_ACCOUNT_USER_DELETE_WRITER;


private:
   PacketSize m_accountUserList_offset = 0;
   PacketSize m_accountUserList_count = 0;

public:
   MC_ACK_ACCOUNT_USER_DELETE()
   {
       memset(this, 0, sizeof(MC_ACK_ACCOUNT_USER_DELETE));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_ACCOUNT_USER_DELETE));
   }
   MC_ACK_ACCOUNT_USER_DELETE(const MC_ACK_ACCOUNT_USER_DELETE&) = delete;
   MC_ACK_ACCOUNT_USER_DELETE(MC_ACK_ACCOUNT_USER_DELETE &&) = delete;
   MC_ACK_ACCOUNT_USER_DELETE& operator = (const MC_ACK_ACCOUNT_USER_DELETE&) = delete;
   MC_ACK_ACCOUNT_USER_DELETE& operator = (MC_ACK_ACCOUNT_USER_DELETE &&) = delete;

   PacketDataList<MC_ACK_ACCOUNT_USER_DELETE, ACCOUNT_USER> Get_accountUserList() const { return PacketDataList<MC_ACK_ACCOUNT_USER_DELETE, ACCOUNT_USER>(this, m_accountUserList_offset); }
   PacketSize Get_accountUserList_count() const { return m_accountUserList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_ACCOUNT_USER_DELETE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_ACCOUNT_USER_DELETE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_ACCOUNT_USER_DELETE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_ACCOUNT_USER_DELETE))
           {
               size += sizeof(MC_ACK_ACCOUNT_USER_DELETE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_accountUserList_offset)
               return false;

           PacketSize _offset = m_accountUserList_offset;
           while (0 != _offset)
           {
               const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_ACCOUNT_USER_DELETE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       if (0 == t->Get_accountUserList_count())
       {
           result += std::format(L"\n{}accountUserList: LIST[{}]", tTabStr, t->Get_accountUserList_count());
       }
       else
       {
           result += std::format(L"\n{}accountUserList: LIST[{}], ", tTabStr, t->Get_accountUserList_count());
           //tTabStr += std::wstring(L"\t");
           for (const ACCOUNT_USER* it : t->Get_accountUserList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<ACCOUNT_USER*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_AUTH_TICKET;

class MC_ACK_AUTH_TICKET_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_AUTH_TICKET;

public:
   // (4)
   explicit MC_ACK_AUTH_TICKET_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_AUTH_TICKET, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit MC_ACK_AUTH_TICKET_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_AUTH_TICKET, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit MC_ACK_AUTH_TICKET_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_AUTH_TICKET, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit MC_ACK_AUTH_TICKET_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       AuthTicket authTicket,
       const ACCOUNT_USER& accountUser
   )
   {
       WriteValue(authTicket);

       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountUserOffset = GetPacketSize();
       WriteBinary((uint8_t*)&accountUser, accountUser.GetPacketSize());

   }

   void SetValues(
       AuthTicket authTicket,
       const ACCOUNT_USER::Writer& accountUser
   )
   {
       WriteValue(authTicket);

       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountUserOffset = GetPacketSize();
       WriteBinary(accountUser.GetPacketBufPtr(), accountUser.GetPacketSize());

   }

   MC_ACK_AUTH_TICKET& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_AUTH_TICKET*>(GetPacketBufPtr()); }
   MC_ACK_AUTH_TICKET* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_AUTH_TICKET*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_AUTH_TICKET : public NetworkPacket
{
   public:
      using Writer = MC_ACK_AUTH_TICKET_WRITER;


private:
   AuthTicket m_authTicket;

   PacketSize m_accountUser_offset = 0;

public:
   MC_ACK_AUTH_TICKET()
   {
       memset(this, 0, sizeof(MC_ACK_AUTH_TICKET));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_AUTH_TICKET));
   }
   MC_ACK_AUTH_TICKET(const MC_ACK_AUTH_TICKET&) = delete;
   MC_ACK_AUTH_TICKET(MC_ACK_AUTH_TICKET &&) = delete;
   MC_ACK_AUTH_TICKET& operator = (const MC_ACK_AUTH_TICKET&) = delete;
   MC_ACK_AUTH_TICKET& operator = (MC_ACK_AUTH_TICKET &&) = delete;

   AuthTicket Get_authTicket() const noexcept { return m_authTicket; }
   AuthTicket& Ref_authTicket() noexcept { return m_authTicket; }
   const AuthTicket& ConstRef_authTicket() const noexcept { return m_authTicket; }

   const ACCOUNT_USER& Get_accountUser() const noexcept { return *(ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }
   ACCOUNT_USER* Get_accountUser_ptr() const noexcept { return (ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_AUTH_TICKET) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_AUTH_TICKET) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_AUTH_TICKET); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_AUTH_TICKET))
           {
               size += sizeof(MC_ACK_AUTH_TICKET);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(AuthTicket);
       }

       {
           if (GetPacketSize() < m_accountUser_offset)
               return false;

           const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + m_accountUser_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_AUTH_TICKET>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}authTicket: {}", tTabStr, t->Get_authTicket());
       result += std::format(L"\n{}accountUser: {}", tTabStr, t->Get_accountUser_ptr());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_AUTH_MODIFY;

class MC_ACK_AUTH_MODIFY_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_AUTH_MODIFY;

public:
   // (4)
   explicit MC_ACK_AUTH_MODIFY_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_AUTH_MODIFY, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit MC_ACK_AUTH_MODIFY_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_AUTH_MODIFY, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit MC_ACK_AUTH_MODIFY_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_AUTH_MODIFY, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit MC_ACK_AUTH_MODIFY_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const ACCOUNT& account
   )
   {
       PacketSize& accountOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountOffset = GetPacketSize();
       WriteBinary((uint8_t*)&account, account.GetPacketSize());

   }

   void SetValues(
       const ACCOUNT::Writer& account
   )
   {
       PacketSize& accountOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountOffset = GetPacketSize();
       WriteBinary(account.GetPacketBufPtr(), account.GetPacketSize());

   }

   MC_ACK_AUTH_MODIFY& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_AUTH_MODIFY*>(GetPacketBufPtr()); }
   MC_ACK_AUTH_MODIFY* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_AUTH_MODIFY*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_AUTH_MODIFY : public NetworkPacket
{
   public:
      using Writer = MC_ACK_AUTH_MODIFY_WRITER;


private:
   PacketSize m_account_offset = 0;

public:
   MC_ACK_AUTH_MODIFY()
   {
       memset(this, 0, sizeof(MC_ACK_AUTH_MODIFY));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_AUTH_MODIFY));
   }
   MC_ACK_AUTH_MODIFY(const MC_ACK_AUTH_MODIFY&) = delete;
   MC_ACK_AUTH_MODIFY(MC_ACK_AUTH_MODIFY &&) = delete;
   MC_ACK_AUTH_MODIFY& operator = (const MC_ACK_AUTH_MODIFY&) = delete;
   MC_ACK_AUTH_MODIFY& operator = (MC_ACK_AUTH_MODIFY &&) = delete;

   const ACCOUNT& Get_account() const noexcept { return *(ACCOUNT*)((uint8_t*)this + m_account_offset); }
   ACCOUNT* Get_account_ptr() const noexcept { return (ACCOUNT*)((uint8_t*)this + m_account_offset); }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_AUTH_MODIFY) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_AUTH_MODIFY) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_AUTH_MODIFY); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_AUTH_MODIFY))
           {
               size += sizeof(MC_ACK_AUTH_MODIFY);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_account_offset)
               return false;

           const ACCOUNT* _packet = reinterpret_cast<const ACCOUNT*>(GetPacketBufPtr() + m_account_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_AUTH_MODIFY>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}account: {}", tTabStr, t->Get_account_ptr());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_GAME_LIST_OVER;

class MC_ACK_GAME_LIST_OVER_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_GAME_LIST_OVER;

private:
   PacketSize* m_gameList_offset = nullptr;
   PacketSize* m_gameList_count = nullptr;

public:
   // (4)
   explicit MC_ACK_GAME_LIST_OVER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_GAME_LIST_OVER, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit MC_ACK_GAME_LIST_OVER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_GAME_LIST_OVER, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit MC_ACK_GAME_LIST_OVER_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_GAME_LIST_OVER, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit MC_ACK_GAME_LIST_OVER_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       int64_t totalCount
   )
   {
       WriteValue(totalCount);

       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_gameList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   void Write_gameList(const GAME& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   void Write_gameList(GAME&& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   void Write_gameList(const GAME::Writer& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   void Write_gameList(GAME::Writer&& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   MC_ACK_GAME_LIST_OVER& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_GAME_LIST_OVER*>(GetPacketBufPtr()); }
   MC_ACK_GAME_LIST_OVER* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_GAME_LIST_OVER*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_GAME_LIST_OVER : public NetworkPacket
{
   public:
      using Writer = MC_ACK_GAME_LIST_OVER_WRITER;


private:
   int64_t m_totalCount;

   PacketSize m_gameList_offset = 0;
   PacketSize m_gameList_count = 0;

public:
   MC_ACK_GAME_LIST_OVER()
   {
       memset(this, 0, sizeof(MC_ACK_GAME_LIST_OVER));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_GAME_LIST_OVER));
   }
   MC_ACK_GAME_LIST_OVER(const MC_ACK_GAME_LIST_OVER&) = delete;
   MC_ACK_GAME_LIST_OVER(MC_ACK_GAME_LIST_OVER &&) = delete;
   MC_ACK_GAME_LIST_OVER& operator = (const MC_ACK_GAME_LIST_OVER&) = delete;
   MC_ACK_GAME_LIST_OVER& operator = (MC_ACK_GAME_LIST_OVER &&) = delete;

   int64_t Get_totalCount() const noexcept { return m_totalCount; }
   int64_t& Ref_totalCount() noexcept { return m_totalCount; }
   const int64_t& ConstRef_totalCount() const noexcept { return m_totalCount; }

   PacketDataList<MC_ACK_GAME_LIST_OVER, GAME> Get_gameList() const { return PacketDataList<MC_ACK_GAME_LIST_OVER, GAME>(this, m_gameList_offset); }
   PacketSize Get_gameList_count() const { return m_gameList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_GAME_LIST_OVER) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_GAME_LIST_OVER) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_GAME_LIST_OVER); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_GAME_LIST_OVER))
           {
               size += sizeof(MC_ACK_GAME_LIST_OVER);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(int64_t);
       }

       {
           if (GetPacketSize() < m_gameList_offset)
               return false;

           PacketSize _offset = m_gameList_offset;
           while (0 != _offset)
           {
               const GAME* _packet = reinterpret_cast<const GAME*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_GAME_LIST_OVER>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}totalCount: {}", tTabStr, t->Get_totalCount());
       if (0 == t->Get_gameList_count())
       {
           result += std::format(L"\n{}gameList: LIST[{}]", tTabStr, t->Get_gameList_count());
       }
       else
       {
           result += std::format(L"\n{}gameList: LIST[{}], ", tTabStr, t->Get_gameList_count());
           //tTabStr += std::wstring(L"\t");
           for (const GAME* it : t->Get_gameList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<GAME*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MC_ACK_GAME_LIST_UNDER;

class MC_ACK_GAME_LIST_UNDER_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MC_ACK_GAME_LIST_UNDER;

private:
   PacketSize* m_gameList_offset = nullptr;
   PacketSize* m_gameList_count = nullptr;

public:
   // (4)
   explicit MC_ACK_GAME_LIST_UNDER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_GAME_LIST_UNDER, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit MC_ACK_GAME_LIST_UNDER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_GAME_LIST_UNDER, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit MC_ACK_GAME_LIST_UNDER_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MC_ACK_GAME_LIST_UNDER, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit MC_ACK_GAME_LIST_UNDER_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       int64_t totalCount
   )
   {
       WriteValue(totalCount);

       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_gameList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   void Write_gameList(const GAME& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   void Write_gameList(GAME&& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   void Write_gameList(const GAME::Writer& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   void Write_gameList(GAME::Writer&& packet)
   {
       *m_gameList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_gameList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_gameList_count);
   }

   MC_ACK_GAME_LIST_UNDER& GetPacket() const noexcept { return *reinterpret_cast<MC_ACK_GAME_LIST_UNDER*>(GetPacketBufPtr()); }
   MC_ACK_GAME_LIST_UNDER* GetPacketPtr() const noexcept { return reinterpret_cast<MC_ACK_GAME_LIST_UNDER*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MC_ACK_GAME_LIST_UNDER : public NetworkPacket
{
   public:
      using Writer = MC_ACK_GAME_LIST_UNDER_WRITER;


private:
   int64_t m_totalCount;

   PacketSize m_gameList_offset = 0;
   PacketSize m_gameList_count = 0;

public:
   MC_ACK_GAME_LIST_UNDER()
   {
       memset(this, 0, sizeof(MC_ACK_GAME_LIST_UNDER));
       mPacketSize = static_cast<PacketSize>(sizeof(MC_ACK_GAME_LIST_UNDER));
   }
   MC_ACK_GAME_LIST_UNDER(const MC_ACK_GAME_LIST_UNDER&) = delete;
   MC_ACK_GAME_LIST_UNDER(MC_ACK_GAME_LIST_UNDER &&) = delete;
   MC_ACK_GAME_LIST_UNDER& operator = (const MC_ACK_GAME_LIST_UNDER&) = delete;
   MC_ACK_GAME_LIST_UNDER& operator = (MC_ACK_GAME_LIST_UNDER &&) = delete;

   int64_t Get_totalCount() const noexcept { return m_totalCount; }
   int64_t& Ref_totalCount() noexcept { return m_totalCount; }
   const int64_t& ConstRef_totalCount() const noexcept { return m_totalCount; }

   PacketDataList<MC_ACK_GAME_LIST_UNDER, GAME> Get_gameList() const { return PacketDataList<MC_ACK_GAME_LIST_UNDER, GAME>(this, m_gameList_offset); }
   PacketSize Get_gameList_count() const { return m_gameList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MC_ACK_GAME_LIST_UNDER) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MC_ACK_GAME_LIST_UNDER) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MC_ACK_GAME_LIST_UNDER); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MC_ACK_GAME_LIST_UNDER))
           {
               size += sizeof(MC_ACK_GAME_LIST_UNDER);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(int64_t);
       }

       {
           if (GetPacketSize() < m_gameList_offset)
               return false;

           PacketSize _offset = m_gameList_offset;
           while (0 != _offset)
           {
               const GAME* _packet = reinterpret_cast<const GAME*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MC_ACK_GAME_LIST_UNDER>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}totalCount: {}", tTabStr, t->Get_totalCount());
       if (0 == t->Get_gameList_count())
       {
           result += std::format(L"\n{}gameList: LIST[{}]", tTabStr, t->Get_gameList_count());
       }
       else
       {
           result += std::format(L"\n{}gameList: LIST[{}], ", tTabStr, t->Get_gameList_count());
           //tTabStr += std::wstring(L"\t");
           for (const GAME* it : t->Get_gameList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<GAME*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

#pragma pack(pop)

inline bool ValidatePacketMC(const Packet& rp)
{
   static constexpr bool(*ValidatePacketFuncArray[PacketTypes::MC_PACKET_END - PacketTypes::MC_PACKET_START - 1])(const Packet&) =
   {
       &ValidatePacketFunc<MC_ERROR>,
       &ValidatePacketFunc<MC_ACK_SERVER_LIST>,
       &ValidatePacketFunc<MC_ACK_ACCOUNT_USER_LIST>,
       &ValidatePacketFunc<MC_ACK_ACCOUNT_USER_CREATE>,
       &ValidatePacketFunc<MC_ACK_ACCOUNT_USER_DELETE>,
       &ValidatePacketFunc<MC_ACK_AUTH_TICKET>,
       &ValidatePacketFunc<MC_ACK_AUTH_MODIFY>,
       &ValidatePacketFunc<MC_ACK_GAME_LIST_OVER>,
       &ValidatePacketFunc<MC_ACK_GAME_LIST_UNDER>
   };

   if ((PacketTypes::MC_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::MC_PACKET_END <= rp.GetPacketType()))
   {
       return true;
   }

   return ValidatePacketFuncArray[rp.GetPacketType() - PacketTypes::MC_PACKET_START - 1](rp);
}

template <typename _Owner, typename... _Args>
HandleResult DispatchPacketMC(uint64_t socket, _Owner* owner, NetworkPacket& rp, _Args&&... args)
{
   HandleResult handleResult = DispatchPacketCOMMON(socket, owner, rp, std::forward<_Args>(args)...);
   if (handleResult != HandleResult::NOT_EXISTS)
       return handleResult;
   
   static constexpr HandleResult(*DispatchPacketFuncArray[PacketTypes::MC_PACKET_END - PacketTypes::MC_PACKET_START - 1])(uint64_t, _Owner*, NetworkPacket&, _Args&&...) =
   {
       &DispatchPacketFunc<_Owner, MC_ERROR, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_SERVER_LIST, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_ACCOUNT_USER_LIST, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_ACCOUNT_USER_CREATE, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_ACCOUNT_USER_DELETE, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_AUTH_TICKET, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_AUTH_MODIFY, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_GAME_LIST_OVER, _Args&&...>,
       &DispatchPacketFunc<_Owner, MC_ACK_GAME_LIST_UNDER, _Args&&...>
   };

   if ((PacketTypes::MC_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::MC_PACKET_END <= rp.GetPacketType()))
   {
       return HandleResult::NOT_EXISTS;
   }

   if (auto func = DispatchPacketFuncArray[rp.GetPacketType() - PacketTypes::MC_PACKET_START - 1])
       return func(socket, owner, rp, std::forward<_Args>(args)...);
   else
       return HandleResult::NOT_EXISTS;
}

