// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/NetworkPacket/NetworkPacket.h"
#include "Packet/NetworkPacket/NetworkPacketWriter.h"
#include "Packet/BasePacket/PacketWriter.h"
#include "Packet/PacketDataList/PacketDataList.h"
#include "Packet/PacketFuncs/PacketValidator.h"
#include "Packet/PacketFuncs/PacketDispatcher.h"

#pragma pack(push, 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FD_REQ_CD_BYPASS;

class FD_REQ_CD_BYPASS_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FD_REQ_CD_BYPASS;

public:
   // (1)
   explicit FD_REQ_CD_BYPASS_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_REQ_CD_BYPASS, buf)
   {
   }

   // (2)
   explicit FD_REQ_CD_BYPASS_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_REQ_CD_BYPASS, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit FD_REQ_CD_BYPASS_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_REQ_CD_BYPASS, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit FD_REQ_CD_BYPASS_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const uint8_t* nestedPacket,
       PacketSize nestedPacketSize
   )
   {
       PacketSize& nestedPacketOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(nestedPacketSize);


       nestedPacketOffset = GetPacketSize();
       WriteBinary(nestedPacket, nestedPacketSize);

   }

   FD_REQ_CD_BYPASS& GetPacket() const noexcept { return *reinterpret_cast<FD_REQ_CD_BYPASS*>(GetPacketBufPtr()); }
   FD_REQ_CD_BYPASS* GetPacketPtr() const noexcept { return reinterpret_cast<FD_REQ_CD_BYPASS*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FD_REQ_CD_BYPASS : public NetworkPacket
{
   public:
      using Writer = FD_REQ_CD_BYPASS_WRITER;


private:
   PacketSize m_nestedPacket_offset = 0;
   PacketSize m_nestedPacket_size = 0;

public:
   FD_REQ_CD_BYPASS()
   {
       memset(this, 0, sizeof(FD_REQ_CD_BYPASS));
       mPacketSize = static_cast<PacketSize>(sizeof(FD_REQ_CD_BYPASS));
   }
   FD_REQ_CD_BYPASS(const FD_REQ_CD_BYPASS&) = delete;
   FD_REQ_CD_BYPASS(FD_REQ_CD_BYPASS &&) = delete;
   FD_REQ_CD_BYPASS& operator = (const FD_REQ_CD_BYPASS&) = delete;
   FD_REQ_CD_BYPASS& operator = (FD_REQ_CD_BYPASS &&) = delete;

   const uint8_t* Get_nestedPacket() const noexcept { return ((uint8_t*)this + m_nestedPacket_offset); }
   PacketSize Get_nestedPacket_size() const noexcept { return m_nestedPacket_size; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FD_REQ_CD_BYPASS) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FD_REQ_CD_BYPASS) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FD_REQ_CD_BYPASS); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FD_REQ_CD_BYPASS))
           {
               size += sizeof(FD_REQ_CD_BYPASS);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_nestedPacket_offset)
               return false;

           thisSize += m_nestedPacket_size;
           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FD_REQ_CD_BYPASS>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}nestedPacket: BIN[{}]", tTabStr, t->Get_nestedPacket_size());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FD_REQ_USER_LOGIN;

class FD_REQ_USER_LOGIN_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FD_REQ_USER_LOGIN;

public:
   // (1)
   explicit FD_REQ_USER_LOGIN_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_REQ_USER_LOGIN, buf)
   {
   }

   // (2)
   explicit FD_REQ_USER_LOGIN_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_REQ_USER_LOGIN, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit FD_REQ_USER_LOGIN_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_REQ_USER_LOGIN, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit FD_REQ_USER_LOGIN_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       AuthTicket authTicket
   )
   {
       WriteValue(authTicket);


   }

   FD_REQ_USER_LOGIN& GetPacket() const noexcept { return *reinterpret_cast<FD_REQ_USER_LOGIN*>(GetPacketBufPtr()); }
   FD_REQ_USER_LOGIN* GetPacketPtr() const noexcept { return reinterpret_cast<FD_REQ_USER_LOGIN*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FD_REQ_USER_LOGIN : public NetworkPacket
{
   public:
      using Writer = FD_REQ_USER_LOGIN_WRITER;


private:
   AuthTicket m_authTicket;

public:
   FD_REQ_USER_LOGIN()
   {
       memset(this, 0, sizeof(FD_REQ_USER_LOGIN));
       mPacketSize = static_cast<PacketSize>(sizeof(FD_REQ_USER_LOGIN));
   }
   FD_REQ_USER_LOGIN(const FD_REQ_USER_LOGIN&) = delete;
   FD_REQ_USER_LOGIN(FD_REQ_USER_LOGIN &&) = delete;
   FD_REQ_USER_LOGIN& operator = (const FD_REQ_USER_LOGIN&) = delete;
   FD_REQ_USER_LOGIN& operator = (FD_REQ_USER_LOGIN &&) = delete;

   AuthTicket Get_authTicket() const noexcept { return m_authTicket; }
   AuthTicket& Ref_authTicket() noexcept { return m_authTicket; }
   const AuthTicket& ConstRef_authTicket() const noexcept { return m_authTicket; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FD_REQ_USER_LOGIN) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FD_REQ_USER_LOGIN) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FD_REQ_USER_LOGIN); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FD_REQ_USER_LOGIN))
           {
               size += sizeof(FD_REQ_USER_LOGIN);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(AuthTicket);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FD_REQ_USER_LOGIN>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}authTicket: {}", tTabStr, t->Get_authTicket());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FD_USER_LOGOUT;

class FD_USER_LOGOUT_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::FD_USER_LOGOUT;

public:
   // (7)
   explicit FD_USER_LOGOUT_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::FD_USER_LOGOUT, buf)
   {

   }

   // (8)
   explicit FD_USER_LOGOUT_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   FD_USER_LOGOUT& GetPacket() const noexcept { return *reinterpret_cast<FD_USER_LOGOUT*>(GetPacketBufPtr()); }
   FD_USER_LOGOUT* GetPacketPtr() const noexcept { return reinterpret_cast<FD_USER_LOGOUT*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FD_USER_LOGOUT : public NetworkPacket
{
   public:
      using Writer = FD_USER_LOGOUT_WRITER;


private:
public:
   FD_USER_LOGOUT()
   {
       memset(this, 0, sizeof(FD_USER_LOGOUT));
       mPacketSize = static_cast<PacketSize>(sizeof(FD_USER_LOGOUT));
   }
   FD_USER_LOGOUT(const FD_USER_LOGOUT&) = delete;
   FD_USER_LOGOUT(FD_USER_LOGOUT &&) = delete;
   FD_USER_LOGOUT& operator = (const FD_USER_LOGOUT&) = delete;
   FD_USER_LOGOUT& operator = (FD_USER_LOGOUT &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(FD_USER_LOGOUT) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(FD_USER_LOGOUT) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(FD_USER_LOGOUT); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(FD_USER_LOGOUT))
           {
               size += sizeof(FD_USER_LOGOUT);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, FD_USER_LOGOUT>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

#pragma pack(pop)

inline bool ValidatePacketFD(const Packet& rp)
{
   static constexpr bool(*ValidatePacketFuncArray[PacketTypes::FD_PACKET_END - PacketTypes::FD_PACKET_START - 1])(const Packet&) =
   {
       &ValidatePacketFunc<FD_REQ_CD_BYPASS>,
       &ValidatePacketFunc<FD_REQ_USER_LOGIN>,
       &ValidatePacketFunc<FD_USER_LOGOUT>
   };

   if ((PacketTypes::FD_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::FD_PACKET_END <= rp.GetPacketType()))
   {
       return true;
   }

   return ValidatePacketFuncArray[rp.GetPacketType() - PacketTypes::FD_PACKET_START - 1](rp);
}

template <typename _Owner, typename... _Args>
HandleResult DispatchPacketFD(uint64_t socket, _Owner* owner, NetworkPacket& rp, _Args&&... args)
{
   HandleResult handleResult = DispatchPacketCOMMON(socket, owner, rp, std::forward<_Args>(args)...);
   if (handleResult != HandleResult::NOT_EXISTS)
       return handleResult;
   
   static constexpr HandleResult(*DispatchPacketFuncArray[PacketTypes::FD_PACKET_END - PacketTypes::FD_PACKET_START - 1])(uint64_t, _Owner*, NetworkPacket&, _Args&&...) =
   {
       &DispatchPacketFunc<_Owner, FD_REQ_CD_BYPASS, _Args&&...>,
       &DispatchPacketFunc<_Owner, FD_REQ_USER_LOGIN, _Args&&...>,
       &DispatchPacketFunc<_Owner, FD_USER_LOGOUT, _Args&&...>
   };

   if ((PacketTypes::FD_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::FD_PACKET_END <= rp.GetPacketType()))
   {
       return HandleResult::NOT_EXISTS;
   }

   if (auto func = DispatchPacketFuncArray[rp.GetPacketType() - PacketTypes::FD_PACKET_START - 1])
       return func(socket, owner, rp, std::forward<_Args>(args)...);
   else
       return HandleResult::NOT_EXISTS;
}

