// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/NetworkPacket/NetworkPacket.h"
#include "Packet/NetworkPacket/NetworkPacketWriter.h"
#include "Packet/BasePacket/PacketWriter.h"
#include "Packet/PacketDataList/PacketDataList.h"
#include "Packet/PacketFuncs/PacketValidator.h"
#include "Packet/PacketFuncs/PacketDispatcher.h"

#pragma pack(push, 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_ACK_STATIC_DATA_CHECKSUM;

class DG_ACK_STATIC_DATA_CHECKSUM_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_ACK_STATIC_DATA_CHECKSUM;

public:
   // (4)
   explicit DG_ACK_STATIC_DATA_CHECKSUM_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_STATIC_DATA_CHECKSUM, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit DG_ACK_STATIC_DATA_CHECKSUM_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_STATIC_DATA_CHECKSUM, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit DG_ACK_STATIC_DATA_CHECKSUM_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_STATIC_DATA_CHECKSUM, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit DG_ACK_STATIC_DATA_CHECKSUM_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       Checksum staticDataChecksum,
       const StaticDataSize* staticDataSizeList,
       PacketSize staticDataSizeListSize,
       const Checksum* checksumList,
       PacketSize checksumListSize
   )
   {
       WriteValue(staticDataChecksum);

       PacketSize& staticDataSizeListOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(staticDataSizeListSize);

       PacketSize& checksumListOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(checksumListSize);


       staticDataSizeListOffset = GetPacketSize();
       WriteBinary((uint8_t*)staticDataSizeList, sizeof(StaticDataSize) * staticDataSizeListSize);

       checksumListOffset = GetPacketSize();
       WriteBinary((uint8_t*)checksumList, sizeof(Checksum) * checksumListSize);

   }

   DG_ACK_STATIC_DATA_CHECKSUM& GetPacket() const noexcept { return *reinterpret_cast<DG_ACK_STATIC_DATA_CHECKSUM*>(GetPacketBufPtr()); }
   DG_ACK_STATIC_DATA_CHECKSUM* GetPacketPtr() const noexcept { return reinterpret_cast<DG_ACK_STATIC_DATA_CHECKSUM*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_ACK_STATIC_DATA_CHECKSUM : public NetworkPacket
{
   public:
      using Writer = DG_ACK_STATIC_DATA_CHECKSUM_WRITER;


private:
   Checksum m_staticDataChecksum;

   PacketSize m_staticDataSizeList_offset = 0;
   PacketSize m_staticDataSizeList_size = 0;

   PacketSize m_checksumList_offset = 0;
   PacketSize m_checksumList_size = 0;

public:
   DG_ACK_STATIC_DATA_CHECKSUM()
   {
       memset(this, 0, sizeof(DG_ACK_STATIC_DATA_CHECKSUM));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_ACK_STATIC_DATA_CHECKSUM));
   }
   DG_ACK_STATIC_DATA_CHECKSUM(const DG_ACK_STATIC_DATA_CHECKSUM&) = delete;
   DG_ACK_STATIC_DATA_CHECKSUM(DG_ACK_STATIC_DATA_CHECKSUM &&) = delete;
   DG_ACK_STATIC_DATA_CHECKSUM& operator = (const DG_ACK_STATIC_DATA_CHECKSUM&) = delete;
   DG_ACK_STATIC_DATA_CHECKSUM& operator = (DG_ACK_STATIC_DATA_CHECKSUM &&) = delete;

   Checksum Get_staticDataChecksum() const noexcept { return m_staticDataChecksum; }
   Checksum& Ref_staticDataChecksum() noexcept { return m_staticDataChecksum; }
   const Checksum& ConstRef_staticDataChecksum() const noexcept { return m_staticDataChecksum; }

   const StaticDataSize* Get_staticDataSizeList() const noexcept { return (StaticDataSize*)((uint8_t*)this + m_staticDataSizeList_offset); }
   PacketSize Get_staticDataSizeList_size() const noexcept { return m_staticDataSizeList_size; }

   const Checksum* Get_checksumList() const noexcept { return (Checksum*)((uint8_t*)this + m_checksumList_offset); }
   PacketSize Get_checksumList_size() const noexcept { return m_checksumList_size; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_ACK_STATIC_DATA_CHECKSUM) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_ACK_STATIC_DATA_CHECKSUM) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_ACK_STATIC_DATA_CHECKSUM); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_ACK_STATIC_DATA_CHECKSUM))
           {
               size += sizeof(DG_ACK_STATIC_DATA_CHECKSUM);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(Checksum);
       }

       {
           thisSize += sizeof(StaticDataSize) * m_staticDataSizeList_size;
           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           thisSize += sizeof(Checksum) * m_checksumList_size;
           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_ACK_STATIC_DATA_CHECKSUM>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}staticDataChecksum: {}", tTabStr, t->Get_staticDataChecksum());
       if (0 == t->Get_staticDataSizeList_size())
       {
           result += std::format(L"\n{}staticDataSizeList: ARRAY[{}]", tTabStr, t->Get_staticDataSizeList_size());
       }
       else
       {
           result += std::format(L"\n{}staticDataSizeList: ARRAY[{}], ", tTabStr, t->Get_staticDataSizeList_size());
           //tTabStr += std::wstring(L"\t");
           for (size_t i = 0; i < t->Get_staticDataSizeList_size(); ++i)
           {
               result += std::format(L"\n{}{}", tTabStr, t->Get_staticDataSizeList()[i]);
           }
           //tTabStr.pop_back();
       }
       if (0 == t->Get_checksumList_size())
       {
           result += std::format(L"\n{}checksumList: ARRAY[{}]", tTabStr, t->Get_checksumList_size());
       }
       else
       {
           result += std::format(L"\n{}checksumList: ARRAY[{}], ", tTabStr, t->Get_checksumList_size());
           //tTabStr += std::wstring(L"\t");
           for (size_t i = 0; i < t->Get_checksumList_size(); ++i)
           {
               result += std::format(L"\n{}{}", tTabStr, t->Get_checksumList()[i]);
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_ACK_STATIC_DATA;

class DG_ACK_STATIC_DATA_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_ACK_STATIC_DATA;

public:
   // (4)
   explicit DG_ACK_STATIC_DATA_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_STATIC_DATA, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit DG_ACK_STATIC_DATA_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_STATIC_DATA, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit DG_ACK_STATIC_DATA_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_STATIC_DATA, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit DG_ACK_STATIC_DATA_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       StaticDataIndex index,
       uint8_t isCompleted,
       StaticDataSize offset,
       const uint8_t* staticDataBin,
       PacketSize staticDataBinSize
   )
   {
       WriteValue(index);

       WriteValue(isCompleted);

       WriteValue(offset);

       PacketSize& staticDataBinOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       WriteValue(staticDataBinSize);


       staticDataBinOffset = GetPacketSize();
       WriteBinary(staticDataBin, staticDataBinSize);

   }

   DG_ACK_STATIC_DATA& GetPacket() const noexcept { return *reinterpret_cast<DG_ACK_STATIC_DATA*>(GetPacketBufPtr()); }
   DG_ACK_STATIC_DATA* GetPacketPtr() const noexcept { return reinterpret_cast<DG_ACK_STATIC_DATA*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_ACK_STATIC_DATA : public NetworkPacket
{
   public:
      using Writer = DG_ACK_STATIC_DATA_WRITER;


private:
   StaticDataIndex m_index;

   uint8_t m_isCompleted;

   StaticDataSize m_offset;

   PacketSize m_staticDataBin_offset = 0;
   PacketSize m_staticDataBin_size = 0;

public:
   DG_ACK_STATIC_DATA()
   {
       memset(this, 0, sizeof(DG_ACK_STATIC_DATA));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_ACK_STATIC_DATA));
   }
   DG_ACK_STATIC_DATA(const DG_ACK_STATIC_DATA&) = delete;
   DG_ACK_STATIC_DATA(DG_ACK_STATIC_DATA &&) = delete;
   DG_ACK_STATIC_DATA& operator = (const DG_ACK_STATIC_DATA&) = delete;
   DG_ACK_STATIC_DATA& operator = (DG_ACK_STATIC_DATA &&) = delete;

   StaticDataIndex Get_index() const noexcept { return m_index; }
   StaticDataIndex& Ref_index() noexcept { return m_index; }
   const StaticDataIndex& ConstRef_index() const noexcept { return m_index; }

   uint8_t Get_isCompleted() const noexcept { return m_isCompleted; }
   uint8_t& Ref_isCompleted() noexcept { return m_isCompleted; }
   const uint8_t& ConstRef_isCompleted() const noexcept { return m_isCompleted; }

   StaticDataSize Get_offset() const noexcept { return m_offset; }
   StaticDataSize& Ref_offset() noexcept { return m_offset; }
   const StaticDataSize& ConstRef_offset() const noexcept { return m_offset; }

   const uint8_t* Get_staticDataBin() const noexcept { return ((uint8_t*)this + m_staticDataBin_offset); }
   PacketSize Get_staticDataBin_size() const noexcept { return m_staticDataBin_size; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_ACK_STATIC_DATA) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_ACK_STATIC_DATA) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_ACK_STATIC_DATA); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_ACK_STATIC_DATA))
           {
               size += sizeof(DG_ACK_STATIC_DATA);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(StaticDataIndex);
       }

       {
           thisSize += sizeof(uint8_t);
       }

       {
           thisSize += sizeof(StaticDataSize);
       }

       {
           if (GetPacketSize() < m_staticDataBin_offset)
               return false;

           thisSize += m_staticDataBin_size;
           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_ACK_STATIC_DATA>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}index: {}", tTabStr, t->Get_index());
       result += std::format(L"\n{}isCompleted: {}", tTabStr, t->Get_isCompleted());
       result += std::format(L"\n{}offset: {}", tTabStr, t->Get_offset());
       result += std::format(L"\n{}staticDataBin: BIN[{}]", tTabStr, t->Get_staticDataBin_size());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_REQ_ITEM_USE;

class DG_REQ_ITEM_USE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_REQ_ITEM_USE;

public:
   // (1)
   explicit DG_REQ_ITEM_USE_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_REQ_ITEM_USE, buf)
   {
   }

   // (2)
   explicit DG_REQ_ITEM_USE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_REQ_ITEM_USE, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit DG_REQ_ITEM_USE_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_REQ_ITEM_USE, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit DG_REQ_ITEM_USE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       ItemId itemId,
       ItemQuantity itemQuantity
   )
   {
       WriteValue(itemId);

       WriteValue(itemQuantity);


   }

   DG_REQ_ITEM_USE& GetPacket() const noexcept { return *reinterpret_cast<DG_REQ_ITEM_USE*>(GetPacketBufPtr()); }
   DG_REQ_ITEM_USE* GetPacketPtr() const noexcept { return reinterpret_cast<DG_REQ_ITEM_USE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_REQ_ITEM_USE : public NetworkPacket
{
   public:
      using Writer = DG_REQ_ITEM_USE_WRITER;


private:
   ItemId m_itemId;

   ItemQuantity m_itemQuantity;

public:
   DG_REQ_ITEM_USE()
   {
       memset(this, 0, sizeof(DG_REQ_ITEM_USE));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_REQ_ITEM_USE));
   }
   DG_REQ_ITEM_USE(const DG_REQ_ITEM_USE&) = delete;
   DG_REQ_ITEM_USE(DG_REQ_ITEM_USE &&) = delete;
   DG_REQ_ITEM_USE& operator = (const DG_REQ_ITEM_USE&) = delete;
   DG_REQ_ITEM_USE& operator = (DG_REQ_ITEM_USE &&) = delete;

   ItemId Get_itemId() const noexcept { return m_itemId; }
   ItemId& Ref_itemId() noexcept { return m_itemId; }
   const ItemId& ConstRef_itemId() const noexcept { return m_itemId; }

   ItemQuantity Get_itemQuantity() const noexcept { return m_itemQuantity; }
   ItemQuantity& Ref_itemQuantity() noexcept { return m_itemQuantity; }
   const ItemQuantity& ConstRef_itemQuantity() const noexcept { return m_itemQuantity; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_REQ_ITEM_USE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_REQ_ITEM_USE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_REQ_ITEM_USE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_REQ_ITEM_USE))
           {
               size += sizeof(DG_REQ_ITEM_USE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(ItemId);
       }

       {
           thisSize += sizeof(ItemQuantity);
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_REQ_ITEM_USE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}itemId: {}", tTabStr, t->Get_itemId());
       result += std::format(L"\n{}itemQuantity: {}", tTabStr, t->Get_itemQuantity());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_REQ_GAME_USER_DATA_LOAD;

class DG_REQ_GAME_USER_DATA_LOAD_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_REQ_GAME_USER_DATA_LOAD;

public:
   // (1)
   explicit DG_REQ_GAME_USER_DATA_LOAD_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_REQ_GAME_USER_DATA_LOAD, buf)
   {
   }

   // (2)
   explicit DG_REQ_GAME_USER_DATA_LOAD_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_REQ_GAME_USER_DATA_LOAD, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit DG_REQ_GAME_USER_DATA_LOAD_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_REQ_GAME_USER_DATA_LOAD, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit DG_REQ_GAME_USER_DATA_LOAD_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const ACCOUNT_USER& accountUser,
       const USER& user
   )
   {
       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       PacketSize& userOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountUserOffset = GetPacketSize();
       WriteBinary((uint8_t*)&accountUser, accountUser.GetPacketSize());

       userOffset = GetPacketSize();
       WriteBinary((uint8_t*)&user, user.GetPacketSize());

   }

   void SetValues(
       const ACCOUNT_USER::Writer& accountUser,
       const USER::Writer& user
   )
   {
       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       PacketSize& userOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountUserOffset = GetPacketSize();
       WriteBinary(accountUser.GetPacketBufPtr(), accountUser.GetPacketSize());

       userOffset = GetPacketSize();
       WriteBinary(user.GetPacketBufPtr(), user.GetPacketSize());

   }

   DG_REQ_GAME_USER_DATA_LOAD& GetPacket() const noexcept { return *reinterpret_cast<DG_REQ_GAME_USER_DATA_LOAD*>(GetPacketBufPtr()); }
   DG_REQ_GAME_USER_DATA_LOAD* GetPacketPtr() const noexcept { return reinterpret_cast<DG_REQ_GAME_USER_DATA_LOAD*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_REQ_GAME_USER_DATA_LOAD : public NetworkPacket
{
   public:
      using Writer = DG_REQ_GAME_USER_DATA_LOAD_WRITER;


private:
   PacketSize m_accountUser_offset = 0;

   PacketSize m_user_offset = 0;

public:
   DG_REQ_GAME_USER_DATA_LOAD()
   {
       memset(this, 0, sizeof(DG_REQ_GAME_USER_DATA_LOAD));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_REQ_GAME_USER_DATA_LOAD));
   }
   DG_REQ_GAME_USER_DATA_LOAD(const DG_REQ_GAME_USER_DATA_LOAD&) = delete;
   DG_REQ_GAME_USER_DATA_LOAD(DG_REQ_GAME_USER_DATA_LOAD &&) = delete;
   DG_REQ_GAME_USER_DATA_LOAD& operator = (const DG_REQ_GAME_USER_DATA_LOAD&) = delete;
   DG_REQ_GAME_USER_DATA_LOAD& operator = (DG_REQ_GAME_USER_DATA_LOAD &&) = delete;

   const ACCOUNT_USER& Get_accountUser() const noexcept { return *(ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }
   ACCOUNT_USER* Get_accountUser_ptr() const noexcept { return (ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }

   const USER& Get_user() const noexcept { return *(USER*)((uint8_t*)this + m_user_offset); }
   USER* Get_user_ptr() const noexcept { return (USER*)((uint8_t*)this + m_user_offset); }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_REQ_GAME_USER_DATA_LOAD) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_REQ_GAME_USER_DATA_LOAD) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_REQ_GAME_USER_DATA_LOAD); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_REQ_GAME_USER_DATA_LOAD))
           {
               size += sizeof(DG_REQ_GAME_USER_DATA_LOAD);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_accountUser_offset)
               return false;

           const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + m_accountUser_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       {
           if (GetPacketSize() < m_user_offset)
               return false;

           const USER* _packet = reinterpret_cast<const USER*>(GetPacketBufPtr() + m_user_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_REQ_GAME_USER_DATA_LOAD>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}accountUser: {}", tTabStr, t->Get_accountUser_ptr());
       result += std::format(L"\n{}user: {}", tTabStr, t->Get_user_ptr());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_GAME_USER_STAT_ALL;

class DG_GAME_USER_STAT_ALL_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_GAME_USER_STAT_ALL;

public:
   // (7)
   explicit DG_GAME_USER_STAT_ALL_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_GAME_USER_STAT_ALL, buf)
   {
   }

   // (9)
   explicit DG_GAME_USER_STAT_ALL_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       UserId userId,
       const WORLD_USER_STAT_ALL& worldUserStatAll
   )
       :
       NetworkPacketWriter(trait, PacketTypes::DG_GAME_USER_STAT_ALL, buf)
   {
       WriteValue(userId);

       PacketSize& worldUserStatAllOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       worldUserStatAllOffset = GetPacketSize();
       WriteBinary((uint8_t*)&worldUserStatAll, worldUserStatAll.GetPacketSize());

   }

   // (9)
   explicit DG_GAME_USER_STAT_ALL_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       UserId userId,
       const WORLD_USER_STAT_ALL::Writer& worldUserStatAll
   )
       :
       NetworkPacketWriter(trait, PacketTypes::DG_GAME_USER_STAT_ALL, buf)
   {
       WriteValue(userId);

       PacketSize& worldUserStatAllOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       worldUserStatAllOffset = GetPacketSize();
       WriteBinary(worldUserStatAll.GetPacketBufPtr(), worldUserStatAll.GetPacketSize());

   }

   // (8)
   explicit DG_GAME_USER_STAT_ALL_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       UserId userId,
       const WORLD_USER_STAT_ALL& worldUserStatAll
   )
   {
       WriteValue(userId);

       PacketSize& worldUserStatAllOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       worldUserStatAllOffset = GetPacketSize();
       WriteBinary((uint8_t*)&worldUserStatAll, worldUserStatAll.GetPacketSize());

   }

   void SetValues(
       UserId userId,
       const WORLD_USER_STAT_ALL::Writer& worldUserStatAll
   )
   {
       WriteValue(userId);

       PacketSize& worldUserStatAllOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       worldUserStatAllOffset = GetPacketSize();
       WriteBinary(worldUserStatAll.GetPacketBufPtr(), worldUserStatAll.GetPacketSize());

   }

   DG_GAME_USER_STAT_ALL& GetPacket() const noexcept { return *reinterpret_cast<DG_GAME_USER_STAT_ALL*>(GetPacketBufPtr()); }
   DG_GAME_USER_STAT_ALL* GetPacketPtr() const noexcept { return reinterpret_cast<DG_GAME_USER_STAT_ALL*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_GAME_USER_STAT_ALL : public NetworkPacket
{
   public:
      using Writer = DG_GAME_USER_STAT_ALL_WRITER;


private:
   UserId m_userId;

   PacketSize m_worldUserStatAll_offset = 0;

public:
   DG_GAME_USER_STAT_ALL()
   {
       memset(this, 0, sizeof(DG_GAME_USER_STAT_ALL));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_GAME_USER_STAT_ALL));
   }
   DG_GAME_USER_STAT_ALL(const DG_GAME_USER_STAT_ALL&) = delete;
   DG_GAME_USER_STAT_ALL(DG_GAME_USER_STAT_ALL &&) = delete;
   DG_GAME_USER_STAT_ALL& operator = (const DG_GAME_USER_STAT_ALL&) = delete;
   DG_GAME_USER_STAT_ALL& operator = (DG_GAME_USER_STAT_ALL &&) = delete;

   UserId Get_userId() const noexcept { return m_userId; }
   UserId& Ref_userId() noexcept { return m_userId; }
   const UserId& ConstRef_userId() const noexcept { return m_userId; }

   const WORLD_USER_STAT_ALL& Get_worldUserStatAll() const noexcept { return *(WORLD_USER_STAT_ALL*)((uint8_t*)this + m_worldUserStatAll_offset); }
   WORLD_USER_STAT_ALL* Get_worldUserStatAll_ptr() const noexcept { return (WORLD_USER_STAT_ALL*)((uint8_t*)this + m_worldUserStatAll_offset); }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_GAME_USER_STAT_ALL) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_GAME_USER_STAT_ALL) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_GAME_USER_STAT_ALL); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_GAME_USER_STAT_ALL))
           {
               size += sizeof(DG_GAME_USER_STAT_ALL);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(UserId);
       }

       {
           if (GetPacketSize() < m_worldUserStatAll_offset)
               return false;

           const WORLD_USER_STAT_ALL* _packet = reinterpret_cast<const WORLD_USER_STAT_ALL*>(GetPacketBufPtr() + m_worldUserStatAll_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_GAME_USER_STAT_ALL>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}userId: {}", tTabStr, t->Get_userId());
       result += std::format(L"\n{}worldUserStatAll: {}", tTabStr, t->Get_worldUserStatAll_ptr());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_GAME_USER_STAT_DIFF;

class DG_GAME_USER_STAT_DIFF_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_GAME_USER_STAT_DIFF;

private:
   PacketSize* m_worldUserStatDiffList_offset = nullptr;
   PacketSize* m_worldUserStatDiffList_count = nullptr;

public:
   // (7)
   explicit DG_GAME_USER_STAT_DIFF_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_GAME_USER_STAT_DIFF, buf)
   {
   }

   // (9)
   explicit DG_GAME_USER_STAT_DIFF_WRITER(
       PacketTraitParam trait, uint8_t* buf,
       UserId userId
   )
       :
       NetworkPacketWriter(trait, PacketTypes::DG_GAME_USER_STAT_DIFF, buf)
   {
       WriteValue(userId);

       m_worldUserStatDiffList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_worldUserStatDiffList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   // (8)
   explicit DG_GAME_USER_STAT_DIFF_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       UserId userId
   )
   {
       WriteValue(userId);

       m_worldUserStatDiffList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       m_worldUserStatDiffList_count = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));


   }

   void Write_worldUserStatDiffList(const WORLD_USER_STAT_DIFF& packet)
   {
       *m_worldUserStatDiffList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_worldUserStatDiffList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_worldUserStatDiffList_count);
   }

   void Write_worldUserStatDiffList(WORLD_USER_STAT_DIFF&& packet)
   {
       *m_worldUserStatDiffList_offset = GetPacketSize();
       WriteBinary((uint8_t*)&packet, packet.GetPacketSize());
       m_worldUserStatDiffList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_worldUserStatDiffList_count);
   }

   void Write_worldUserStatDiffList(const WORLD_USER_STAT_DIFF::Writer& packet)
   {
       *m_worldUserStatDiffList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_worldUserStatDiffList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_worldUserStatDiffList_count);
   }

   void Write_worldUserStatDiffList(WORLD_USER_STAT_DIFF::Writer&& packet)
   {
       *m_worldUserStatDiffList_offset = GetPacketSize();
       WriteBinary(packet.GetPacketBufPtr(), packet.GetPacketSize());
       m_worldUserStatDiffList_offset = (PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));
       ++(*m_worldUserStatDiffList_count);
   }

   DG_GAME_USER_STAT_DIFF& GetPacket() const noexcept { return *reinterpret_cast<DG_GAME_USER_STAT_DIFF*>(GetPacketBufPtr()); }
   DG_GAME_USER_STAT_DIFF* GetPacketPtr() const noexcept { return reinterpret_cast<DG_GAME_USER_STAT_DIFF*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_GAME_USER_STAT_DIFF : public NetworkPacket
{
   public:
      using Writer = DG_GAME_USER_STAT_DIFF_WRITER;


private:
   UserId m_userId;

   PacketSize m_worldUserStatDiffList_offset = 0;
   PacketSize m_worldUserStatDiffList_count = 0;

public:
   DG_GAME_USER_STAT_DIFF()
   {
       memset(this, 0, sizeof(DG_GAME_USER_STAT_DIFF));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_GAME_USER_STAT_DIFF));
   }
   DG_GAME_USER_STAT_DIFF(const DG_GAME_USER_STAT_DIFF&) = delete;
   DG_GAME_USER_STAT_DIFF(DG_GAME_USER_STAT_DIFF &&) = delete;
   DG_GAME_USER_STAT_DIFF& operator = (const DG_GAME_USER_STAT_DIFF&) = delete;
   DG_GAME_USER_STAT_DIFF& operator = (DG_GAME_USER_STAT_DIFF &&) = delete;

   UserId Get_userId() const noexcept { return m_userId; }
   UserId& Ref_userId() noexcept { return m_userId; }
   const UserId& ConstRef_userId() const noexcept { return m_userId; }

   PacketDataList<DG_GAME_USER_STAT_DIFF, WORLD_USER_STAT_DIFF> Get_worldUserStatDiffList() const { return PacketDataList<DG_GAME_USER_STAT_DIFF, WORLD_USER_STAT_DIFF>(this, m_worldUserStatDiffList_offset); }
   PacketSize Get_worldUserStatDiffList_count() const { return m_worldUserStatDiffList_count; }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_GAME_USER_STAT_DIFF) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_GAME_USER_STAT_DIFF) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_GAME_USER_STAT_DIFF); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_GAME_USER_STAT_DIFF))
           {
               size += sizeof(DG_GAME_USER_STAT_DIFF);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(UserId);
       }

       {
           if (GetPacketSize() < m_worldUserStatDiffList_offset)
               return false;

           PacketSize _offset = m_worldUserStatDiffList_offset;
           while (0 != _offset)
           {
               const WORLD_USER_STAT_DIFF* _packet = reinterpret_cast<const WORLD_USER_STAT_DIFF*>(GetPacketBufPtr() + _offset);
               if (!_packet->Validate(thisSize, ++depth))
                   return false;

               if (GetPacketSize() < thisSize)
                   return false;

               _offset = *reinterpret_cast<const PacketSize*>(GetPacketBufPtr() + _offset + _packet->GetPacketSize());
               thisSize += sizeof(PacketSize);

               if (GetPacketSize() < _offset)
                   return false;
           }

           thisSize += sizeof(PacketSize);
           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < _offset)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_GAME_USER_STAT_DIFF>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}userId: {}", tTabStr, t->Get_userId());
       if (0 == t->Get_worldUserStatDiffList_count())
       {
           result += std::format(L"\n{}worldUserStatDiffList: LIST[{}]", tTabStr, t->Get_worldUserStatDiffList_count());
       }
       else
       {
           result += std::format(L"\n{}worldUserStatDiffList: LIST[{}], ", tTabStr, t->Get_worldUserStatDiffList_count());
           //tTabStr += std::wstring(L"\t");
           for (const WORLD_USER_STAT_DIFF* it : t->Get_worldUserStatDiffList())
           {
               result += std::format(L"\n{}{}", tTabStr, const_cast<WORLD_USER_STAT_DIFF*>(it));
           }
           //tTabStr.pop_back();
       }
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DG_ACK_GAME_FINISH;

class DG_ACK_GAME_FINISH_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::DG_ACK_GAME_FINISH;

public:
   // (4)
   explicit DG_ACK_GAME_FINISH_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_GAME_FINISH, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (5)
   explicit DG_ACK_GAME_FINISH_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_GAME_FINISH, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (6)
   explicit DG_ACK_GAME_FINISH_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::DG_ACK_GAME_FINISH, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);

   }

   // (8)
   explicit DG_ACK_GAME_FINISH_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   DG_ACK_GAME_FINISH& GetPacket() const noexcept { return *reinterpret_cast<DG_ACK_GAME_FINISH*>(GetPacketBufPtr()); }
   DG_ACK_GAME_FINISH* GetPacketPtr() const noexcept { return reinterpret_cast<DG_ACK_GAME_FINISH*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DG_ACK_GAME_FINISH : public NetworkPacket
{
   public:
      using Writer = DG_ACK_GAME_FINISH_WRITER;


private:
public:
   DG_ACK_GAME_FINISH()
   {
       memset(this, 0, sizeof(DG_ACK_GAME_FINISH));
       mPacketSize = static_cast<PacketSize>(sizeof(DG_ACK_GAME_FINISH));
   }
   DG_ACK_GAME_FINISH(const DG_ACK_GAME_FINISH&) = delete;
   DG_ACK_GAME_FINISH(DG_ACK_GAME_FINISH &&) = delete;
   DG_ACK_GAME_FINISH& operator = (const DG_ACK_GAME_FINISH&) = delete;
   DG_ACK_GAME_FINISH& operator = (DG_ACK_GAME_FINISH &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(DG_ACK_GAME_FINISH) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(DG_ACK_GAME_FINISH) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(DG_ACK_GAME_FINISH); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(DG_ACK_GAME_FINISH))
           {
               size += sizeof(DG_ACK_GAME_FINISH);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, DG_ACK_GAME_FINISH>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

#pragma pack(pop)

inline bool ValidatePacketDG(const Packet& rp)
{
   static constexpr bool(*ValidatePacketFuncArray[PacketTypes::DG_PACKET_END - PacketTypes::DG_PACKET_START - 1])(const Packet&) =
   {
       &ValidatePacketFunc<DG_ACK_STATIC_DATA_CHECKSUM>,
       &ValidatePacketFunc<DG_ACK_STATIC_DATA>,
       &ValidatePacketFunc<DG_REQ_ITEM_USE>,
       &ValidatePacketFunc<DG_REQ_GAME_USER_DATA_LOAD>,
       &ValidatePacketFunc<DG_GAME_USER_STAT_ALL>,
       &ValidatePacketFunc<DG_GAME_USER_STAT_DIFF>,
       &ValidatePacketFunc<DG_ACK_GAME_FINISH>
   };

   if ((PacketTypes::DG_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::DG_PACKET_END <= rp.GetPacketType()))
   {
       return true;
   }

   return ValidatePacketFuncArray[rp.GetPacketType() - PacketTypes::DG_PACKET_START - 1](rp);
}

template <typename _Owner, typename... _Args>
HandleResult DispatchPacketDG(uint64_t socket, _Owner* owner, NetworkPacket& rp, _Args&&... args)
{
   HandleResult handleResult = DispatchPacketCOMMON(socket, owner, rp, std::forward<_Args>(args)...);
   if (handleResult != HandleResult::NOT_EXISTS)
       return handleResult;
   
   static constexpr HandleResult(*DispatchPacketFuncArray[PacketTypes::DG_PACKET_END - PacketTypes::DG_PACKET_START - 1])(uint64_t, _Owner*, NetworkPacket&, _Args&&...) =
   {
       &DispatchPacketFunc<_Owner, DG_ACK_STATIC_DATA_CHECKSUM, _Args&&...>,
       &DispatchPacketFunc<_Owner, DG_ACK_STATIC_DATA, _Args&&...>,
       &DispatchPacketFunc<_Owner, DG_REQ_ITEM_USE, _Args&&...>,
       &DispatchPacketFunc<_Owner, DG_REQ_GAME_USER_DATA_LOAD, _Args&&...>,
       &DispatchPacketFunc<_Owner, DG_GAME_USER_STAT_ALL, _Args&&...>,
       &DispatchPacketFunc<_Owner, DG_GAME_USER_STAT_DIFF, _Args&&...>,
       &DispatchPacketFunc<_Owner, DG_ACK_GAME_FINISH, _Args&&...>
   };

   if ((PacketTypes::DG_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::DG_PACKET_END <= rp.GetPacketType()))
   {
       return HandleResult::NOT_EXISTS;
   }

   if (auto func = DispatchPacketFuncArray[rp.GetPacketType() - PacketTypes::DG_PACKET_START - 1])
       return func(socket, owner, rp, std::forward<_Args>(args)...);
   else
       return HandleResult::NOT_EXISTS;
}

