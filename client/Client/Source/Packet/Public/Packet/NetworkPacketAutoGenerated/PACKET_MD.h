// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"
#include "Packet/NetworkPacket/NetworkPacket.h"
#include "Packet/NetworkPacket/NetworkPacketWriter.h"
#include "Packet/BasePacket/PacketWriter.h"
#include "Packet/PacketDataList/PacketDataList.h"
#include "Packet/PacketFuncs/PacketValidator.h"
#include "Packet/PacketFuncs/PacketDispatcher.h"

#pragma pack(push, 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MD;

class MD_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MD;

public:
   // (7)
   explicit MD_WRITER(PacketTraitNotify trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::MD, buf)
   {

   }

   // (8)
   explicit MD_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   MD& GetPacket() const noexcept { return *reinterpret_cast<MD*>(GetPacketBufPtr()); }
   MD* GetPacketPtr() const noexcept { return reinterpret_cast<MD*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MD : public NetworkPacket
{
   public:
      using Writer = MD_WRITER;


private:
public:
   MD()
   {
       memset(this, 0, sizeof(MD));
       mPacketSize = static_cast<PacketSize>(sizeof(MD));
   }
   MD(const MD&) = delete;
   MD(MD &&) = delete;
   MD& operator = (const MD&) = delete;
   MD& operator = (MD &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MD) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MD) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MD); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MD))
           {
               size += sizeof(MD);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MD>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MD_REQ_AUTH_TICKET;

class MD_REQ_AUTH_TICKET_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MD_REQ_AUTH_TICKET;

public:
   // (1)
   explicit MD_REQ_AUTH_TICKET_WRITER(PacketTraitReq trait, uint8_t* buf)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_REQ_AUTH_TICKET, buf)
   {
   }

   // (2)
   explicit MD_REQ_AUTH_TICKET_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacket& rp)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_REQ_AUTH_TICKET, buf)
   {
       SetReadPacket(rp);
   }

   // (3)
   explicit MD_REQ_AUTH_TICKET_WRITER(PacketTraitReq trait, uint8_t* buf, const NetworkPacketWriter& wp)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_REQ_AUTH_TICKET, buf)
   {
       SetWritePacket(wp);
   }

   // (8)
   explicit MD_REQ_AUTH_TICKET_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       AuthTicket authTicket,
       const ACCOUNT_USER& accountUser
   )
   {
       WriteValue(authTicket);

       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountUserOffset = GetPacketSize();
       WriteBinary((uint8_t*)&accountUser, accountUser.GetPacketSize());

   }

   void SetValues(
       AuthTicket authTicket,
       const ACCOUNT_USER::Writer& accountUser
   )
   {
       WriteValue(authTicket);

       PacketSize& accountUserOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       accountUserOffset = GetPacketSize();
       WriteBinary(accountUser.GetPacketBufPtr(), accountUser.GetPacketSize());

   }

   MD_REQ_AUTH_TICKET& GetPacket() const noexcept { return *reinterpret_cast<MD_REQ_AUTH_TICKET*>(GetPacketBufPtr()); }
   MD_REQ_AUTH_TICKET* GetPacketPtr() const noexcept { return reinterpret_cast<MD_REQ_AUTH_TICKET*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MD_REQ_AUTH_TICKET : public NetworkPacket
{
   public:
      using Writer = MD_REQ_AUTH_TICKET_WRITER;


private:
   AuthTicket m_authTicket;

   PacketSize m_accountUser_offset = 0; // accountId, userId 셋팅

public:
   MD_REQ_AUTH_TICKET()
   {
       memset(this, 0, sizeof(MD_REQ_AUTH_TICKET));
       mPacketSize = static_cast<PacketSize>(sizeof(MD_REQ_AUTH_TICKET));
   }
   MD_REQ_AUTH_TICKET(const MD_REQ_AUTH_TICKET&) = delete;
   MD_REQ_AUTH_TICKET(MD_REQ_AUTH_TICKET &&) = delete;
   MD_REQ_AUTH_TICKET& operator = (const MD_REQ_AUTH_TICKET&) = delete;
   MD_REQ_AUTH_TICKET& operator = (MD_REQ_AUTH_TICKET &&) = delete;

   AuthTicket Get_authTicket() const noexcept { return m_authTicket; }
   AuthTicket& Ref_authTicket() noexcept { return m_authTicket; }
   const AuthTicket& ConstRef_authTicket() const noexcept { return m_authTicket; }

   const ACCOUNT_USER& Get_accountUser() const noexcept { return *(ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }
   ACCOUNT_USER* Get_accountUser_ptr() const noexcept { return (ACCOUNT_USER*)((uint8_t*)this + m_accountUser_offset); }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MD_REQ_AUTH_TICKET) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MD_REQ_AUTH_TICKET) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MD_REQ_AUTH_TICKET); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MD_REQ_AUTH_TICKET))
           {
               size += sizeof(MD_REQ_AUTH_TICKET);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           thisSize += sizeof(AuthTicket);
       }

       {
           if (GetPacketSize() < m_accountUser_offset)
               return false;

           const ACCOUNT_USER* _packet = reinterpret_cast<const ACCOUNT_USER*>(GetPacketBufPtr() + m_accountUser_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MD_REQ_AUTH_TICKET>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}authTicket: {}", tTabStr, t->Get_authTicket());
       result += std::format(L"\n{}accountUser: {}", tTabStr, t->Get_accountUser_ptr());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MD_ACK_GAME_CREATE;

class MD_ACK_GAME_CREATE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MD_ACK_GAME_CREATE;

public:
   // (4)
   explicit MD_ACK_GAME_CREATE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_CREATE, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (5)
   explicit MD_ACK_GAME_CREATE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_CREATE, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);
   }

   // (6)
   explicit MD_ACK_GAME_CREATE_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_CREATE, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);
   }

   // (8)
   explicit MD_ACK_GAME_CREATE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   void SetValues(
       const GAME& game
   )
   {
       PacketSize& gameOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       gameOffset = GetPacketSize();
       WriteBinary((uint8_t*)&game, game.GetPacketSize());

   }

   void SetValues(
       const GAME::Writer& game
   )
   {
       PacketSize& gameOffset = *(PacketSize*)GetPacketBufWritingPtr();
       WriteValue(PacketSize(0));

       gameOffset = GetPacketSize();
       WriteBinary(game.GetPacketBufPtr(), game.GetPacketSize());

   }

   MD_ACK_GAME_CREATE& GetPacket() const noexcept { return *reinterpret_cast<MD_ACK_GAME_CREATE*>(GetPacketBufPtr()); }
   MD_ACK_GAME_CREATE* GetPacketPtr() const noexcept { return reinterpret_cast<MD_ACK_GAME_CREATE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MD_ACK_GAME_CREATE : public NetworkPacket
{
   public:
      using Writer = MD_ACK_GAME_CREATE_WRITER;


private:
   PacketSize m_game_offset = 0;

public:
   MD_ACK_GAME_CREATE()
   {
       memset(this, 0, sizeof(MD_ACK_GAME_CREATE));
       mPacketSize = static_cast<PacketSize>(sizeof(MD_ACK_GAME_CREATE));
   }
   MD_ACK_GAME_CREATE(const MD_ACK_GAME_CREATE&) = delete;
   MD_ACK_GAME_CREATE(MD_ACK_GAME_CREATE &&) = delete;
   MD_ACK_GAME_CREATE& operator = (const MD_ACK_GAME_CREATE&) = delete;
   MD_ACK_GAME_CREATE& operator = (MD_ACK_GAME_CREATE &&) = delete;

   const GAME& Get_game() const noexcept { return *(GAME*)((uint8_t*)this + m_game_offset); }
   GAME* Get_game_ptr() const noexcept { return (GAME*)((uint8_t*)this + m_game_offset); }


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MD_ACK_GAME_CREATE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MD_ACK_GAME_CREATE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MD_ACK_GAME_CREATE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MD_ACK_GAME_CREATE))
           {
               size += sizeof(MD_ACK_GAME_CREATE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       {
           if (GetPacketSize() < m_game_offset)
               return false;

           const GAME* _packet = reinterpret_cast<const GAME*>(GetPacketBufPtr() + m_game_offset);
           if (!_packet->Validate(thisSize, ++depth))
               return false;

           thisSize += sizeof(PacketSize);

           if (GetPacketSize() < thisSize)
               return false;
       }

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MD_ACK_GAME_CREATE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       result += std::format(L"\n{}game: {}", tTabStr, t->Get_game_ptr());
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MD_ACK_GAME_USER_ENTER;

class MD_ACK_GAME_USER_ENTER_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MD_ACK_GAME_USER_ENTER;

public:
   // (4)
   explicit MD_ACK_GAME_USER_ENTER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_USER_ENTER, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (5)
   explicit MD_ACK_GAME_USER_ENTER_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_USER_ENTER, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (6)
   explicit MD_ACK_GAME_USER_ENTER_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_USER_ENTER, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);

   }

   // (8)
   explicit MD_ACK_GAME_USER_ENTER_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   MD_ACK_GAME_USER_ENTER& GetPacket() const noexcept { return *reinterpret_cast<MD_ACK_GAME_USER_ENTER*>(GetPacketBufPtr()); }
   MD_ACK_GAME_USER_ENTER* GetPacketPtr() const noexcept { return reinterpret_cast<MD_ACK_GAME_USER_ENTER*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MD_ACK_GAME_USER_ENTER : public NetworkPacket
{
   public:
      using Writer = MD_ACK_GAME_USER_ENTER_WRITER;


private:
public:
   MD_ACK_GAME_USER_ENTER()
   {
       memset(this, 0, sizeof(MD_ACK_GAME_USER_ENTER));
       mPacketSize = static_cast<PacketSize>(sizeof(MD_ACK_GAME_USER_ENTER));
   }
   MD_ACK_GAME_USER_ENTER(const MD_ACK_GAME_USER_ENTER&) = delete;
   MD_ACK_GAME_USER_ENTER(MD_ACK_GAME_USER_ENTER &&) = delete;
   MD_ACK_GAME_USER_ENTER& operator = (const MD_ACK_GAME_USER_ENTER&) = delete;
   MD_ACK_GAME_USER_ENTER& operator = (MD_ACK_GAME_USER_ENTER &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MD_ACK_GAME_USER_ENTER) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MD_ACK_GAME_USER_ENTER) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MD_ACK_GAME_USER_ENTER); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MD_ACK_GAME_USER_ENTER))
           {
               size += sizeof(MD_ACK_GAME_USER_ENTER);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MD_ACK_GAME_USER_ENTER>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MD_ACK_GAME_USER_LEAVE;

class MD_ACK_GAME_USER_LEAVE_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MD_ACK_GAME_USER_LEAVE;

public:
   // (4)
   explicit MD_ACK_GAME_USER_LEAVE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_USER_LEAVE, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (5)
   explicit MD_ACK_GAME_USER_LEAVE_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_USER_LEAVE, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (6)
   explicit MD_ACK_GAME_USER_LEAVE_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_USER_LEAVE, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);

   }

   // (8)
   explicit MD_ACK_GAME_USER_LEAVE_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   MD_ACK_GAME_USER_LEAVE& GetPacket() const noexcept { return *reinterpret_cast<MD_ACK_GAME_USER_LEAVE*>(GetPacketBufPtr()); }
   MD_ACK_GAME_USER_LEAVE* GetPacketPtr() const noexcept { return reinterpret_cast<MD_ACK_GAME_USER_LEAVE*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MD_ACK_GAME_USER_LEAVE : public NetworkPacket
{
   public:
      using Writer = MD_ACK_GAME_USER_LEAVE_WRITER;


private:
public:
   MD_ACK_GAME_USER_LEAVE()
   {
       memset(this, 0, sizeof(MD_ACK_GAME_USER_LEAVE));
       mPacketSize = static_cast<PacketSize>(sizeof(MD_ACK_GAME_USER_LEAVE));
   }
   MD_ACK_GAME_USER_LEAVE(const MD_ACK_GAME_USER_LEAVE&) = delete;
   MD_ACK_GAME_USER_LEAVE(MD_ACK_GAME_USER_LEAVE &&) = delete;
   MD_ACK_GAME_USER_LEAVE& operator = (const MD_ACK_GAME_USER_LEAVE&) = delete;
   MD_ACK_GAME_USER_LEAVE& operator = (MD_ACK_GAME_USER_LEAVE &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MD_ACK_GAME_USER_LEAVE) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MD_ACK_GAME_USER_LEAVE) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MD_ACK_GAME_USER_LEAVE); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MD_ACK_GAME_USER_LEAVE))
           {
               size += sizeof(MD_ACK_GAME_USER_LEAVE);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MD_ACK_GAME_USER_LEAVE>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MD_ACK_GAME_FINISH;

class MD_ACK_GAME_FINISH_WRITER : public NetworkPacketWriter
{
public:
   static constexpr PacketType PACKET_TYPE = PacketTypes::MD_ACK_GAME_FINISH;

public:
   // (4)
   explicit MD_ACK_GAME_FINISH_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacket& rp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_FINISH, buf)
   {
       SetReadPacket(rp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (5)
   explicit MD_ACK_GAME_FINISH_WRITER(PacketTraitAck trait, uint8_t* buf, const NetworkPacketWriter& wp, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_FINISH, buf)
   {
       SetWritePacket(wp);
       GetHeader().SetPacketResult(packetResult);

   }

   // (6)
   explicit MD_ACK_GAME_FINISH_WRITER(PacketTraitAck trait, uint8_t* buf, const PacketHeader& header, Result packetResult)
       :
       NetworkPacketWriter(trait, PacketTypes::MD_ACK_GAME_FINISH, buf)
   {
       SetHeader(header);
       GetHeader().SetPacketResult(packetResult);

   }

   // (8)
   explicit MD_ACK_GAME_FINISH_WRITER(uint8_t* buf)
       :
       NetworkPacketWriter(buf) 
   {
   }

   MD_ACK_GAME_FINISH& GetPacket() const noexcept { return *reinterpret_cast<MD_ACK_GAME_FINISH*>(GetPacketBufPtr()); }
   MD_ACK_GAME_FINISH* GetPacketPtr() const noexcept { return reinterpret_cast<MD_ACK_GAME_FINISH*>(GetPacketBufPtr()); }

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MD_ACK_GAME_FINISH : public NetworkPacket
{
   public:
      using Writer = MD_ACK_GAME_FINISH_WRITER;


private:
public:
   MD_ACK_GAME_FINISH()
   {
       memset(this, 0, sizeof(MD_ACK_GAME_FINISH));
       mPacketSize = static_cast<PacketSize>(sizeof(MD_ACK_GAME_FINISH));
   }
   MD_ACK_GAME_FINISH(const MD_ACK_GAME_FINISH&) = delete;
   MD_ACK_GAME_FINISH(MD_ACK_GAME_FINISH &&) = delete;
   MD_ACK_GAME_FINISH& operator = (const MD_ACK_GAME_FINISH&) = delete;
   MD_ACK_GAME_FINISH& operator = (MD_ACK_GAME_FINISH &&) = delete;


   bool Validate(IN OUT size_t& size, int32_t depth = 0) const
   {
       if (0 == GetPacketSize())
           return true;

       if (sizeof(MD_ACK_GAME_FINISH) > GetPacketSize())
           return false;

       if (MAX_PACKET_BUFFER_SIZE < GetPacketSize())
           return false;

       if ((depth != 0) && (sizeof(MD_ACK_GAME_FINISH) == GetPacketSize()))
       {
           size_t i = sizeof(NetworkPacket);
           for (; i < sizeof(MD_ACK_GAME_FINISH); ++i)
               if (0 != GetPacketBufPtr()[i]) break;

           if (i == sizeof(MD_ACK_GAME_FINISH))
           {
               size += sizeof(MD_ACK_GAME_FINISH);
               return true;
           }
       }

       size_t thisSize = sizeof(NetworkPacket);

       if (GetPacketSize() != thisSize)
           return false;

       size += thisSize;

       return true;
   }

};

template<typename T, typename _CharType>
    requires std::is_same_v<std::remove_cv_t<std::remove_pointer_t<T>>, MD_ACK_GAME_FINISH>
struct std::formatter<T, _CharType>
{
    constexpr auto parse(auto& ctx)
    {
        return ctx.end();
    }

    auto format(MAYBE_UNUSED T t, auto& ctx) const
    {
        std::wstring result;
       result += std::format(L"\n{}{}", tTabStr, t->ConstGetHeader());
       tTabStr += std::wstring(L"\t");
       tTabStr.pop_back();

       return std::ranges::copy(result, ctx.out()).out;
   }
};

#pragma pack(pop)

inline bool ValidatePacketMD(const Packet& rp)
{
   static constexpr bool(*ValidatePacketFuncArray[PacketTypes::MD_PACKET_END - PacketTypes::MD_PACKET_START - 1])(const Packet&) =
   {
       &ValidatePacketFunc<MD>,
       &ValidatePacketFunc<MD_REQ_AUTH_TICKET>,
       &ValidatePacketFunc<MD_ACK_GAME_CREATE>,
       &ValidatePacketFunc<MD_ACK_GAME_USER_ENTER>,
       &ValidatePacketFunc<MD_ACK_GAME_USER_LEAVE>,
       &ValidatePacketFunc<MD_ACK_GAME_FINISH>
   };

   if ((PacketTypes::MD_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::MD_PACKET_END <= rp.GetPacketType()))
   {
       return true;
   }

   return ValidatePacketFuncArray[rp.GetPacketType() - PacketTypes::MD_PACKET_START - 1](rp);
}

template <typename _Owner, typename... _Args>
HandleResult DispatchPacketMD(uint64_t socket, _Owner* owner, NetworkPacket& rp, _Args&&... args)
{
   HandleResult handleResult = DispatchPacketCOMMON(socket, owner, rp, std::forward<_Args>(args)...);
   if (handleResult != HandleResult::NOT_EXISTS)
       return handleResult;
   
   static constexpr HandleResult(*DispatchPacketFuncArray[PacketTypes::MD_PACKET_END - PacketTypes::MD_PACKET_START - 1])(uint64_t, _Owner*, NetworkPacket&, _Args&&...) =
   {
       &DispatchPacketFunc<_Owner, MD, _Args&&...>,
       &DispatchPacketFunc<_Owner, MD_REQ_AUTH_TICKET, _Args&&...>,
       &DispatchPacketFunc<_Owner, MD_ACK_GAME_CREATE, _Args&&...>,
       &DispatchPacketFunc<_Owner, MD_ACK_GAME_USER_ENTER, _Args&&...>,
       &DispatchPacketFunc<_Owner, MD_ACK_GAME_USER_LEAVE, _Args&&...>,
       &DispatchPacketFunc<_Owner, MD_ACK_GAME_FINISH, _Args&&...>
   };

   if ((PacketTypes::MD_PACKET_START >= rp.GetPacketType()) ||
       (PacketTypes::MD_PACKET_END <= rp.GetPacketType()))
   {
       return HandleResult::NOT_EXISTS;
   }

   if (auto func = DispatchPacketFuncArray[rp.GetPacketType() - PacketTypes::MD_PACKET_START - 1])
       return func(socket, owner, rp, std::forward<_Args>(args)...);
   else
       return HandleResult::NOT_EXISTS;
}

