// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "Packet/StaticDataCatalog/StaticDataCatalog.h"

#include "Common/Util/Md5/Md5.h"

#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"


namespace StaticDataCatalogUtil
{
	template<typename _List>
	void StaticDataToBinary(
		IN _List& staticDataList, 
		OUT std::vector<StaticDataSize>& sizeList,
		OUT std::vector<Checksum>& checksumList,
		OUT std::vector<uint8_t*>& binaryList
	)
	{
		using _ListType = typename std::decay<_List>::type;
		using _PacketKeep = typename _ListType::value_type;
		using _PacketType = typename _PacketKeep::packet_type;

		StaticDataSize size = 0;
		for (_PacketKeep& packetKeep : staticDataList)
		{
			_PacketType* packet = *packetKeep;
			size += packet->GetPacketSize();
		}	
		sizeList.emplace_back(size);
		binaryList.emplace_back(size ? _MALLOC<uint8_t>(size) : nullptr);
		uint8_t* buf = binaryList.back();		
		for (_PacketKeep& container : staticDataList)
		{
			_PacketType* packet = *container;
			std::copy_n(packet->GetPacketBufPtr(), packet->GetPacketSize(), buf);
			buf += packet->GetPacketSize();
		}
		buf = binaryList.back();

		Md5 md5;
		Checksum checksum = md5.GetChecksum(buf, size);
		checksumList.emplace_back(checksum);
	}

	template<typename _List>
	bool BinaryToStaticDataList(
		OUT _List& staticDataList, 
		IN StaticDataSize size,
		IN uint8_t* bin
	)
	{
		using _ListType = typename std::decay<_List>::type;
		using _PacketKeep = typename _ListType::value_type;
		using _PacketType = typename _PacketKeep::packet_type;

		staticDataList.clear();
		while (0 < size)
		{
			if (nullptr == bin)
				return false;

			_PacketType* packet = reinterpret_cast<_PacketType*>(bin);

			size_t validateSize = 0;
			if (false == packet->Validate(validateSize))
				return false;

			staticDataList.emplace_back(*packet);
			bin += packet->GetPacketSize();
			size -= packet->GetPacketSize();
		}

		if (0 != size)
			return false;

		return true;
	}
}

StaticDataCatalog::StaticDataCatalog(const StaticDataIndexList& staticDataIndexListForGameServer, const StaticDataIndexList& staticDataIndexListForClient)
	:
	mStaticDataIndexListForGameServer(staticDataIndexListForGameServer),
	mStaticDataIndexListForClient(staticDataIndexListForClient)
{
	size_t idx = 0;
	StaticDataListTypes types; // 媛泥대ㅼ???깃낵 ?硫몄???ㅻ ?? 二쇱.
	ForEach(types,
		[this, &idx](auto& type)
		{
			RegisterList<decltype(type)>(idx++);
		}
	);
}

StaticDataCatalog::~StaticDataCatalog()
{
	Cleanup();
}

void StaticDataCatalog::Cleanup()
{
	mMyChecksumForGameServer = Checksum{};
	mMyChecksumForClient = Checksum{};
	mMySizeList.clear();
	mMyChecksumList.clear();

	for (size_t i = 0; i < mBinaryList.size(); ++i)
	{
		if (nullptr != mBinaryList[i])
		{
			_FREE(reinterpret_cast<void*>(mBinaryList[i]));
			mBinaryList[i] = nullptr;
		}		
	}
	mBinaryList.clear();
}

void StaticDataCatalog::StaticDataToBinary()
{
	Cleanup();	

	StaticDataListTypes types; // 媛泥대ㅼ???깃낵 ?硫몄???ㅻ ?? 二쇱.
	ForEach(types,
		[this](auto& type)
		{
			StaticDataCatalogUtil::StaticDataToBinary(
				IN GetList<decltype(type)>(),
				OUT mMySizeList,
				OUT mMyChecksumList,
				OUT mBinaryList
			);
		}
	);

	{
		std::vector<Checksum> checksumList;

		Md5 md5;
		for (size_t index : mStaticDataIndexListForGameServer)
		{
			checksumList.emplace_back(mMyChecksumList[index]);
		}

		mMyChecksumForGameServer = md5.GetChecksum(reinterpret_cast<uint8_t*>(checksumList.data()), sizeof(Checksum) * checksumList.size());
	}

	{
		std::vector<Checksum> checksumList;

		Md5 md5;
		for (size_t index : mStaticDataIndexListForClient)
		{
			checksumList.emplace_back(mMyChecksumList[index]);
		}

		mMyChecksumForClient = md5.GetChecksum(reinterpret_cast<uint8_t*>(checksumList.data()), sizeof(Checksum) * checksumList.size());
	}
}

std::pair<bool, StaticDataIndex> StaticDataCatalog::BuildDataForGameServer()
{
	for (StaticDataIndex index : mStaticDataIndexListForGameServer)
	{
		if(false == BinaryToStaticDataList(index))
			return std::make_pair(false, index);
	}

	StaticDataToBinary();

	if (mMyChecksumList.size() != mExpectedChecksumList.size())
		return std::make_pair(false, INVALID_STATIC_DATA_INDEX);

	for (StaticDataIndex index : mStaticDataIndexListForGameServer)
	{
		if (mMyChecksumList[index] != mExpectedChecksumList[index])
			return std::make_pair(false, index);
	}

	if (mMyChecksumForGameServer != mExpectedChecksumForGameServer)
		return std::make_pair(false, INVALID_STATIC_DATA_INDEX);

	return std::make_pair(true, INVALID_STATIC_DATA_INDEX);
}

std::pair<bool, StaticDataIndex> StaticDataCatalog::BuildDataForClient()
{
	for (StaticDataIndex index : mStaticDataIndexListForClient)
	{
		if (false == BinaryToStaticDataList(index))
			return std::make_pair(false, index);
	}

	StaticDataToBinary();

	if (mMyChecksumList.size() != mExpectedChecksumList.size())
		return std::make_pair(false, INVALID_STATIC_DATA_INDEX);

	for (StaticDataIndex index : mStaticDataIndexListForClient)
	{
		if (mMyChecksumList[index] != mExpectedChecksumList[index])
			return std::make_pair(false, index);
	}

	if (mMyChecksumForClient != mExpectedChecksumForClient)
		return std::make_pair(false, INVALID_STATIC_DATA_INDEX);

	return std::make_pair(true, INVALID_STATIC_DATA_INDEX);
}

bool StaticDataCatalog::BinaryToStaticDataList(StaticDataIndex idx)
{
	bool result = false;
	StaticDataIndex _idx = 0;
	StaticDataListTypes types; // 媛泥대ㅼ???깃낵 ?硫몄???ㅻ ?? 二쇱.
	ForEach(types,
		[this, &_idx, idx, &result](auto& type)
		{
			if (!result && (_idx++) == idx)
			{
				StaticDataCatalogUtil::BinaryToStaticDataList(
					OUT GetList<decltype(type)>(), 
					IN mExpectedSizeList[idx],
					IN mBinaryList[idx]
				);
				result = true;
			}
		}
	);

	return result;
}

bool StaticDataCatalog::SetSyncing()
{ 
	State expected = State::NONE;
	return mState.compare_exchange_strong(expected, State::SYNCING);
}

bool StaticDataCatalog::SetSynced()
{ 
	State expected = State::SYNCING;
	return mState.compare_exchange_strong(expected, State::SYNCED);
}

bool StaticDataCatalog::ResetSync()
{
		State expected = State::SYNCED;
		return mState.compare_exchange_strong(expected, State::NONE);
}

#if defined(__UNREAL__)
PACKET_API TSharedPtr<StaticDataCatalog> gStaticDataCatalog = nullptr;
#endif

