// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "PeerSocket.h"

#include "Common/Random/Mt19937Random/Mt19937Random32.h"
#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"

import ServerEngineDev;
import ServerEngineNetwork;
import ServerEngineUtil;
import ServerEngineWorker;
import ServerEngineApp;


bool PeerSocket::Connect(const wchar_t* hostIp, uint16_t hostPort, AppId myAppId, AppType myAppType, AppId hostAppId, AppType hostAppType)
{
	_DEBUG_LOG(WHITE, L"[{}]", mSocket);

	mHostIp = hostIp;
	mHostPort = hostPort;
	mMyAppId = myAppId;
	mMyAppType = myAppType;
	mHostAppId = hostAppId;
	mHostAppType = hostAppType;

	TryConnect();

	return true;
}

void PeerSocket::TryConnect()
{
	SocketBase::Connect(mHostIp.c_str(), mHostPort, false);
}

void PeerSocket::Reconnect_timer()
{
	_DEBUG_LOG(WHITE, L"[{}]", mSocket);

	ReleaseRef(L"Reconnect_timer");

	SocketBase::Connect(mHostIp.c_str(), mHostPort, true);
}

void PeerSocket::OnConnected(bool succeed)
{
	_DEBUG_LOG(WHITE, L"[{}], succeed: {}", mSocket, succeed);

	mHostEncryptionKey = 0;

	if (true == succeed)
	{
		mReconnectDelay = 0ms;
	}

	__super::OnConnected(succeed);
}

void PeerSocket::OnDisconnected()
{
	_DEBUG_LOG(WHITE, L"[{}]", mSocket);

	OnLostSocket();

	__super::OnDisconnected();
}

bool PeerSocket::OnDispose()
{
	OnLostSocket();

	if (true == mEnableReconnect)
	{
		InitRef(L"Prevent Disposing For Reconnecting");

		AddRef(L"Reconnect_timer");
		mReconnectDelay = std::clamp(mReconnectDelay, MIN_RECONNECT_DELAY, MAX_RECONNECT_DELAY);
		WorkerManager::RunOnTimer(mReconnectDelay, gTimerWorker->GetTimerWorker(), this, &PeerSocket::Reconnect_timer);

		return false;
	}

	return true;
}

Result PeerSocket::OnRecv(uint8_t* buf, size_t len, OUT size_t& recved)
{
	size_t remain = len;

	while (sizeof(NetworkPacket) <= remain)
	{
		if (SocketState::CONNECTED != mSocketState.load())
		{
			return Result::NETWORK_DISCONNECTED;
		}

		NetworkPacket* ptr;

		if (0 == mHostEncryptionKey)
		{
			ptr = reinterpret_cast<NetworkPacket*>(buf);

			const PacketSize packetSize = ptr->GetPacketSize();

			if (packetSize > remain)
			{
				break;
			}

			if (MAX_PACKET_BUFFER_SIZE < packetSize)
			{
				_DEBUG_BREAK;
				return Result::OUT_OF_SIZE;
			}

			const PacketType packetType = ptr->GetPacketType();
			if (PacketTypes::HANDSHAKE_TO_PEER != packetType)
			{
				_DEBUG_BREAK;
				return Result::NEED_HANDSHAKE;
			}

			HANDSHAKE_TO_PEER* rp = reinterpret_cast<HANDSHAKE_TO_PEER*>(buf);

			{
				mMyEncryptionKey = (*tRandomEngine32)();
				if (0 == mMyEncryptionKey)
					mMyEncryptionKey = 1;

				SocketUtil::Send<HANDSHAKE_TO_HOST::Writer, EncryptionOption::NO_ENCRYPTION> wp(*this, NOTIFY);
				wp.SetValues(
					mMyEncryptionKey, 
					mMyAppId,
					mMyAppType
				);
			}

			mHostEncryptionKey = rp->Get_hostEncryptionKey();

			OnHandshakeCompleted(mIsReconnect);

			UpdateAppListSocketInfo();
		}
		else
		{
			OnEncrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);

			ptr = reinterpret_cast<NetworkPacket*>(buf);

			const PacketSize packetSize = ptr->GetPacketSize();

			if (packetSize > remain)
			{
				OnEncrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);
				break;
			}

			if (MAX_PACKET_BUFFER_SIZE < packetSize)
			{
				_DEBUG_BREAK;
				return Result::OUT_OF_SIZE;
			}

			OnEncrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);
			OnEncrypt(buf, packetSize, mMyEncryptionKey);

#ifdef _DEBUG
			gDevPacketConverter.OnApplyDevPacketType(IN OUT * ptr);
#endif

			OnLogPacket(*ptr);

			if (false == OnDispatchPacket(*ptr))
			{
				// 잘못된 패킷 또는 접속이 끊긴 경우 일 수 있다
				return Result::HANDLING_PACKET_FAILED;
			}
		}

		buf += ptr->GetPacketSize();
		remain -= ptr->GetPacketSize();
	}

	recved = len - remain;
	return Result::SUCCEEDED;
}

void PeerSocket::UpdateAppListSocketInfo()
{
	if (mHostAppId == INVALID_APP_ID)
		return;

	auto [appInfo, lock] = gAppListManager->FindAppInfo(mHostAppId);
	if (!appInfo)
	{
		// 데드락 방지
		lock.~ReadLock();

		auto [newAppInfo, newLock] = gAppListManager->AddAppInfo(
			APP_DATA::Writer(PARAM, TEMP_BUF,
				mHostAppId,
				mHostAppType,
				L""
			).GetPacket()
		);

		appInfo = newAppInfo;

		//return;
	}

	if (!appInfo->GetSocket())
		appInfo->SetSocket(GetSocketPtr(), L"PeerSocket");
}

bool PeerSocket::HasEncryptionKey() const
{
	return (0 == mHostEncryptionKey) ? false : true;
}

void PeerSocket::OnTryEncrypt(uint8_t* buf, int32_t len)
{
	if (0 == mHostEncryptionKey)
		return;

	OnEncrypt(buf, len, mHostEncryptionKey);
}
