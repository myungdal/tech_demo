// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#include "HostSocket.h"

#include "Common/Random/Mt19937Random/Mt19937Random32.h"
#include "Packet/BasePacketAutoGenerated/PACKET_COMMON.h"

import ServerEngineNetwork;
import ServerEngineUtil;
import ServerEngineWorker;
import ServerEngineApp;


void HostSocket::OnConnected(bool succeed)
{
	_DEBUG_LOG(WHITE, L"[{}]", mSocket);

	__super::OnConnected(succeed);

	mPeerEncryptionKey = 0;

	if (true == succeed)
	{
		mMyEncryptionKey = (*tRandomEngine32)();
		if (0 == mMyEncryptionKey)
			mMyEncryptionKey = 1;

		SocketUtil::Send<HANDSHAKE_TO_PEER::Writer, EncryptionOption::NO_ENCRYPTION> wp(*this, NOTIFY);
		wp.SetValues(mMyEncryptionKey);
	}
}

void HostSocket::OnDisconnected()
{
	_DEBUG_LOG(WHITE, L"[{}]", mSocket);

	OnLostSocket();

	__super::OnDisconnected();
}

Result HostSocket::OnRecv(uint8_t* buf, size_t len, OUT size_t& recved)
{
	size_t remain = len;

	while (sizeof(NetworkPacket) <= remain)
	{
		if (SocketState::CONNECTED != mSocketState.load())
		{
			return Result::NETWORK_DISCONNECTED;
		}

		NetworkPacket* ptr;

		if (0 == mPeerEncryptionKey)
		{
			ptr = reinterpret_cast<NetworkPacket*>(buf);

			const PacketSize packetSize = ptr->GetPacketSize();

			if (packetSize > remain)
				break;

			if (MAX_PACKET_BUFFER_SIZE < packetSize)
			{
				_DEBUG_BREAK;
				return Result::OUT_OF_SIZE;
			}

			const PacketType packetType = ptr->GetPacketType();
			if (PacketTypes::HANDSHAKE_TO_HOST != packetType)
			{
				_DEBUG_RED;
				return Result::NEED_HANDSHAKE;
			}

			const HANDSHAKE_TO_HOST* rp = reinterpret_cast<HANDSHAKE_TO_HOST*>(buf);
			mPeerEncryptionKey = rp->Get_peerEncryptionKey();
			mPeerAppId = rp->Get_peerAppId();
			mPeerAppType = rp->Get_peerAppType();

			OnHandshakeCompleted(false);

			UpdateAppListSocketInfo();
		}
		else 
		{
			OnEncrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);

			ptr = reinterpret_cast<NetworkPacket*>(buf);

			const PacketSize packetSize = ptr->GetPacketSize();

			if (packetSize > remain)
			{
				OnEncrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);
				break;
			}

			if (MAX_PACKET_BUFFER_SIZE < packetSize)
				return Result::OUT_OF_SIZE;

			OnEncrypt(buf, sizeof(NetworkPacket), mMyEncryptionKey);
			OnEncrypt(buf, packetSize, mMyEncryptionKey);

			OnLogPacket(*ptr);

			if (false == OnDispatchPacket(*ptr))
			{
				recved = len;
				// 잘못된 패킷 또는 접속이 끊긴 경우 일 수 있다
				return Result::HANDLING_PACKET_FAILED;
			}
		}

		buf += ptr->GetPacketSize();
		remain -= ptr->GetPacketSize();
	}

	recved = len - remain;

	return Result::SUCCEEDED;
}

void HostSocket::UpdateAppListSocketInfo()
{
	if (mPeerAppId == INVALID_APP_ID)
		return;

	auto [appInfo, lock] = gAppListManager->FindAppInfo(mPeerAppId);
	if (!appInfo)
	{
		// 데드락 방지
		lock.~ReadLock();

		auto [newAppInfo, newLock] = gAppListManager->AddAppInfo(
			APP_DATA::Writer(PARAM, TEMP_BUF,
				mPeerAppId,
				mPeerAppType,
				L""
			).GetPacket()
		);

		appInfo = newAppInfo;

		//return;
	}

	if (!appInfo->GetSocket())
		appInfo->SetSocket(GetSocketPtr(), L"HostSocket");
}

bool HostSocket::HasEncryptionKey() const
{
	return (0 == mPeerEncryptionKey) ? false : true;
}

void HostSocket::OnTryEncrypt(uint8_t* buf, int32_t len)
{
	if (0 == mPeerEncryptionKey)
		return;

	OnEncrypt(buf, len, mPeerEncryptionKey);
}
