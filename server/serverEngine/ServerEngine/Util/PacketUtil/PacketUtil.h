// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

#pragma once

#include "Packet/NetworkPacketAutoGenerated/PacketFwd.h"
#include "Packet/PacketFuncs/PacketLogger.h"

#include "ServerEngine/Socket/SocketPtr/SocketPtr.h"
#include "ServerEngine/Worker/WorkerManager.h"
#include "ServerEngine/Util/SocketUtil/SocketUtil.h"


namespace PacketUtil
{
	template <typename NestedPacketType, typename _SocketType, typename DispatchPacketFunc>
	void DispatchNestedPacket(NetworkPacket& rp, _SocketType* socket, DispatchPacketFunc dispatchPacketFunc)
	{
		NestedPacketType& bypassPacket = *reinterpret_cast<NestedPacketType*>(rp.RefPacketBufPtr());

		uint8_t* nestedPacketPtr = const_cast<uint8_t*>(bypassPacket.Get_nestedPacket());

		NetworkPacket* basePacketPtr = reinterpret_cast<NetworkPacket*>(nestedPacketPtr);

		NetworkPacket& basePacket = *basePacketPtr;

#if _PACKET_RECV_LOG
		if (SocketBase::PACKET_RECV_LOG)
			PacketLogger::LogPacket(L"Recv", socket->GetSocketNameW(), socket->GetRawSocket(), basePacket);
#endif

		(socket->*dispatchPacketFunc)(basePacket);
	}

	template <typename _Worker, typename _SocketType, typename _Function, typename... _Args>
	void DispatchPacketOnWorker(std::shared_ptr<_Worker> workerPtr, _SocketType* socket, _Function&& function, NetworkPacket& rp, _Args&&... args)
	{
		SocketPtr<_SocketType> ptr(socket, L"DispatchPacketOnWorker");
		PacketTemp tp(rp);

		if (tThreadId == INVALID_THREAD_ID)
		{	
			WorkerManager::RunAsyncForced(workerPtr, socket, std::forward<_Function>(function), ptr, tp, std::forward<_Args>(args)...);
		}
		else
		{
			WorkerManager::Run(workerPtr, socket, std::forward<_Function>(function), ptr, tp, std::forward<_Args>(args)...);
		}	
	}

	template <typename _SocketType, typename _Function, typename... _Args>
	void DispatchPacketOnAnyThread(_SocketType* socket, _Function&& function, NetworkPacket& rp, _Args&&... args)
	{
		SocketPtr<_SocketType> ptr(socket, L"DispatchPacketOnAnyThread");
		PacketTemp tp(rp);

		WorkerManager::RunOnAnyThread(socket, std::forward<_Function>(function), ptr, tp, std::forward<_Args>(args)...);
	}

	template <typename _SocketType, typename _Function, typename... _Args>
	void DispatchPacketOnThread(ThreadId threadId, _SocketType* socket, _Function&& function, NetworkPacket& rp, _Args&&... args)
	{
		SocketPtr<_SocketType> ptr(socket, L"DispatchPacketOnAnyThread");
		PacketTemp tp(rp);

		WorkerManager::RunOnThread(threadId, socket, std::forward<_Function>(function), ptr, tp, std::forward<_Args>(args)...);
	}

	template <typename _PacketType, typename FromSocket, typename DestSocket>
	void ForwardBypassPacketReq(FromSocket& from, DestSocket& to, NetworkPacket& rp)
	{
		if (to.IsNull())
		{
			// 잠시 후 다시 시도하라고 응답.
			SocketUtil::Send<FC_ERROR::Writer> wp(from, NOTIFY);
			wp.GetHeader().SetPacketResult(Result::RETRY_LATER);
			wp.SetValues(
				rp.GetPacketType()
			);
		}
		else
		{
			SocketUtil::Send<_PacketType> wp(**to, REQ);
			rp.GetHeader().SetRemoteSocketId(gMyAppType, to->MakeRemoteSocketId(&from));
			wp.SetValues(
				rp.GetPacketBufPtr(),
				rp.GetPacketSize()
			);
		}
	}

	template <typename _PacketType, typename FromSocket, typename DestSocket>
	void ForwardBypassPacketNormal(FromSocket& from, DestSocket& to, NetworkPacket& rp)
	{
		if (to.IsNull())
		{
			// 잠시 후 다시 시도하라고 응답.
			SocketUtil::Send<FC_ERROR::Writer> wp(from, NOTIFY);
			wp.GetHeader().SetPacketResult(Result::RETRY_LATER);
			wp.SetValues(
				rp.GetPacketType()
			);
		}
		else
		{
			SocketUtil::Send<_PacketType> wp(**to, REQ);
			wp.GetHeader().SetRemoteSocketId(gMyAppType, to->MakeRemoteSocketId(&from));
			wp.SetValues(
				rp.GetPacketBufPtr(),
				rp.GetPacketSize()
			);
		}
	}
}
