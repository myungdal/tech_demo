// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

import BridgeServer;
import ServerEnginePacketAutoGenerated;


bool SocketBridgeFromFront::OnDispatchPacket(NetworkPacket& rp)
{
	switch (rp.GetPacketType())
	{
	case PacketTypes::FB_REQ_CB_BYPASS:
	{
		// [WHY] FrontServer가 클라이언트 패킷을 bypass로 전달할 때 중첩 패킷을 추출하여 처리
		const FB_REQ_CB_BYPASS& bypassPacket = *reinterpret_cast<const FB_REQ_CB_BYPASS*>(rp.GetPacketBufPtr());
		NetworkPacket& nestedPacket = *const_cast<NetworkPacket*>(reinterpret_cast<const NetworkPacket*>(bypassPacket.Get_nestedPacket()));
		DispatchPacket(nestedPacket);
		break;
	}
	default:
		DispatchPacket(rp);
		break;
	}

	return true;
}

void SocketBridgeFromFront::DispatchPacket(NetworkPacket& rp)
{
	// [WHY] Worker 스레드가 아닌 경우 비동기로 Worker에게 디스패치 위임
	if (tThreadId == INVALID_THREAD_ID)
		PacketUtil::DispatchPacketOnAnyThread(this, &SocketBridgeFromFront::DispatchPacket_async, rp);
	else
		DispatchPacketToHandler(rp);
}

void SocketBridgeFromFront::DispatchPacket_async(MAYBE_UNUSED SocketPtrType& ptr, PacketTemp tp)
{
	DispatchPacket(**tp);
}

void SocketBridgeFromFront::DispatchPacketToHandler(NetworkPacket& rp)
{
	auto DispatchPacketToHandler = [this](auto handler, NetworkPacket& rp)
		{
			if (DispatchPacketCB(mSocket, handler, rp, *this) != HandleResult::NOT_EXISTS) return true;
			if (DispatchPacketFB(mSocket, handler, rp, *this) != HandleResult::NOT_EXISTS) return true;
			return false;
		};

	if (DispatchPacketToHandler(gBridgePacketHandlerAuth.get(), rp)) return;

	// [WHY] 처리되지 않은 패킷은 로그로 기록 (디버깅 용도)
	_DEBUG_LOG(RED, L"{}", GetPacketTypeString(rp.GetPacketType()));
}
