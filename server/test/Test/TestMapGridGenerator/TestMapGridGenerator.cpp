// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

import Test;

#include "TestMapGridGenerator.h"

#include "Common/EnumAutoGenerated/Enum.h"
#include "Common/PCH/pch_world.h"

#include "MmoSync/Map/GridGeneration/DungeonGridGenerator.h"
#include "MmoSync/Map/GridGeneration/FieldGridGenerator.h"
#include "MmoSync/Grid/MultiGrid.h"
#include "MmoSync/Map/Types/MapGenerationSettings.h"
#include "MmoSync/Map/Configuration/DungeonMapConfig.h"
#include "MmoSync/Map/Configuration/FieldMapConfig.h"
#include "MmoSync/Map/Visualization/AsciiConstants.h"
#include "MmoSync/Map/EntityGeneration/CastlePosGenerator.h"
#include "MmoSync/Map/EntityGeneration/NestPosGenerator.h"
#include "MmoSync/Map/Types/AsciiMap.h"
#include "MmoSync/Util/GridUtil/GridUtil.h"
#include "MmoSync/DebugControlTool/DebugInfo.h"

using namespace MmoSync::Map;
using namespace MmoSync::Map::TerrainLevel;
using namespace MmoSync::Map::Special;
using namespace MmoSync::Map::Npc;

// ============================================================================
// Unified ASCII Map Class
// ============================================================================

class AsciiMapPrinter
{
public:
	AsciiMapPrinter(int width, int height, MapKind mapKind,
		std::shared_ptr<MmoSync::Map::Unified::MapTypeRegistry> registry)
		: mWidth(width), mHeight(height), mMapKind(mapKind), mRegistry(registry)
	{
		mMap.resize(height, std::vector<wchar_t>(width, L'.'));
	}

	void SetTerrain(int x, int y, wchar_t terrain)
	{
		if (x >= 0 && x < mWidth && y >= 0 && y < mHeight)
		{
			mMap[y][x] = terrain;
		}
	}

	void SetCastle(int x, int y)
	{
		if (x >= 0 && x < mWidth && y >= 0 && y < mHeight)
		{
			mMap[y][x] = Npc::CASTLE; // Castle
		}
	}

	void SetNest(int x, int y, ItemGrade grade)
	{
		if (x >= 0 && x < mWidth && y >= 0 && y < mHeight)
		{
			if (static_cast<int>(grade) == 0) mMap[y][x] = Npc::NEST0; // Nest
			else if (static_cast<int>(grade) == 1) mMap[y][x] = Npc::NEST1; // Nest
			else if (static_cast<int>(grade) == 2) mMap[y][x] = Npc::NEST2; // Nest
			else if (static_cast<int>(grade) == 3) mMap[y][x] = Npc::NEST3; // Nest
		}
	}

	wchar_t Get(int x, int y) const
	{
		if (x >= 0 && x < mWidth && y >= 0 && y < mHeight)
		{
			return mMap[y][x];
		}

		_DEBUG_RED;
		return Special::UNKNOWN; // Out of bounds
	}

	int GetWidth() const { return mWidth; }
	int GetHeight() const { return mHeight; }
	MapKind GetMapKind() const { return mMapKind; }

	void PrintMap() const
	{
		// Console output removed for performance - only file output is used
		std::wcout << L"Map generated (" << mWidth << "x" << mHeight << ") - saved to file only" << std::endl;
	}

	bool SaveMapToFile(const std::wstring& filename) const
	{
		std::wofstream file(filename);
		if (!file.is_open())
		{
			std::wcout << L"Failed to open file: " << filename << std::endl;
			return false;
		}

		for (int y = 0; y < mHeight; ++y)
		{
			for (int x = 0; x < mWidth; ++x)
			{
				file << mMap[y][x];
			}
			file << std::endl;
		}

		file.close();
		std::wcout << GetMapKindName() << L" asciiMapPrinter saved to: " << filename << std::endl;
		return true;
	}

private:
	int mWidth, mHeight;
	MapKind mMapKind;
	std::vector<std::vector<wchar_t>> mMap;
	std::shared_ptr<MmoSync::Map::Unified::MapTypeRegistry> mRegistry;

	std::wstring GetMapKindName() const
	{
		return mMapKind == MapKind::DUNGEON ? L"Dungeon" : L"Field";
	}

	std::wstring GetLegend() const
	{
		if (mRegistry)
		{
			// Use MapTypeRegistry::GenerateLegend directly (no MapKind needed)
			return mRegistry->GenerateLegend();
		}

		// Fallback: Return empty legend if registry is not available
		return L"No legend available";
	}
};


// ============================================================================
// TestMapGridGenerator Implementation
// ============================================================================

TestMapGridGenerator::TestMapGridGenerator(long appArg)
	: TestAppBase(appArg)
{
}

void TestMapGridGenerator::OnInitialize(CommandDispatcherWithResult<std::wstring>& /*dispatcher*/)
{
	// Initialize test
}

void TestMapGridGenerator::OnStarted()
{
	std::wcout << L"TestMapGridGenerator::OnStarted() called" << std::endl;

	std::vector<std::wstring> dungeonFiles;
	std::vector<std::wstring> fieldFiles;

	RunDungeonDemo(dungeonFiles);
	std::wcout << L"\n" << std::wstring(50, L'=') << std::endl;
	RunFieldDemo(fieldFiles);

	PrintStatistics(L"Dungeon", dungeonFiles);
	PrintStatistics(L"Field", fieldFiles);
}

void TestMapGridGenerator::OnUpdate()
{
	// Update test
}

void TestMapGridGenerator::RunDungeonDemo(std::vector<std::wstring>& outFiles)
{
	const uint8_t DEFAULT_MAP_GRID_FACTOR = static_cast<uint8_t>(DebugInfo::DEFAULT_MAP_GRID_FACTOR);
	const int DEFAULT_MAP_CASTLE_CNT = DebugInfo::DEFAULT_MAP_CASTLE_CNT;
	const int DEFAULT_MAP_NEST_CNT = DebugInfo::DEFAULT_MAP_NEST_CNT;

	std::wcout << L"=== Dungeon Map Generator Demo ===" << std::endl;
	std::wcout << L"Generating dungeon asciiMapPrinter (console output disabled for performance)..." << std::endl;

	try
	{
		// Create output directory if it doesn't exist
		std::filesystem::create_directories("../../output/ascii_map");

		for (int mapIndex = 0; mapIndex < 100; ++mapIndex)
		{
			DungeonMapConfig dungeonConfig;
			dungeonConfig.mGridColCountFactor = DEFAULT_MAP_GRID_FACTOR;
			dungeonConfig.mGridRowCountFactor = DEFAULT_MAP_GRID_FACTOR;
			dungeonConfig.mRandomSeed = mapIndex;
			MapConfig mapConfig(dungeonConfig);

			auto settings = std::make_unique<MapGenerationSettings>();
			settings->SetMapKind(MapKind::DUNGEON);
			settings->mapConfig = mapConfig;
			settings->entitySettings.castleCount = DEFAULT_MAP_CASTLE_CNT;
			settings->entitySettings.nestCount = DEFAULT_MAP_NEST_CNT;

			MultiGrid multiGrid(
				dungeonConfig.mGridColCountFactor, 
				dungeonConfig.mGridRowCountFactor
			);

			auto generator = std::make_unique<DungeonGridGenerator>(settings->mapConfig);
			auto asciiMap = generator->CreateMultiGrid(multiGrid, *settings);

			auto registry = std::make_shared<MmoSync::Map::Unified::MapTypeRegistry>();
			auto asciiMapPrinter = std::make_unique<AsciiMapPrinter>(asciiMap->Width(), asciiMap->Height(), MapKind::DUNGEON, registry);

			int wallCount = 0;
			int floorCount = 0;
			int startCount = 0;
			int exitCount = 0;
			for (int y = 0; y < asciiMap->Height(); ++y)
			{
				for (int x = 0; x < asciiMap->Width(); ++x)
				{
					wchar_t tile = asciiMap->Get(x, y);
					if (tile == LEVEL0)
					{
						
						floorCount++;
					}
					else if (tile == LEVEL1)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL1);
						floorCount++;
					}
					else if (tile == LEVEL2)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL2);
						floorCount++;
					}
					else if (tile == LEVEL3)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL3);
						floorCount++;
					}
					else if (tile == LEVEL4)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL4);
						wallCount++;
					}
					else if (tile == LEVEL5)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL5);
						wallCount++;
					}
					else if (tile == LEVEL6)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL6);
						wallCount++;
					}
					else if (tile == LEVEL7)
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL7);
						wallCount++;
					}
					else if (tile == Special::START)
					{
						asciiMapPrinter->SetTerrain(x, y, Special::START);
						floorCount++;
						startCount++;
					}
					else if (tile == Special::EXIT)
					{
						asciiMapPrinter->SetTerrain(x, y, Special::EXIT);
						floorCount++;
						exitCount++;
					}
					else
					{
						asciiMapPrinter->SetTerrain(x, y, LEVEL0);
						floorCount++;
					}
				}
			}

			std::wcout << L"Dungeon stats: Walls = " << wallCount << L", Floors = " << floorCount
				<< L", Start Points = " << startCount << L", Exit Points = " << exitCount << std::endl;

			// Generate entity positions directly using CastlePosGenerator and NestPosGenerator (test only position generation logic)
			std::deque<ColRowPair> posList;

			// Generate Castle positions
			if (settings->entitySettings.castleCount > 0)
			{
				auto castlePosGenerator = std::make_unique<CastlePosGenerator>(multiGrid, posList);
				castlePosGenerator->InitCastlePositions(settings->entitySettings.castleCount, *asciiMap, mapConfig.GetSeed());
				const auto& castlePositions = castlePosGenerator->GetCastlePositions();

				for (const auto& position : castlePositions)
				{
					int mapX = static_cast<int>(position.first);
					int mapY = static_cast<int>(position.second);
					if (mapX >= 0 && mapX < asciiMapPrinter->GetWidth() && mapY >= 0 && mapY < asciiMapPrinter->GetHeight())
						asciiMapPrinter->SetCastle(mapX, mapY);
				}
			}

			// Generate Nest positions
			if (settings->entitySettings.nestCount > 0)
			{
				auto nestPosGenerator = std::make_unique<NestPosGenerator>(multiGrid, posList);
				nestPosGenerator->InitNestPositions(settings->entitySettings.nestCount, *asciiMap, mapConfig.GetSeed());
				const auto& nestPositions = nestPosGenerator->GetNestPositions();

				for (const auto& position : nestPositions)
				{
					const ColRowPair cell = std::get<0>(position);
					const ItemGrade grade = std::get<1>(position);
					int mapX = static_cast<int>(cell.first);
					int mapY = static_cast<int>(cell.second);
					if (mapX >= 0 && mapX < asciiMapPrinter->GetWidth() && mapY >= 0 && mapY < asciiMapPrinter->GetHeight())
						asciiMapPrinter->SetNest(mapX, mapY, grade);
				}
			}

			// Map ready for file output

			// Basic validation
			std::wcout << L"\nDungeon Map " << mapIndex << " Generated Successfully:" << std::endl;
			std::wcout << L"  Size: " << asciiMapPrinter->GetWidth() << "x" << asciiMapPrinter->GetHeight() << std::endl;

			// Generate filename
			std::wstringstream filename;
			filename << L"../../output/ascii_map/dungeon_map_";
			if (mapIndex < 10) filename << L"0";
			filename << mapIndex << L".txt";

			// Save asciiMapPrinter with proper error handling
			if (asciiMapPrinter->SaveMapToFile(filename.str()))
			{
				std::wcout << L"  Map saved: " << filename.str() << std::endl;
				outFiles.push_back(filename.str());
			}
			else
			{
				std::wcout << L"  ERROR: Failed to save map file: " << filename.str() << std::endl;
			}
		}
	}
	catch (const std::exception& e)
	{
		std::wcout << L"Exception in RunDungeonDemo: " << e.what() << std::endl;
	}
}

void TestMapGridGenerator::RunFieldDemo(std::vector<std::wstring>& outFiles)
{
	const uint8_t DEFAULT_MAP_GRID_FACTOR = static_cast<uint8_t>(DebugInfo::DEFAULT_MAP_GRID_FACTOR);
	const int DEFAULT_MAP_CASTLE_CNT = DebugInfo::DEFAULT_MAP_CASTLE_CNT;
	const int DEFAULT_MAP_NEST_CNT = DebugInfo::DEFAULT_MAP_NEST_CNT;

	std::wcout << L"=== Field Map Generator Demo ===" << std::endl;
	std::wcout << L"Generating field asciiMapPrinter (console output disabled for performance)..." << std::endl;

	try
	{
		// Create output directory if it doesn't exist
		std::filesystem::create_directories("../../output/ascii_map");

		for (int mapIndex = 0; mapIndex < 100; ++mapIndex)
		{
			FieldMapConfig fieldConfig;
			fieldConfig.mGridColCountFactor = DEFAULT_MAP_GRID_FACTOR;
			fieldConfig.mGridRowCountFactor = DEFAULT_MAP_GRID_FACTOR;
			fieldConfig.mRandomSeed = static_cast<uint64_t>(mapIndex);
			MapConfig mapConfig(fieldConfig);

			auto settings = std::make_unique<MapGenerationSettings>();
			settings->SetMapKind(MapKind::FIELD);
			settings->mapConfig = mapConfig;
			settings->entitySettings.castleCount = DEFAULT_MAP_CASTLE_CNT;
			settings->entitySettings.nestCount = DEFAULT_MAP_NEST_CNT;

			MultiGrid multiGrid(
				fieldConfig.mGridColCountFactor, 
				fieldConfig.mGridRowCountFactor
			);

			auto generator = std::make_unique<FieldGridGenerator>(settings->mapConfig);
			auto asciiMap = generator->CreateMultiGrid(multiGrid, *settings);

			auto registry = std::make_shared<MmoSync::Map::Unified::MapTypeRegistry>();
			auto asciiMapPrinter = std::make_unique<AsciiMapPrinter>(asciiMap->Width(), asciiMap->Height(), MapKind::FIELD, registry);

			for (int y = 0; y < asciiMap->Height(); ++y)
			{
				for (int x = 0; x < asciiMap->Width(); ++x)
				{
					wchar_t tile = asciiMap->Get(x, y);
					asciiMapPrinter->SetTerrain(x, y, tile);
				}
			}

			// Generate entity positions directly using CastlePosGenerator and NestPosGenerator (test only position generation logic)
			std::deque<ColRowPair> posList;

			// Generate Castle positions
			if (settings->entitySettings.castleCount > 0)
			{
				auto castlePosGenerator = std::make_unique<CastlePosGenerator>(multiGrid, posList);
				castlePosGenerator->InitCastlePositions(settings->entitySettings.castleCount, *asciiMap, mapConfig.GetSeed());
				const auto& castlePositions = castlePosGenerator->GetCastlePositions();

				for (const auto& position : castlePositions)
				{
					int mapX = static_cast<int>(position.first);
					int mapY = static_cast<int>(position.second);
					if (mapX >= 0 && mapX < asciiMapPrinter->GetWidth() && mapY >= 0 && mapY < asciiMapPrinter->GetHeight())
						asciiMapPrinter->SetCastle(mapX, mapY);
				}
			}

			// Generate Nest positions
			if (settings->entitySettings.nestCount > 0)
			{
				auto nestPosGenerator = std::make_unique<NestPosGenerator>(multiGrid, posList);
				nestPosGenerator->InitNestPositions(settings->entitySettings.nestCount, *asciiMap, mapConfig.GetSeed());
				const auto& nestPositions = nestPosGenerator->GetNestPositions();

				for (const auto& position : nestPositions)
				{
					const ColRowPair cell = std::get<0>(position);
					const ItemGrade grade = std::get<1>(position);
					int mapX = static_cast<int>(cell.first);
					int mapY = static_cast<int>(cell.second);
					if (mapX >= 0 && mapX < asciiMapPrinter->GetWidth() && mapY >= 0 && mapY < asciiMapPrinter->GetHeight())
						asciiMapPrinter->SetNest(mapX, mapY, grade);
				}
			}

			// Save asciiMapPrinter (console output removed for performance)
			asciiMapPrinter->PrintMap();

			// Use unified system for analysis
			// Basic validation
			std::wcout << L"\nField Map " << mapIndex << " Generated Successfully:" << std::endl;
			std::wcout << L"  Size: " << asciiMapPrinter->GetWidth() << "x" << asciiMapPrinter->GetHeight() << std::endl;

			// Generate filename
			// If using sequential seed (0, 1, 2...), seed equals mapIndex, so no need to add seed to filename
			std::wstringstream filename;
			filename << L"../../output/ascii_map/field_map_";
			if (mapIndex < 10) filename << L"0";
			filename << mapIndex << L".txt";

			if (asciiMapPrinter->SaveMapToFile(filename.str()))
			{
				std::wcout << L"  Map saved: " << filename.str() << std::endl;
				outFiles.push_back(filename.str());
			}
		}
	}
	catch (const std::exception& e)
	{
		std::wcout << L"Exception in RunFieldDemo: " << e.what() << std::endl;
	}
}

void TestMapGridGenerator::PrintStatistics(const std::wstring& mapType, const std::vector<std::wstring>& mapFiles)
{
	std::wcout << L"\n=== " << mapType << L" Map Statistics ===" << std::endl;

	// Generate output filename
	std::wstringstream statsFilename;
	statsFilename << L"../../output/ascii_map/" << mapType << L"_statistics.txt";

	std::wofstream statsFile(statsFilename.str());
	if (!statsFile.is_open())
	{
		std::wcout << L"Failed to create statistics file: " << statsFilename.str() << std::endl;
		return;
	}

	statsFile << mapType << L" Map Statistics" << std::endl;
	statsFile << std::wstring(50, L'=') << std::endl;
	statsFile << std::endl;

	int totalMaps = 0;

	// Collect all individual values across all maps
	std::vector<int> allStartCounts;
	std::vector<int> allExitCounts;
	std::vector<int> allLevel0Counts;
	std::vector<int> allLevel1Counts;
	std::vector<int> allLevel2Counts;
	std::vector<int> allLevel3Counts;
	std::vector<int> allLevel4PlusCounts;
	std::vector<int> allCastleCounts;
	std::vector<int> allNest0Counts;
	std::vector<int> allNest1Counts;
	std::vector<int> allNest2Counts;
	std::vector<int> allNest3Counts;
	std::vector<int> allNest4Counts;
	std::vector<double> allFloorRatios;
	std::vector<double> allWallRatios;

	// Collect all distances across all maps
	std::vector<int> allStartToStartDistances;
	std::vector<int> allStartToExitDistances;

	// Analyze each map file
	for (const auto& filename : mapFiles)
	{
		std::wifstream file(filename);
		if (!file.is_open())
		{
			continue;
		}

		std::vector<std::wstring> lines;
		std::wstring line;
		while (std::getline(file, line))
		{
			lines.push_back(line);
		}
		file.close();

		if (lines.empty())
		{
			continue;
		}

		int height = static_cast<int>(lines.size());
		int width = static_cast<int>(lines[0].length());
		int totalTiles = height * width;

		// Count tiles
		int startCount = 0;
		int exitCount = 0;
		int level0Count = 0;
		int level1Count = 0;
		int level2Count = 0;
		int level3Count = 0;
		int level4PlusCount = 0; // Wall
		int floorCount = 0; // 0, 1, 2, 3
		int wallCount = 0; // 4 이상

		// NPC counts
		int castleCount = 0;
		int nest0Count = 0;
		int nest1Count = 0;
		int nest2Count = 0;
		int nest3Count = 0;
		int nest4Count = 0;

		std::vector<std::pair<int, int>> startPositions;
		std::pair<int, int> exitPos(-1, -1);

		for (int y = 0; y < height; ++y)
		{
			for (int x = 0; x < width && x < static_cast<int>(lines[y].length()); ++x)
			{
				wchar_t tile = lines[y][x];

				if (tile == Special::START)
				{
					startCount++;
					startPositions.push_back({ x, y });
				}
				else if (tile == Special::EXIT)
				{
					exitCount++;
					exitPos = { x, y };
				}
				else if (tile == LEVEL0)
				{
					level0Count++;
					floorCount++;
				}
				else if (tile == LEVEL1)
				{
					level1Count++;
					floorCount++;
				}
				else if (tile == LEVEL2)
				{
					level2Count++;
					floorCount++;
				}
				else if (tile == LEVEL3)
				{
					level3Count++;
					floorCount++;
				}
				else if (tile == Npc::CASTLE)
				{
					castleCount++;
					wallCount++;
				}
				else if (tile == Npc::NEST0)
				{
					nest0Count++;
					wallCount++;
				}
				else if (tile == Npc::NEST1)
				{
					nest1Count++;
					wallCount++;
				}
				else if (tile == Npc::NEST2)
				{
					nest2Count++;
					wallCount++;
				}
				else if (tile == Npc::NEST3)
				{
					nest3Count++;
					wallCount++;
				}
				else if (tile == Npc::NEST4)
				{
					nest4Count++;
					wallCount++;
				}
				else if (tile == LEVEL4 || tile == LEVEL5 || tile == LEVEL6 || tile == LEVEL7)
				{
					// LEVEL4 이상의 지형 (wchar_t와 TerrainLevel 상수는 ASCII 값이므로 직접 비교하면 안 됨)
					level4PlusCount++;
					wallCount++;
				}
				else
				{
					// Treat other unknown tiles as walls
					wallCount++;
				}
			}
		}

		// Calculate distances
		std::vector<int> startToStartDistances;
		std::vector<int> startToExitDistances;

		// Between START positions
		for (size_t i = 0; i < startPositions.size(); ++i)
		{
			for (size_t j = i + 1; j < startPositions.size(); ++j)
			{
				int dx = startPositions[i].first - startPositions[j].first;
				int dy = startPositions[i].second - startPositions[j].second;
				int dist = std::abs(dx) + std::abs(dy); // Manhattan distance
				startToStartDistances.push_back(dist);
			}
		}

		// Between START and EXIT
		if (exitPos.first >= 0 && !startPositions.empty())
		{
			for (const auto& startPos : startPositions)
			{
				int dx = startPos.first - exitPos.first;
				int dy = startPos.second - exitPos.second;
				int dist = std::abs(dx) + std::abs(dy);
				startToExitDistances.push_back(dist);
			}
		}

		// Calculate START to START distance statistics
		int startToStartMin = 0, startToStartMax = 0;
		double startToStartAvg = 0.0;
		if (!startToStartDistances.empty())
		{
			startToStartMin = *std::min_element(startToStartDistances.begin(), startToStartDistances.end());
			startToStartMax = *std::max_element(startToStartDistances.begin(), startToStartDistances.end());
			double sum = 0;
			for (int dist : startToStartDistances)
				sum += dist;
			startToStartAvg = sum / startToStartDistances.size();
		}

		// Calculate START to EXIT distance statistics
		int startToExitMin = 0, startToExitMax = 0;
		double startToExitAvg = 0.0;
		if (!startToExitDistances.empty())
		{
			startToExitMin = *std::min_element(startToExitDistances.begin(), startToExitDistances.end());
			startToExitMax = *std::max_element(startToExitDistances.begin(), startToExitDistances.end());
			double sum = 0;
			for (int dist : startToExitDistances)
				sum += dist;
			startToExitAvg = sum / startToExitDistances.size();
		}

		// Calculate ratios
		double floorRatio = static_cast<double>(floorCount) / totalTiles * 100.0;
		double wallRatio = static_cast<double>(wallCount) / totalTiles * 100.0;

		// Write statistics for this map
		statsFile << L"Filename: " << filename << std::endl;
		statsFile << L"  Size: " << width << L"x" << height << std::endl;
		statsFile << L"  START count: " << startCount << std::endl;
		statsFile << L"  EXIT count: " << exitCount << std::endl;
		statsFile << L"  LEVEL0 count: " << level0Count << std::endl;
		statsFile << L"  LEVEL1 count: " << level1Count << std::endl;
		statsFile << L"  LEVEL2 count: " << level2Count << std::endl;
		statsFile << L"  LEVEL3 count: " << level3Count << std::endl;
		statsFile << L"  LEVEL4+ count: " << level4PlusCount << std::endl;
		statsFile << L"  CASTLE count: " << castleCount << std::endl;
		statsFile << L"  NEST0 count: " << nest0Count << std::endl;
		statsFile << L"  NEST1 count: " << nest1Count << std::endl;
		statsFile << L"  NEST2 count: " << nest2Count << std::endl;
		statsFile << L"  NEST3 count: " << nest3Count << std::endl;
		statsFile << L"  NEST4 count: " << nest4Count << std::endl;
		statsFile << L"  START to START - Min distance: " << startToStartMin << std::endl;
		statsFile << L"  START to START - Max distance: " << startToStartMax << std::endl;
		statsFile << L"  START to START - Avg distance: " << startToStartAvg << std::endl;
		statsFile << L"  START to EXIT - Min distance: " << startToExitMin << std::endl;
		statsFile << L"  START to EXIT - Max distance: " << startToExitMax << std::endl;
		statsFile << L"  START to EXIT - Avg distance: " << startToExitAvg << std::endl;
		statsFile << L"  Floor ratio (%): " << floorRatio << std::endl;
		statsFile << L"  Wall ratio (%): " << wallRatio << std::endl;
		statsFile << std::endl;

		// Collect individual values from each map
		allStartCounts.push_back(startCount);
		allExitCounts.push_back(exitCount);
		allLevel0Counts.push_back(level0Count);
		allLevel1Counts.push_back(level1Count);
		allLevel2Counts.push_back(level2Count);
		allLevel3Counts.push_back(level3Count);
		allLevel4PlusCounts.push_back(level4PlusCount);
		allCastleCounts.push_back(castleCount);
		allNest0Counts.push_back(nest0Count);
		allNest1Counts.push_back(nest1Count);
		allNest2Counts.push_back(nest2Count);
		allNest3Counts.push_back(nest3Count);
		allNest4Counts.push_back(nest4Count);
		allFloorRatios.push_back(floorRatio);
		allWallRatios.push_back(wallRatio);

		// Collect all distances
		allStartToStartDistances.insert(allStartToStartDistances.end(), startToStartDistances.begin(), startToStartDistances.end());
		allStartToExitDistances.insert(allStartToExitDistances.end(), startToExitDistances.begin(), startToExitDistances.end());

		totalMaps++;
	}

	statsFile << L"Total maps analyzed: " << totalMaps << std::endl;
	statsFile << std::endl;

	// Print aggregated statistics
	statsFile << L"=== Overall Statistics ===" << std::endl;
	statsFile << std::endl;

	// Helper lambda to print min/max/avg statistics
	auto printStats = [&statsFile](const std::wstring& name, const std::vector<int>& values) {
		if (values.empty()) return;
		int min = *std::min_element(values.begin(), values.end());
		int max = *std::max_element(values.begin(), values.end());
		double avg = 0.0;
		for (int val : values) avg += val;
		avg /= values.size();

		statsFile << L"  " << name << ":" << std::endl;
		statsFile << L"    Min: " << min << std::endl;
		statsFile << L"    Max: " << max << std::endl;
		statsFile << L"    Avg: " << avg << std::endl;
		};

	auto printStatsDouble = [&statsFile](const std::wstring& name, const std::vector<double>& values) {
		if (values.empty()) return;
		double min = *std::min_element(values.begin(), values.end());
		double max = *std::max_element(values.begin(), values.end());
		double avg = 0.0;
		for (double val : values) avg += val;
		avg /= values.size();

		statsFile << L"  " << name << ":" << std::endl;
		statsFile << L"    Min: " << min << std::endl;
		statsFile << L"    Max: " << max << std::endl;
		statsFile << L"    Avg: " << avg << std::endl;
		};

	printStats(L"START count", allStartCounts);
	printStats(L"EXIT count", allExitCounts);
	printStats(L"LEVEL0 count", allLevel0Counts);
	printStats(L"LEVEL1 count", allLevel1Counts);
	printStats(L"LEVEL2 count", allLevel2Counts);
	printStats(L"LEVEL3 count", allLevel3Counts);
	printStats(L"LEVEL4+ count", allLevel4PlusCounts);
	printStats(L"CASTLE count", allCastleCounts);
	printStats(L"NEST0 count", allNest0Counts);
	printStats(L"NEST1 count", allNest1Counts);
	printStats(L"NEST2 count", allNest2Counts);
	printStats(L"NEST3 count", allNest3Counts);
	printStats(L"NEST4 count", allNest4Counts);
	printStatsDouble(L"Floor ratio (%)", allFloorRatios);
	printStatsDouble(L"Wall ratio (%)", allWallRatios);

	statsFile << std::endl;

	// Calculate overall statistics from all distances
	if (!allStartToStartDistances.empty())
	{
		int overallMin = *std::min_element(allStartToStartDistances.begin(), allStartToStartDistances.end());
		int overallMax = *std::max_element(allStartToStartDistances.begin(), allStartToStartDistances.end());
		double overallAvg = 0.0;
		for (int dist : allStartToStartDistances)
			overallAvg += dist;
		overallAvg /= allStartToStartDistances.size();

		statsFile << L"Overall START to START distances (all pairs):" << std::endl;
		statsFile << L"  Min: " << overallMin << std::endl;
		statsFile << L"  Max: " << overallMax << std::endl;
		statsFile << L"  Avg: " << overallAvg << std::endl;
		statsFile << L"  Total pairs: " << allStartToStartDistances.size() << std::endl;
		statsFile << std::endl;
	}

	if (!allStartToExitDistances.empty())
	{
		int overallMin = *std::min_element(allStartToExitDistances.begin(), allStartToExitDistances.end());
		int overallMax = *std::max_element(allStartToExitDistances.begin(), allStartToExitDistances.end());
		double overallAvg = 0.0;
		for (int dist : allStartToExitDistances)
			overallAvg += dist;
		overallAvg /= allStartToExitDistances.size();

		statsFile << L"Overall START to EXIT distances (all pairs):" << std::endl;
		statsFile << L"  Min: " << overallMin << std::endl;
		statsFile << L"  Max: " << overallMax << std::endl;
		statsFile << L"  Avg: " << overallAvg << std::endl;
		statsFile << L"  Total pairs: " << allStartToExitDistances.size() << std::endl;
		statsFile << std::endl;
	}

	statsFile.close();

	std::wcout << L"Statistics saved to: " << statsFilename.str() << std::endl;
	std::wcout << L"Total maps analyzed: " << totalMaps << std::endl;
}
