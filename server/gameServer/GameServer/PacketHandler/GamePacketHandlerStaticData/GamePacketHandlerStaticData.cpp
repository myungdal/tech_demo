// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

import GameServer;
import ServerEnginePacket;
import ServerEnginePacketAutoGenerated;

#include "MmoSync/Engine/Engine.h"


void GamePacketHandlerStaticData::SendReqStaticDataChecksum_timer(SocketPtr<SocketGameToDb>& socket)
{
	gStaticDataCatalog->ResetSync();
	gStaticDataCatalog->SetSyncing();

	// DB서버와 연결되면, 정적데이터 체크섬 요청
	SocketUtil::Send<GD_REQ_STATIC_DATA_CHECKSUM::Writer> wp(**socket, REQ);
}

void GamePacketHandlerStaticData::SendReqStaticData(SocketGameToDb& socket)
{
	auto [succeeded, index] = gStaticDataCatalog->BuildDataForGameServer();

	// 데이터가 일치하지 않으면 데이터 요청
	if (false == succeeded)
	{
		_ASSERT_CRASH(INVALID_STATIC_DATA_INDEX != index);
		SocketUtil::Send<GD_REQ_STATIC_DATA::Writer> wp(socket, REQ);
		wp.SetValues(index);
	}
	else
	{		
		// DB 정적 데이터 로딩 완료,
		gStaticDataAccessor = std::make_shared<StaticDataAccessor>();
		gStaticDataAccessor->BuildView();
		gStaticDataCatalog->SetSynced();

		if (Engine::GetDebugStepCount() != -1)
		{
			// 디버그 중이라면, 게임들에 WorldData를 재구성하게 한다
			gGameChannelManager->RunToAllGameChannel(&GameChannel::LoadDebugDbData);
		}
		else
		{
			// 디버그 중이 아니고, 처음 받아온 것이라면, Main서버에 준비 되었다고 알려주고 기본적인 게임들을 생성 요청받게 된다
			SocketUtil::Send<GM_GAME_SERVER_READY::Writer> wp(*gSocketGameToMain, NOTIFY);
		}
	}
}

// 정적데이터 체크섬 응답 받음
HandleResult GamePacketHandlerStaticData::OnPacket(DG_ACK_STATIC_DATA_CHECKSUM& rp, MAYBE_UNUSED SocketGameToDb& socket)
{
	const Result result = rp.GetHeader().GetPacketResult();

	switch (result)
	{
	case Result::SUCCEEDED:
	{
		const size_t listSize0 = rp.Get_checksumList_size();
		//const size_t listSize1 = rp.Get_staticDataSizeList_size();
		const StaticDataSize* srcSizeList = rp.Get_staticDataSizeList();
		const Checksum* srcChecksumList = rp.Get_checksumList();

		gStaticDataCatalog->ExpectedChecksumForGameServer() = rp.Get_staticDataChecksum();
		gStaticDataCatalog->ExpectedSizeList().resize(listSize0, 0);
		gStaticDataCatalog->ExpectedChecksumList().resize(listSize0, {});
		gStaticDataCatalog->BinaryList().resize(listSize0, nullptr);

		for (size_t i = 0; i < listSize0; ++i)
		{
			if ((gStaticDataCatalog->ExpectedSizeList().at(i) == srcSizeList[i]) &&
				(gStaticDataCatalog->ExpectedChecksumList().at(i) == srcChecksumList[i]))
			{
				continue;
			}

			gStaticDataCatalog->ExpectedSizeList().at(i) = srcSizeList[i];
			gStaticDataCatalog->ExpectedChecksumList().at(i) = srcChecksumList[i];

			if (gStaticDataCatalog->BinaryList().at(i))
			{
				_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
				gStaticDataCatalog->BinaryList().at(i) = nullptr;
			}
		}

		SendReqStaticData(socket);

		break;
	}
	default:
	{
		// DB서버의 상태가 준비되지 않았다면, 다시 시도.
		SocketPtr<SocketGameToDb> ptr(&socket, L"SendReqStaticDataChecksum_timer");	
		WorkerManager::RunOnTimer(RETRY_DELAY, gTimerWorker->GetTimerWorker(), this, &GamePacketHandlerStaticData::SendReqStaticDataChecksum_timer, ptr);

		break;
	}
	}

	return HandleResult::OK;
}

// 정적데이터 응답 받음
HandleResult GamePacketHandlerStaticData::OnPacket(DG_ACK_STATIC_DATA& rp, MAYBE_UNUSED SocketGameToDb& socket)
{
	const Result result = rp.GetHeader().GetPacketResult();
	switch (result)
	{
	case Result::SUCCEEDED:
	{
		const StaticDataIndex i = rp.Get_index();
		const uint8_t* srcBin = rp.Get_staticDataBin();
		const StaticDataSize srcOffset = rp.Get_offset();
		const PacketSize srcSize = rp.Get_staticDataBin_size();

		_ASSERT_CRASH(gStaticDataCatalog->BinaryList().size() > static_cast<size_t>(i));

		if (gStaticDataCatalog->BinaryList().at(i))
		{
			_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
			gStaticDataCatalog->BinaryList().at(i) = nullptr;
		}

		gStaticDataCatalog->ExpectedSizeList().at(i) = srcSize;

		if (srcSize > 0)
		{
			gStaticDataCatalog->BinaryList().at(i) = _MALLOC<uint8_t>(srcSize);
			std::copy_n(srcBin, srcSize, gStaticDataCatalog->BinaryList().at(i) + srcOffset);
		}

		// 완료되었으면, 다음 StaticData 요청.
		if (1 == rp.Get_isCompleted())
		{
			SendReqStaticData(socket);
		}

		break;
	}
	default:
	{
		// 치명적 실패
		_DEBUG_LOG(RED, L"{}", result);
		_ASSERT_CRASH(false);

		break;
	}
	}

	return HandleResult::OK;
}

