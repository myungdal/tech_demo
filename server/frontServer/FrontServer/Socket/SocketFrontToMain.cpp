// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

import FrontServer;
import ServerEnginePacketAutoGenerated;


SocketFrontToMain::SocketFrontToMain()
{
	mCommandDispatcher.Register(
		L"help", L"도움말",
		std::bind(&SocketFrontToMain::OnCommand_help, this, std::placeholders::_1)
	);
	mCommandDispatcher.Register(
		L"disconnect", L"네트워크 연결 끊기",
		std::bind(&SocketFrontToMain::OnCommand_disconnect, this, std::placeholders::_1)
	);
}
void SocketFrontToMain::OnAppAdded(IN OUT AppInfo& appInfo)
{
	if (AppType::DB_SERVER == appInfo.GetData().Get_appType())
	{	
		SocketFrontToDb* socketFrontToDb = _NEW<SocketFrontToDb>();
		socketFrontToDb->SetIocp(mIocp);
		socketFrontToDb->Connect(
			appInfo.GetData().Get_ip(),
			gAppConfigManager->GetVariableNum<uint16_t>(L"PORT_FD"), 
			gFrontServerApp->GetMyAppId(),
			gFrontServerApp->GetMyAppType(),
			appInfo.GetData().Get_appId(),
			appInfo.GetData().Get_appType()
		);

		appInfo.SetSocket(socketFrontToDb->GetSocketPtr(), L"OnAppAdded");
	}
	else if (AppType::BRIDGE_SERVER == appInfo.GetData().Get_appType())
	{
		SocketFrontToBridge* socketFrontToBridge = _NEW<SocketFrontToBridge>();
		socketFrontToBridge->SetIocp(mIocp);
		socketFrontToBridge->Connect(
			appInfo.GetData().Get_ip(),
			gAppConfigManager->GetVariableNum<uint16_t>(L"PORT_FB"), 
			gFrontServerApp->GetMyAppId(),
			gFrontServerApp->GetMyAppType(),
			appInfo.GetData().Get_appId(),
			appInfo.GetData().Get_appType()
		);

		appInfo.SetSocket(socketFrontToBridge->GetSocketPtr(), L"OnAppAdded");
	}
	else if (AppType::GAME_SERVER == appInfo.GetData().Get_appType())
	{
		SocketFrontToGame* socketFrontToGame = _NEW<SocketFrontToGame>();
		socketFrontToGame->SetIocp(mIocp);
		socketFrontToGame->Connect(
			appInfo.GetData().Get_ip(),
			gAppConfigManager->GetVariableNum<uint16_t>(L"PORT_FG"), 
			gFrontServerApp->GetMyAppId(),
			gFrontServerApp->GetMyAppType(),
			appInfo.GetData().Get_appId(),
			appInfo.GetData().Get_appType()
		);

		appInfo.SetSocket(socketFrontToGame->GetSocketPtr(), L"OnAppAdded");
	}
}

std::wstring SocketFrontToMain::OnShellCommand(const wchar_t* command)
{
	SHELL_NOTIFY::Writer wp(NOTIFY, TEMP_BUF);
	wp.SetValues(
		command
	);

	// 모든 유저들에게 쉘 명령 전달
	gFrontDataManager->ForEachUser(
		[&wp](FrontUserPtr& frontUser)
		{
			if (auto socketFromClient = frontUser->GetClientSocket())
			{
				// 암호화를 위해 세션 별 패킷 생성
				SocketUtil::Send<NetworkPacketWriter> wpEachUser(**socketFromClient);
				std::copy_n(wp.GetPacketBufPtr(), wp.GetPacketSize(), wpEachUser.GetPacketBufPtr());
			}
		}
	);

	return mCommandDispatcher.Dispatch(command);
}

std::wstring SocketFrontToMain::OnCommand_help(MAYBE_UNUSED ArgList& argList)
{
	std::wstring result;
	result += L"\n";
	result += L"* GameServer 명령:\n";
	for (const auto& [key, handler] : mCommandDispatcher.GetHandlerMap())
	{
		result += L"\t";
		result += std::get<0>(handler);
		result += L"\t";
		result += std::get<1>(handler);
		result += L"\n";
	}
	result += L"\n";
	return result;
}

std::wstring SocketFrontToMain::OnCommand_disconnect(MAYBE_UNUSED ArgList& argList)
{
	gFrontDataManager->ForEachUser(
		[](FrontUserPtr& frontUser)
		{
			if (auto socketFromClient = frontUser->GetClientSocket())
			{
				socketFromClient->Disconnect();
			}
		}
	);

	return L"OK\n";
}

bool SocketFrontToMain::OnDispatchPacket(NetworkPacket& rp)
{
	DispatchPacket(rp);
	return true;
}

void SocketFrontToMain::DispatchPacket(NetworkPacket& rp)
{
	switch (rp.GetPacketType())
	{
	case PacketTypes::MF_ROOM_USER_ENTER:
	case PacketTypes::MF_ROOM_USER_LEAVE:
		PacketUtil::DispatchPacketOnWorker(gFrontDataManager, this, &SocketFrontToMain::DispatchPacket_async, rp);
		break;
	default:
		if (tThreadId == INVALID_THREAD_ID)
			PacketUtil::DispatchPacketOnAnyThread(this, &SocketFrontToMain::DispatchPacket_async, rp);
		else
			DispatchPacketToHandler(rp);
		break;
	}
}

void SocketFrontToMain::DispatchPacket_async(MAYBE_UNUSED SocketPtrType& ptr, PacketTemp tp)
{
	DispatchPacketToHandler(**tp);
}

void SocketFrontToMain::DispatchPacketToHandler(NetworkPacket& rp)
{
	auto DispatchPacketToHandler = [this](auto handler, NetworkPacket& rp)
		{
			if (DispatchPacketMC(mSocket, handler, rp, *this) != HandleResult::NOT_EXISTS) return true;
			if (DispatchPacketMF(mSocket, handler, rp, *this) != HandleResult::NOT_EXISTS) return true;
			return false;
		};

	if (DispatchPacketToHandler(gFrontPacketHandlerSystem.get(), rp)) return;

	if (DispatchPacketMF<MainPeerSocket>(mSocket, this, rp) != HandleResult::NOT_EXISTS) return;

	_DEBUG_LOG(RED, L"{}", GetPacketTypeString(rp.GetPacketType()));
}

