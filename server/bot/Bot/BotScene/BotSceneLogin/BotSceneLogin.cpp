// ============================================================================
// myungdal tech-demo project
// 
// Author: 안명달 (Myungdal Ahn)
// Email: mooondal@gmail.com
// GitHub: https://github.com/myungdal/tech_demo.git
// ============================================================================

import Bot;
import ServerEnginePacket;
import ServerEnginePacketAutoGenerated;


BotSceneLogin::BotSceneLogin(BotPtr& bot)
	: 
	BotScene(bot)
{
	RegisterSeq(this, &BotSceneLogin::CF_CONNECT);
	RegisterSeq(this, &BotSceneLogin::REQ_GLOBAL_NOW);
	RegisterSeq(this, &BotSceneLogin::CF_REQ_PACKET_LIST);
	RegisterSeq(this, &BotSceneLogin::CM_REQ_SERVER_LIST);
	RegisterSeq(this, &BotSceneLogin::CM_REQ_ACCOUNT_USER_LIST);
	RegisterSeq(this, &BotSceneLogin::CM_REQ_ACCOUNT_USER_CREATE);
	RegisterSeq(this, &BotSceneLogin::CM_REQ_AUTH_TICKET);
	RegisterSeq(this, &BotSceneLogin::CF_REQ_USER_LOGIN);
	RegisterSeq(this, &BotSceneLogin::CD_REQ_STATIC_DATA_CHECKSUM);
	RegisterSeq(this, &BotSceneLogin::CD_REQ_STATIC_DATA);
	RegisterSeq(this, &BotSceneLogin::CD_REQ_USER_DATA);
	NextSeq();
}
void BotSceneLogin::OnHandshakeCompleted(MAYBE_UNUSED bool reconnected)
{
	_DEBUG_LOG(WHITE, L"[{}]", GetRawSocket());

	_DEBUG_LOG(WHITE, L"[{}][{}]", GetRawSocket(), GetBotId());

	if (GetSeq() == 0)
		NextSeq();
}

void BotSceneLogin::OnLostConnection()
{
	_DEBUG_LOG(WHITE, L"[{}][{}]", GetRawSocket(), GetBotId());
	TryChangeToReconnectScene();
}

bool BotSceneLogin::OnDispatchPacket(NetworkPacket& rp)
{
	HandleResult handleResult = DispatchPacket(GetRawSocket(), this, rp);
	if (handleResult == HandleResult::NOT_EXISTS)
	{
		_DEBUG_RED;
		return true;
	}
	return (handleResult == HandleResult::OK) ? true : false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HandleResult BotSceneLogin::OnPacket(MAYBE_UNUSED NetworkPacket& rp)
{
	HandleResult handleResult = DispatchPacketToParent<BotScene>(GetRawSocket(), this, rp);
	if (handleResult == HandleResult::NOT_EXISTS)
		_DEBUG_RED;
	return handleResult;
}

void BotSceneLogin::CF_CONNECT()
{
	ConnectToFront();
	_DEBUG_LOG(WHITE, L"[{}][{}]", GetRawSocket(), GetBotId());
}

void BotSceneLogin::REQ_GLOBAL_NOW()
{
	BotSocketUtil::SendToFront<REQ_GLOBAL_NOW::Writer> wp(*this, REQ);
	wp.SetHeader(GetBotContext().CurrPacketHeader());
	wp.SetValues(
		false,
		tClock.GetLocalNowMs()
	);
}

HandleResult BotSceneLogin::OnPacket(ACK_GLOBAL_NOW& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		ClockMs nowMs = tClock.GetLocalNowMs();
		ClockMs reqMs = rp.Get_reqMs();
		ClockMs delta = (nowMs > reqMs) ? (nowMs - reqMs) : 0ms;

		if (MAX_TIME_SYNC_DELTA >= delta)
		{
			gNetworkManager->SetupGlobalNow(rp.Get_ackNow());
			NextSeq();
		}
		else
			RetrySeq();
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_RED;
		RetrySeq();
		break;
	}

	return HandleResult::OK;
}

void BotSceneLogin::CF_REQ_PACKET_LIST()
{
	BotSocketUtil::SendToFront<CF_REQ_PACKET_LIST::Writer> wp(*this, REQ);
	wp.SetHeader(GetBotContext().CurrPacketHeader());
}

HandleResult BotSceneLogin::OnPacket(FC_ACK_PACKET_LIST& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	DevPacketConverter::DevPacketTypeMap devPacketTypeMap;

	for (const PACKET_DEV_DATA* packetDevData : rp.Get_packetDevDataList())
	{
		const PacketType clientPacketType = GetPacketTypeEnum(packetDevData->Get_packetName());
		const PacketType serverPacketType = packetDevData->Get_packetType();

		devPacketTypeMap.emplace(clientPacketType, serverPacketType);
	}

#ifdef _DEBUG
	gDevPacketConverter.SetDevPacketTypeMap(std::move(devPacketTypeMap));
#endif

	NextSeq();
	return HandleResult::OK;
}

void BotSceneLogin::CM_REQ_SERVER_LIST()
{
	BotSocketUtil::SendToFront<CM_REQ_SERVER_LIST::Writer> wp(*this, REQ);
}

HandleResult BotSceneLogin::OnPacket(MC_ACK_SERVER_LIST& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		GetBotContext().ServerList().clear();
		for (const SERVER* server : rp.Get_serverList())
			GetBotContext().ServerList().emplace_back(*server);

		NextSeq();
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		RetrySeq();
		break;
	}

	return HandleResult::OK;
}

void BotSceneLogin::CM_REQ_ACCOUNT_USER_LIST()
{
	auto [account, _] = gBotAccountManager->Find(GetBotId());

	BotSocketUtil::SendToFront<CM_REQ_ACCOUNT_USER_LIST::Writer> wp(*this, REQ);
	wp.SetHeader(GetBotContext().CurrPacketHeader());
	wp.SetValues(
		*account
	);
}

HandleResult BotSceneLogin::OnPacket(MC_ACK_ACCOUNT_USER_LIST& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		GetBotContext().AccountUserList().clear();
		for (const ACCOUNT_USER* accountUser : rp.Get_accountUserList())
			GetBotContext().AccountUserList().emplace_back(*accountUser);

		// 캐릭터가 이미 존재할 수 있기 때문에, 캐릭터 생성은 생략하고 인증 티켓 요청으로 건너뛴다
		JumpToSeq(this, &BotSceneLogin::CM_REQ_AUTH_TICKET);
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_RED;
		RetrySeq();
		break;
	}

	return HandleResult::OK;
}

void BotSceneLogin::CM_REQ_ACCOUNT_USER_CREATE()
{
	if (GetBotContext().ServerList().empty())
	{
		JumpToSeq(this, &BotSceneLogin::CM_REQ_SERVER_LIST);
		return;
	}

	auto [account, _] = gBotAccountManager->Find(GetBotId());

	PacketHeader packetHeader = GetBotContext().CurrPacketHeader();
	const ServerId firstServerId = GetBotContext().ServerList().front()->Get_c_server_id();
	packetHeader.SetServerId(firstServerId);
	
	std::wstring userName = GetBotName();

	BotSocketUtil::SendToFront<CM_REQ_ACCOUNT_USER_CREATE::Writer> wp(*this, REQ);
	wp.SetHeader(packetHeader);
	wp.SetValues(
		*account,
		userName.data()
	);
}

HandleResult BotSceneLogin::OnPacket(MC_ACK_ACCOUNT_USER_CREATE& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		GetBotContext().AccountUserList().clear();
		for (const ACCOUNT_USER* accountUser : rp.Get_accountUserList())
			GetBotContext().AccountUserList().emplace_back(*accountUser);

		NextSeq();
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_RED;
		RetrySeq();
		break;
	}

	return HandleResult::OK;
}

// 인증 요청
void BotSceneLogin::CM_REQ_AUTH_TICKET()
{
	if (GetBotContext().AccountUserList().empty())
	{
		JumpToSeq(this, &BotSceneLogin::CM_REQ_ACCOUNT_USER_CREATE);
		return;
	}

	const PacketKeep<ACCOUNT_USER>& accountUser = GetBotContext().AccountUserList().front();

	auto [account, _] = gBotAccountManager->Find(GetBotId());
	
	BotSocketUtil::SendToFront<CM_REQ_AUTH_TICKET::Writer> wp(*this, REQ);
	wp.SetHeader(GetBotContext().CurrPacketHeader());
	wp.SetValues(
		*account,
		accountUser->Get_c_user_id()
	);
}

// 인증 찾기 응답 받음
HandleResult BotSceneLogin::OnPacket(MC_ACK_AUTH_TICKET& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		GetBotContext().AuthTicket() = rp.Get_authTicket();

		// userId 가 셋팅되기 전이기 때문에 직접 셋팅함.
		// userId 가 셋팅된 후에는 Bot::OnDispatchPacketFront_async 에서 자동으로 셋팅 됨.
		GetBotContext().CurrPacketHeader() = rp.GetHeader();

		NextSeq();
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_RED;
		RetrySeq();
		break;
	}

	return HandleResult::OK;
}

// 로그인 요청
void BotSceneLogin::CF_REQ_USER_LOGIN()
{
	if (INVALID_UUID == GetBotContext().CurrPacketHeader().GetUserId())
		_DEBUG_BREAK;

	// 로그인 요청.
	BotSocketUtil::SendToFront<CF_REQ_USER_LOGIN::Writer> wp(*this, REQ);
	wp.SetHeader(GetBotContext().CurrPacketHeader());
	wp.SetValues(
		GetBotContext().AuthTicket()
	);
}

// 로그인 응답 받음
HandleResult BotSceneLogin::OnPacket(FC_ACK_USER_LOGIN& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		// 로그인 성공 정보를 컨텍스트에 셋팅
		GetBotContext().StaticDataChecksum() = rp.Get_staticDataChecksum();

		// 데이터 받기 시작.
		NextSeq();
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_LOG(RED, L"[{}], {}", GetBotId(), result);

		// 잘못된 인증 제거
		gBotAccountManager->Remove(GetBotId());
		gBotAccountManager->Save();

		JumpToSeq(this, &BotSceneLogin::CM_REQ_AUTH_TICKET);
		break;
	}

	return HandleResult::OK;
}

// 정적데이터 체크섬 요청
void BotSceneLogin::CD_REQ_STATIC_DATA_CHECKSUM()
{
	if(true == gStaticDataCatalog->IsSynced())
	{
		JumpToSeq(this, &BotSceneLogin::CD_REQ_USER_DATA);
		return;
	}

	// 내가 정적데이터 동기화 담당을 시도해 본다
	BotId expected = INVALID_BOT_ID;

	// memory_order:
	// - 성공(acq_rel): "정적데이터 동기화 담당자" 선점 자체가 동기화 지점이 된다.
	//   이후 로직(ResetSync/SetSyncing 등)이 선점 이전으로 재배치되지 않도록(보수적) acquire+release를 사용.
	// - 실패(relaxed): 실패 시에는 바로 재시도/대기만 하므로 추가 동기화가 불필요.
	if (mBotIdSyncingStaticData.compare_exchange_strong(expected, GetBotId(), std::memory_order_acq_rel, std::memory_order_relaxed))
	{
		if ((gStaticDataCatalog->ResetSync() && gStaticDataCatalog->SetSyncing()) || gStaticDataCatalog->SetSyncing())
		{
			BotSocketUtil::SendToFront<CD_REQ_STATIC_DATA_CHECKSUM::Writer> wp(*this, REQ);
			wp.SetHeader(GetBotContext().CurrPacketHeader());
		}
		else
			RetrySeq();
	}
	else
		RetrySeq();
}

// 정적데이터 체크섬 응답 받음
HandleResult BotSceneLogin::OnPacket(DC_ACK_STATIC_DATA_CHECKSUM& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
	{
		const size_t listSize0 = rp.Get_checksumList_size();
		//const size_t listSize1 = rp.Get_staticDataSizeList_size();
		const StaticDataSize* srcSizeList = rp.Get_staticDataSizeList();
		const Checksum* srcChecksumList = rp.Get_checksumList();

		gStaticDataCatalog->ExpectedChecksumForClient() = rp.Get_staticDataChecksum();
		gStaticDataCatalog->ExpectedSizeList().resize(listSize0, 0);
		gStaticDataCatalog->ExpectedChecksumList().resize(listSize0, {});		
		gStaticDataCatalog->BinaryList().resize(listSize0, nullptr);

		for (size_t i = 0; i < listSize0; ++i)
		{
			if ((gStaticDataCatalog->ExpectedSizeList().at(i) == srcSizeList[i]) &&
				(gStaticDataCatalog->ExpectedChecksumList().at(i) == srcChecksumList[i]))
			{
				continue;
			}

			gStaticDataCatalog->ExpectedSizeList().at(i) = srcSizeList[i];
			gStaticDataCatalog->ExpectedChecksumList().at(i) = srcChecksumList[i];

			if (gStaticDataCatalog->BinaryList().at(i))
			{
				_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
				gStaticDataCatalog->BinaryList().at(i) = nullptr;
			}
		}

		NextSeq();
		break;
	}
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_LOG(RED, L"[{}], {}", GetBotId(), result);
		JumpToSeq(this, &BotSceneLogin::CM_REQ_AUTH_TICKET);
		break;
	}

	return HandleResult::OK;
}

// 정적데이터 요청
void BotSceneLogin::CD_REQ_STATIC_DATA()
{
	// 데이터가 일치하지 않으면 데이터 요청
	auto [succeeded, i] = gStaticDataCatalog->BuildDataForClient();

	if (false == succeeded)
	{
		_ASSERT_CRASH(INVALID_STATIC_DATA_INDEX != i);

		// binary 공간 다시 할당
		if (gStaticDataCatalog->BinaryList().at(i))
		{
			_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
			gStaticDataCatalog->BinaryList().at(i) = nullptr;
		}

		gStaticDataCatalog->BinaryList().at(i) = _MALLOC<uint8_t>(gStaticDataCatalog->ExpectedSizeList().at(i));

		BotSocketUtil::SendToFront<CD_REQ_STATIC_DATA::Writer> wp(*this, REQ);
		wp.SetHeader(GetBotContext().CurrPacketHeader());
		wp.SetValues(
			i
		);
	}
	// 성공이면, 유저 데이터 요청
	else
	{			
		gStaticDataAccessor = std::make_shared<StaticDataAccessor>();
		gStaticDataAccessor->BuildView();
		gStaticDataCatalog->SetSynced();

		JumpToSeq(this, &BotSceneLogin::CD_REQ_USER_DATA);
	}
}

// 정적데이터 응답 받음
HandleResult BotSceneLogin::OnPacket(DC_ACK_STATIC_DATA& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
	{
		const StaticDataIndex i = rp.Get_index();
		const uint8_t* srcBin = rp.Get_staticDataBin();
		const StaticDataSize srcOffset = rp.Get_offset();
		const PacketSize srcSize = rp.Get_staticDataBin_size();

		_ASSERT_CRASH(gStaticDataCatalog->BinaryList().size() > static_cast<size_t>(i));

		gStaticDataCatalog->ExpectedSizeList().at(i) = srcSize;

		if (gStaticDataCatalog->BinaryList().at(i))
		{
			_FREE(reinterpret_cast<void*>(gStaticDataCatalog->BinaryList().at(i)));
			gStaticDataCatalog->BinaryList().at(i) = nullptr;
		}

		if (srcSize > 0)
		{
			gStaticDataCatalog->BinaryList().at(i) = _MALLOC<uint8_t>(srcSize);
			std::copy_n(srcBin, srcSize, gStaticDataCatalog->BinaryList().at(i) + srcOffset);
		}

		// 완료되었으면, 다음 StaticData 요청.
		if (1 == rp.Get_isCompleted())
			JumpToSeq(this, &BotSceneLogin::CD_REQ_STATIC_DATA);

		break;
	}
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_LOG(RED, L"[{}], {}", GetBotId(), result);
		_DEBUG_RED;

		JumpToSeq(this, &BotSceneLogin::CM_REQ_AUTH_TICKET);
		break;
	}

	return HandleResult::OK;
}

// 유저데이터 요청
void BotSceneLogin::CD_REQ_USER_DATA()
{
	BotSocketUtil::SendToFront<CD_REQ_USER_DATA::Writer> wp(*this, REQ);
	wp.SetHeader(GetBotContext().CurrPacketHeader());
}

// 유저데이터 응답 받음
HandleResult BotSceneLogin::OnPacket(DC_ACK_USER_DATA& rp)
{
	const Result result = rp.GetHeader().GetPacketResult();
	ReportResultAndYield(result);

	switch (result)
	{
	case Result::SUCCEEDED:
		CacheUserData(rp.Get_userData());

		NextSeq();
		break;
	case Result::RETRY_LATER:
		RetrySeq();
		break;
	default:
		_DEBUG_LOG(RED, L"[{}], {}", GetBotId(), result);
		_DEBUG_RED;

		JumpToSeq(this, &BotSceneLogin::CM_REQ_AUTH_TICKET);
		break;
	}

	return HandleResult::OK;
}
