# 데모 시나리오

## 🎬 시나리오 개요

| # | 시나리오 | 소요시간 | 난이도 | 목적 |
|---|----------|----------|--------|------|
| 1 | 새 패킷 추가 | 5분 | ⭐ | 자동 생성 시스템 시연 |
| 2 | DB 테이블 추가 | 10분 | ⭐⭐ | DB 자동화 시연 |
| 3 | 신규 시스템 구현 | 20분 | ⭐⭐⭐ | AI 페어 프로그래밍 시연 |

---

## 시나리오 1: 새 패킷 추가

### 목표

> "새 우편 알림 패킷을 추가하고, 서버/클라이언트 코드가 자동 생성되는 것을 보여준다"

### 준비물

- resource/packet.xlsx 열기
- bat/generate_all.bat 준비
- VS Code 또는 Cursor 열기

### 스크립트 (5분)

#### Step 1: 요구사항 설명 (30초)

```
"새 우편이 도착하면 클라이언트에 알림을 보내는 기능이 필요합니다.
 NOTIFY_NEW_MAIL 패킷을 추가하겠습니다."
```

#### Step 2: 패킷 정의 (1분)

```
1. resource/packet.xlsx 열기
2. 새 행 추가:
   - 패킷명: NOTIFY_NEW_MAIL
   - 방향: S2C (Server → Client)
   - 필드:
     - mailId: int64
     - senderName: string
     - title: string
     - hasAttachment: bool
3. 저장
```

#### Step 3: 코드 생성 (1분)

```powershell
.\bat\generate_all.bat
```

#### Step 4: 생성된 코드 확인 (2분)

```
# 서버 측 생성 파일
server/ServerEngine/Packet/NetworkPacketAutoGenerated/PACKET_NOTIFY_NEW_MAIL.h

# 클라이언트 측 생성 파일
client/Client/Source/.../NetworkPacketAutoGenerated/PACKET_NOTIFY_NEW_MAIL.h
```

#### Step 5: 마무리 (30초)

```
"패킷 정의 하나로 서버/클라이언트 양쪽 코드가 자동 생성되었습니다.
 타입 안전성이 보장되고, 버전 불일치 걱정이 없습니다."
```

---

## 시나리오 2: DB 테이블 추가

### 목표

> "새 이벤트 로그 테이블을 추가하고, CRUD 코드가 자동 생성되는 것을 보여준다"

### 준비물

- resource/db/log/ 폴더 접근
- bat/dbAutomation/ 스크립트 준비
- SQL 클라이언트 (선택)

### 스크립트 (10분)

#### Step 1: 요구사항 설명 (30초)

```
"이벤트 참여 로그를 저장하는 테이블이 필요합니다.
 EventParticipationLog 테이블을 추가하겠습니다."
```

#### Step 2: SQL 스키마 작성 (2분)

```sql
-- resource/db/log/event_participation_log.sql

CREATE TABLE EventParticipationLog (
    Id              BIGINT          NOT NULL AUTO_INCREMENT,
    UserId          BIGINT          NOT NULL,
    EventId         INT             NOT NULL,
    EventType       TINYINT         NOT NULL,
    RewardItemId    INT             NULL,
    RewardCount     INT             NULL,
    CreatedAt       DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (Id),
    INDEX idx_user_event (UserId, EventId),
    INDEX idx_created (CreatedAt)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### Step 3: AI와 대화 (3분)

```
Cursor에서:
"이 SQL 스키마를 기반으로 C++ 서버용 CRUD 코드를 작성해줘.
 기존 DbUtil 패턴을 따라서."
```

#### Step 4: 코드 생성 확인 (2분)

```cpp
// 생성된 코드 예시
class EventParticipationLogRepository
{
public:
    static bool Insert(const EventParticipationLog& log);
    static std::vector<EventParticipationLog> FindByUserId(int64_t userId);
    static std::vector<EventParticipationLog> FindByEventId(int32_t eventId);
};
```

#### Step 5: 테스트 (2분)

```cpp
// 간단한 삽입 테스트
EventParticipationLog log;
log.UserId = 12345;
log.EventId = 1001;
log.EventType = EventType::DAILY_CHECK;
EventParticipationLogRepository::Insert(log);
```

#### Step 6: 마무리 (30초)

```
"SQL 스키마 하나로 완전한 Repository 클래스가 생성되었습니다.
 수동으로 CRUD 코드를 작성할 필요가 없습니다."
```

---

## 시나리오 3: 신규 시스템 구현

### 목표

> "출석 보상 시스템을 AI와 페어 프로그래밍으로 구현한다"

### 준비물

- Cursor IDE
- 기존 보상 시스템 코드 참조 준비
- 테스트 환경 (서버 + 클라이언트)

### 스크립트 (20분)

#### Step 1: 요구사항 정의 (2분)

```
Cursor에서 AI에게:
"출석 보상 시스템을 구현해줘.
 요구사항:
 - 하루 한 번 출석 가능
 - 연속 출석 시 추가 보상
 - 7일 연속 출석 시 특별 보상
 - 월간 출석 현황 조회 기능"
```

#### Step 2: AI 설계 제안 검토 (3분)

```
AI가 제안하는 내용:
1. AttendanceSystem 클래스 구조
2. DB 테이블 스키마
3. 패킷 정의
4. 보상 로직

검토 포인트:
- 기존 시스템과의 일관성
- 확장성
- 성능 고려사항
```

#### Step 3: DB 스키마 생성 (2분)

```sql
-- AI가 생성한 스키마 리뷰 후 적용
CREATE TABLE UserAttendance (
    UserId          BIGINT      NOT NULL,
    AttendanceDate  DATE        NOT NULL,
    ConsecutiveDays INT         NOT NULL DEFAULT 1,
    RewardReceived  TINYINT     NOT NULL DEFAULT 0,
    CreatedAt       DATETIME    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (UserId, AttendanceDate),
    INDEX idx_user (UserId)
);
```

#### Step 4: 패킷 정의 (2분)

```
packet.xlsx에 추가:
- REQ_ATTENDANCE_CHECK: 출석 체크 요청
- RES_ATTENDANCE_CHECK: 출석 체크 응답 (결과, 보상 목록, 연속 일수)
- REQ_ATTENDANCE_INFO: 출석 현황 요청
- RES_ATTENDANCE_INFO: 출석 현황 응답 (월간 데이터)
```

#### Step 5: 서버 로직 구현 (5분)

```cpp
// AI가 생성한 코드를 리뷰하며 수정
class AttendanceSystem
{
public:
    // 출석 체크
    AttendanceResult CheckIn(int64_t userId);
    
    // 월간 출석 현황
    MonthlyAttendanceInfo GetMonthlyInfo(int64_t userId, int year, int month);
    
private:
    // 연속 출석 일수 계산
    int32_t CalculateConsecutiveDays(int64_t userId);
    
    // 보상 결정
    std::vector<RewardItem> DetermineRewards(int32_t consecutiveDays);
};
```

#### Step 6: 리뷰 & 수정 (4분)

```
AI 코드 리뷰 체크리스트:
□ 스레드 안전성 (동시 출석 체크 방지)
□ 시간대 처리 (서버 시간 vs 로컬 시간)
□ 중복 출석 방지
□ 에러 처리
□ 로깅
```

#### Step 7: 테스트 & 마무리 (2분)

```
1. 서버 실행
2. 테스트 클라이언트로 출석 체크
3. 연속 출석 시뮬레이션
4. 결과 확인
```

---

## 📹 녹화 팁

### 화면 구성

```
┌─────────────────────────────────────────────────────────┐
│                    Cursor IDE (80%)                      │
│  ┌─────────────────┬─────────────────────────────────┐  │
│  │   파일 탐색기    │         코드 에디터              │  │
│  │                 │                                  │  │
│  │                 │                                  │  │
│  │                 │                                  │  │
│  │                 ├─────────────────────────────────┤  │
│  │                 │      AI Chat (Cursor)           │  │
│  └─────────────────┴─────────────────────────────────┘  │
├─────────────────────────────────────────────────────────┤
│                  터미널 (20%)                            │
└─────────────────────────────────────────────────────────┘
```

### 녹화 설정

| 항목 | 권장값 |
|------|--------|
| 해상도 | 1920x1080 |
| FPS | 30 |
| 마이크 | 필수 (설명 음성) |
| 글꼴 크기 | 16pt 이상 (가독성) |
| 테마 | 다크 모드 권장 |

### 말하기 팁

```
✅ DO
• 천천히, 명확하게
• 각 단계 설명 후 실행
• 실수해도 자연스럽게 수정
• AI 결과물 리뷰 과정 보여주기

❌ DON'T
• 너무 빠르게 진행
• 설명 없이 클릭만
• 완벽하려고 다시 녹화 (자연스러움이 중요)
```

---

## ⏱️ 시간 배분 가이드

### 5분 데모 (시나리오 1)

```
0:00 - 0:30  인트로
0:30 - 1:30  패킷 정의
1:30 - 2:30  코드 생성
2:30 - 4:30  결과 확인
4:30 - 5:00  마무리
```

### 10분 데모 (시나리오 2)

```
0:00 - 0:30  인트로
0:30 - 2:30  SQL 스키마 작성
2:30 - 5:30  AI 코드 생성
5:30 - 8:30  리뷰 & 수정
8:30 - 10:00 테스트 & 마무리
```

### 20분 데모 (시나리오 3)

```
0:00 - 2:00  인트로 & 요구사항
2:00 - 5:00  AI 설계 검토
5:00 - 7:00  DB/패킷 정의
7:00 - 14:00 서버 로직 구현
14:00 - 18:00 리뷰 & 수정
18:00 - 20:00 테스트 & 마무리
```
